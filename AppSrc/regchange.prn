Compiling Program: L:\Vdf6\Develop\EmporSap\AppSrc\regchange.src
Memory Available: 2147483647
1>Use AllEntSc
Using pre-compiled package ALLENTSC
INCLUDING FILE: ALLENTSC.PKI
30310>
30310>Register_Object Client_Area
30310>
30310>//AB-StoreTopStart
30310>Object ProgramWorkspace is a WorkspaceSub
30312>    Set WorkspaceName to CURRENT$WORKSPACE
30313>    Set kEnter_Next_State to True
30314>//    Set ModuleName    to 'ProgramName' // Special module name.
30314>//    Set HelpName      to 'HelpName.hlp'// Please provide the name of your Windows help file.
30314>End_Object
30315>
30315>Use Help_Ids.inc // Developer should provide this file of help context links.
INCLUDING FILE: HELP_IDS.INC
30315>>>// Help_ids.inc
30315>>>//
30315>>>// Context ids for the order entry system. This uses
30315>>>// help file ordentry.hlp.
30315>>>//
30315>>>// This is a sample version. YOU must supply
30315>>>// the ID values
30315>>>
30315>>>//  Generic Context Ids
30315>>>//
30315>>>
30315>>>// It is expected that file-names ids will be the same as their
30315>>>// filenumber.
30315>>>
30315>>>
30315>>>//  View and selection-list specific context ids
30315>>>//
30315>>>//..........add view, object, selection-list ids here....
30315>Use Std_Help.pkg
INCLUDING FILE: STD_HELP.PKG
30315>>>// STD_HELP.PKG
30315>>>//
30315>>>// Global Help Object
30315>>>//
30315>>>//  Creates all Help Support required to access WINDOWs help system
30315>>>//  with DataFlex. Creates a global object named Help_Object.
30315>>>//
30315>>>//  9/19/97 JJT - Modified to define stadnard help Ids if they are undefined
30315>>>
30315>>>use DFHlpSys // Context Sensitive Help Support
30315>>>
30315>>>
30315>>>// This file needs to be provided by the developer. It will contain
30315>>>// symbolic replacements for the ID integer values used to access the
30315>>>// the windows help file's topics.
30315>>>//
30315>>>use Help_ids.inc
30315>>>
30315>>>// If the following are not defined in help_ids.inc,
30315>>>//  create default 0 values for them
30315>>>Define GeneralHelpId    for    0
30315>>>Define KeysHelpId       for    0
30315>>>Define FileHelpId       for    0
30315>>>Define ErrorHelpId      for    0  // probably not used in VDF
30315>>>Define IndexHelpId      for    0  // probably not used in VDF
30315>>>
30315>>>object Help_Object is a HelpSystem // global help object
30317>>>
30317>>>   Set Help_Id_General to GeneralHelpId    // these should all be defined
30318>>>   Set Help_Id_Index   to IndexHelpId      // in help_ids.inc.
30319>>>   Set Help_Id_Keys    to KeysHelpId       //
30320>>>   Set Help_Id_Files   to FileHelpId       //
30321>>>   Set Help_Id_Errors  to ErrorHelpId      //
30322>>>
30322>>>end_object
30323>Integer giWait_Obj
30323>
30323>
30323>
30323>// General Functions-Procedures and Variables
30323>Use Globals.Inc
INCLUDING FILE: GLOBALS.INC
30323>>>
30323>>>        String  gs_Selected_Company_Code
30323>>>        String  gs_Selected_Branch_Code
30323>>>        Integer gi_Selected_Year
30323>>>        String gs_Selected_Year_Recr
30323>>>        String  gs_Module_Code
30323>>>
30323>>>
30323>>>//Open Currency
30323>>>//Function CurrDigits Global String asCurr Returns Integer
30323>>>//    Integer liDecX
30323>>>//    Clear Currency
30323>>>//    move asCurr to Currency.Currency_C_Code
30323>>>//    Find Eq Currency By Index.1
30323>>>//    move Currency.Currency_Dec to liDecX
30323>>>//    Function_Return liDecX
30323>>>//End_Function // CurrDigits
30323>>>
30323>>>Open Nomisma
INCLUDING FILE: NOMISMA.FD
30325>>>Open SysCurXr
INCLUDING FILE: SYSCURXR.FD
30327>>>
30327>>>Function fiDekadika_Nomismatos Global String asNomisma Returns Integer
30328>>>    Move (Trim(asNomisma)) to asNomisma
30329>>>    Clear Nomisma
30330>>>    If ( asNomisma<>'' ) Move asNomisma         to Nomisma.Nomisma_Code
30333>>>    Else                 Move SysCurXr.C_Code0  to Nomisma.Nomisma_Code
30335>>>    Find eq Nomisma By Index.1 // Nomisma:Index.1:Nomisma_Code
30336>>>>
30336>>>    Function_Return Nomisma.Dekadika
30337>>>End_Function //
30338>>>
30338>>>Function fsgCode_W_Zeroes Global Integer aiCode Integer aiPlaces Returns String
30339>>>    String rVal
30340>>>    Integer iLength iInt
30340>>>    Move aiCode to rVal
30341>>>    Move (trim(rVal)) to rVal
30342>>>    For iInt From 1 to (aiPlaces-(Length(rVal)))
30348>>>>
30348>>>        Move (Insert('0',rVal,1)) to rVal
30349>>>    Loop
30350>>>>
30350>>>    Function_Return rVal
30351>>>End_Function
30352>>>
30352>>>Function fsgCode_n_Zeroes Global number aiCode Integer aiPlaces Returns String
30353>>>    String rVal
30354>>>    Integer iLength iInt ipos
30354>>>    Move aiCode to rVal
30355>>>    Move (trim(rVal)) to rVal
30356>>>    MOVE (aiPlaces-(Length(rVal))) to ipos
30357>>>    For iInt From 1 to ipos
30363>>>>
30363>>>        Move (Insert('0',rVal,1)) to rVal
30364>>>    Loop
30365>>>>
30365>>>    Function_Return rVal
30366>>>End_Function
30367>>>
30367>>>
30367>>>Open Year
INCLUDING FILE: YEAR.FD
30369>>>Procedure EnumDDsForRebuildConstrain for DataDictionary integer aiMsg integer ahId
30370>>>    Send aiMsg to Self
30371>>>End_Procedure
30372>>>
30372>>>Procedure DoRefindYear for baseclass Integer aiPanel Integer aiYearDD
30373>>>    Integer liChanged
30374>>>
30374>>>    If ((aiYearDD = 0) or (Main_File(aiYearDD)<>Year.File_Number)) ;        Procedure_Return (Message_Box("Invalid Year_DD","Developer's Warning",MB_OK,MB_ICONWARNING))
30377>>>    If (Not(Current_Record(aiYearDD))) Begin
30379>>>        Get Should_Save of aiPanel to liChanged
30380>>>        Send Clear to aiYearDD
30381>>>        Move gs_Selected_Company_Code to Year.Company_Code
30382>>>        Move gs_Selected_Branch_Code  to Year.Branch_Code
30383>>>        Move gi_Selected_Year         to Year.Year_Year
30384>>>        Send Find to aiYearDD Eq 1 //Year.Index.1 - company_code+ranch_code+year_year
30385>>>        If (Not(liChanged)) Set Changed_State of aiPanel to False
30388>>>    End
30388>>>>
30388>>>End_Procedure
30389>>>
30389>>>Procedure RebuildConstrainIfYearChanged for baseclass Integer aiPanel String asCurrentYearRecr Integer aiYearDDId
30390>>>    Integer liSrvr
30391>>>    String  lsCurrentYearRecr
30391>>>
30391>>>    If (asCurrentYearRecr <> gs_Selected_Year_Recr) Begin
30393>>>        Broadcast Send EnumDDsForRebuildConstrain to aiPanel msg_Rebuild_Constraints Self
30395>>>    End
30395>>>>
30395>>>    Send DoRefindYear aiPanel aiYearDDId //(Year_DD(Self))
30396>>>    Get Server of aiPanel to liSrvr
30397>>>    // Respects Default values
30397>>>    If (liSrvr) If (Not(Current_Record(liSrvr))) Send Request_Clear to aiPanel
30402>>>End_Procedure
30403>>>
30403>>>//                                       ’¦ View            Property «¦¬ View             ’¦ Year DDO «¦¬ View
30403>>>//                                                          Holds the current year rec0
30403>>>// ‰¢ã©ž : Send RbldConstrIfYearChanged (Gplan_Test(Self))  (psCurrentYearRecr(Self))     (Year_DD(Self))
30403>>>
30403>>>
30403>>>Function fiRefindYear Global Returns Integer
30404>>>    Clear Year
30405>>>    Move gs_Selected_Company_Code to Year.Company_Code
30406>>>    Move gs_Selected_Branch_Code  to Year.Branch_Code
30407>>>    Move gi_Selected_Year         to Year.Year_Year
30408>>>    Find eq Year by Index.1 //company_code+ranch_code+year_year
30409>>>>
30409>>>    Function_Return (Found = 0)
30410>>>End_Function //fiRefindYear
30411>>>
30411>>>Procedure DoRunApplication for Baseclass String sAppName
30412>>>    string sRuntime  lsStr
30413>>>
30413>>>    Append lsStr 'C:\Dns.bat ' sAppName
30415>>>    RunProgram Wait  lsStr
30416>>>
30416>>>//    get_profile_string "defaults" "VDFBinDir" to sRuntime
30416>>>//    append sRuntime "\dfrun " sAppName
30416>>>    Append sRuntime 'C:\Program Files\Accessories\WORDPAD.EXE ' sAppName
30418>>>    runprogram background sRuntime
30419>>>End_procedure // DoRunApplication
30420>>>
30420>>>// Run the Editor
30420>>>Procedure DoRunEditor for Baseclass String asFile
30421>>>    string sRunPath lsWspcName
30422>>>    Move (WorkspaceName(ProgramWorkspace(Self))) to lsWspcName
30423>>>    get_profile_string ("workspaces\"+lsWspcName) "programpath" to sRunPath
30426>>>    //append sRunPath "\Editor "  asFile //// js 15/03/2002 " " lsWspcName
30426>>>    Move (Replace('.',asFile,'')) to asFile
30427>>>    append sRunPath asFile //// js 15/03/2002 " " lsWspcName
30428>>>    send DoRunApplication sRunPath
30429>>>End_Procedure // DoRunEditor
30430>>>
30430>>>//--------------------------------------
30430>>>
30430>>>//start of global functions and procedures
30430>>>
30430>>>
30430>>>//®¨ž© £¦§¦ œå«˜  ˜§æ: ˜) gmoves.dd    :private.update_gmhnes_ghmnies
30430>>>Function gsfFind_Previous Global String lsCode;                                 String lsDelimiter;                                 Returns String
30431>>>         String  lsTemp_Code1 lsTemp_Code2
30432>>>         Integer liCounter
30432>>>
30432>>>         //1.˜­˜å¨œ©ž ¡œ¤é¤
30432>>>         Move (Trim(lsCode)) to lsCode                                  //§® 30.12.345
30433>>>
30433>>>         //2.˜¤« ©«¨¦­ã
30433>>>         For liCounter From 1 to (Length(lsCode))
30439>>>>
30439>>>             Move (Insert(;                           (Mid(lsCode,1,liCounter)),;                           lsTemp_Code1,;                           1;                         )) to lsTemp_Code1                             //§® 543.21.03
30440>>>         Loop
30441>>>>
30441>>>
30441>>>         //3.˜­˜å¨œ©ž ¡œ¤é¤ (›â¤ ®¨œ áœ«˜ , safety only)
30441>>>         Move (Trim(lsTemp_Code1)) to lsTemp_Code1
30442>>>
30442>>>         //4.§˜å¨¤à £æ¤¦ «¦ ›œ¥ æ £â¨¦ª «¦¬ ˜¤«å©«¨¦­¦¬, £œ«á «¦ §¨é«¦ delimiter
30442>>>         Move (Right(;                      lsTemp_Code1,;                      ((Length(lsTemp_Code1))-((Pos(lsDelimiter,lsTemp_Code1))));                    )) to lsTemp_Code1                                  // §® 21.03
30443>>>
30443>>>         //5.¥˜¤á ˜¤« ©«¨¦­ã «¦¬ ˜¤«å©«¨¦­¦¬
30443>>>         For liCounter from 1 to (Length(lsTemp_Code1))
30449>>>>
30449>>>             Move (Insert(;                           (Mid(lsTemp_Code1,1,liCounter)),;                           lsTemp_Code2,;                           1;                         )) to lsTemp_Code2                             //§® 30.12
30450>>>         Loop
30451>>>>
30451>>>
30451>>>         Function_Return (Trim(lsTemp_Code2))
30452>>>End_Function //gsffind_previous
30453>>>
30453>>>
30453>>>Function gifSystem_Check Returns Integer
30454>>>         Integer liF_Gtypkins liF_Garicls liF_Gmoves liF_Gplans liF_Gmhnes liF_Ghmnies
30455>>>         Integer liS_Gtypkins liS_Garicls liS_Gmoves liS_Gplans liS_Gmhnes liS_Ghmnies
30455>>>//       Clear Company
30455>>>//       Find Gt Company.Recnum
30455>>>//       While (Found = 1)
30455>>>//             Add Company.Company_NumGtypkin to liS_Gtypkins § Ÿ˜¤é© ©«¦ sysfile ¤˜ «˜ ¡˜¨˜«áà ˜¬«á
30455>>>//             Add Company.Company_NumGarticl to liS_Garticls
30455>>>//             Add Company.Company_NumGmoves  to liS_Gmoves
30455>>>//             //d Company.Company_NumGtypkin to liS_Gtypkins
30455>>>//             Add Company.Company_NumGplan   to liS_GPlans
30455>>>//             Add Company.Company_NumGmhnes  to liS_Gmhnes
30455>>>//             Add Company.Company_NumGhmnies to liS_Ghmnies
30455>>>//             Find Gt Company.Recnum
30455>>>//       Loop
30455>>>//
30455>>>//       Get_Attribute {attribute} [of {file-handle} ;
30455>>>//                        [{field-num} | {index-num} [{segment-num}]]] ;
30455>>>//                        To {variable}
30455>>>//
30455>>>//       Get_Attribute DF_FILE_RECORDS_USED of Gtypkin.File_Number to liF_Gtypkins
30455>>>//       Get_Attribute DF_FILE_RECORDS_USED of Garticl.File_Number to liF_Garticls
30455>>>//       Get_Attribute DF_FILE_RECORDS_USED of Gmoves.File_Number  to liF_Gmoves
30455>>>//       //t_Attribute DF_FILE_RECORDS_USED of Gtypkin.File_Number to liF_Gtypkins
30455>>>//       Get_Attribute DF_FILE_RECORDS_USED of Gplan.File_Number   to liF_Gplans
30455>>>//       Get_Attribute DF_FILE_RECORDS_USED of Gmhnes.File_Number  to liF_Gmhnes
30455>>>//       Get_Attribute DF_FILE_RECORDS_USED of Ghmnies.File_Number to liF_Ghmnies
30455>>>//
30455>>>
30455>>>//       //â¢œš®¦ª DF_FILE_MAX_RECORDS+ £œ records used
30455>>>
30455>>>//       //â¢œš®¦ª last rec0 = sysrec rec0
30455>>>
30455>>>    Function_Return 0
30456>>>End_Function //gifSystem_Check
30457>>>
30457>>>/////////////////////////////////////////////////////////////////
30457>>>//‚ ˜ §œ› ˜ Numeric £œ«˜™¢ž«¦¬ £ã¡¦¬ª, £œ ž ®à¨åª ›œ¡˜› ¡á  JS
30457>>>Function Sfi_All_Numbers Global Number anValue Integer aiLengthAkeraios Integer aiLengthDekadika Returns String
30458>>>
30458>>>    String  lsRetval lsValue lsAkeraios lsDekadika
30459>>>    Integer liInt liInteger iTimes iStart
30459>>>    Number  lnDecimals
30459>>>
30459>>>    Move (Integer(anValue))                                         to liInteger
30460>>>    Move (Round(AnValue-(Integer(anValue))*(10^aiLengthDekadika)))  to lnDecimals
30461>>>
30461>>>    Move liInteger              to lsAkeraios
30462>>>    Move lnDecimals             to lsDekadika
30463>>>    Move (Trim(lsAkeraios))     to lsAkeraios
30464>>>    Move (Trim(lsDekadika))     to lsDekadika
30465>>>
30465>>>    Move (Length(lsAkeraios)) to iStart
30466>>>    For iTimes From iStart to (aiLengthAkeraios-1)
30472>>>>
30472>>>        Insert "0" in lsAkeraios at 1
30474>>>    Loop
30475>>>>
30475>>>    Move (Trim(lsAkeraios)) to lsAkeraios
30476>>>
30476>>>    Move (Length(lsDekadika)) to iStart
30477>>>    For iTimes From iStart to (aiLengthDekadika-1)
30483>>>>
30483>>>        Move (Append(lsDekadika,"0")) to lsDekadika
30484>>>    Loop
30485>>>>
30485>>>    Move (Trim(lsDekadika)) to lsDekadika
30486>>>
30486>>>    If (aiLengthDekadika=0) Move '' to lsDekadika
30489>>>    Move '' to lsRetVal
30490>>>    Move (Pad((lsAkeraios-lsDekadika),(aiLengthAkeraios+aiLengthDekadika))) to lsRetval
30491>>>    Function_Return lsRetval
30492>>>End_Function //sfi_All_Numbers  ‚ ˜ §œ› ˜ Numeric £œ«˜™¢ž«¦¬ £ã¡¦¬ª
30493>>>              //                 £œ ž ®à¨åª ›œ¡˜› ¡á (JS)
30493>>>
30493>>>Open Codemast
30495>>>
30495>>>
30495>>>Function gsfCode_Mast Global String lsType String lsValue Returns String
30496>>>         Clear Codemast
30497>>>         Move lsType  to Codemast.Type
30498>>>         Move lsValue to Codemast.Code
30499>>>         Find Eq Codemast by Index.1 //type+code
30500>>>>
30500>>>         Function_Return Codemast.Description
30501>>>End_Function //code_mast
30502>>>
30502>>>
30502>>>Open Branch
INCLUDING FILE: BRANCH.FD
30504>>>Function fsgCode_With_Zeroes Global Integer aiCode    ;                                    Integer aiPlaces  ;                                    String asCompany  ;                                    String asBranch   ;                               Returns String
30505>>>    String rVal
30506>>>    Integer iInt
30506>>>    Clear Branch
30507>>>    Move asCompany  to Branch.Company_Code
30508>>>    Move asBranch   to Branch.Branch_Code
30509>>>    Find Eq Branch by Index.1
30510>>>>
30510>>>    If (Trim(Branch.Tomeas_Code)<>'') Move (Trim(Branch.Tomeas_Code)) to asBranch
30513>>>    Move (Trim(asCompany))  to asCompany
30514>>>    Move (Trim(asBranch))   to asBranch
30515>>>    If (Length(asCompany)=1) Insert '0' In asCompany At 1
30519>>>    If (Length(asBranch) =1) Insert '0' In asBranch  At 1
30523>>>    Move ''                                           to rVal
30524>>>    Move (Sfi_All_Numbers(aiCode,aiPlaces,0))         to rVal
30525>>>    Move (Append((asCompany+'.'+asBranch+'.'),rVal))  to rVal
30526>>>    Move (Trim(rVal))                                 to rVal
30527>>>    Function_Return rVal
30528>>>End_Function
30529>>>
30529>>>Function fsgStripCodeFromID Global String asID Returns Integer
30530>>>      Integer iLen iPos iInt
30531>>>      If (Trim(asID)='') Function_Return 0
30534>>>      Move (Trim  (asID)) to asID
30535>>>      Move (Length(asID)) to iLen
30536>>>      For iInt From 1     to iLen
30542>>>>
30542>>>          If (Mid(asID,1,iInt)='.') Move iInt to iPos
30545>>>      Loop
30546>>>>
30546>>>      Function_Return (Right(asID,(iLen-iPos)))
30547>>>End_Function
30548>>>
30548>>>Function fsCityDescr Global Integer aiCityID Returns String
30549>>>    String rVal
30550>>>    Open Cities
INCLUDING FILE: CITIES.FD
30552>>>    Clear Cities
30553>>>    Move aiCityID to Cities.City_ID
30554>>>    Find Eq Cities By Index.1
30555>>>>
30555>>>    If (Found=1) Move Cities.City_descr to rVal
30558>>>    Else         Move '' to rVal
30560>>>    Function_Return rVal
30561>>>End_Function
30562>>>
30562>>>Function fiTownIDFromCity Global Integer aiCityID Returns Integer
30563>>>    Open Cities
30565>>>    Clear Cities
30566>>>    Move aiCityID to Cities.City_ID
30567>>>    Find Eq Cities By Index.1
30568>>>>
30568>>>    Function_Return Cities.Town_ID
30569>>>End_Function
30570>>>
30570>>>Function fiCountryIDFromTown Global Integer aiTownID Returns Integer
30571>>>    Open Towns
INCLUDING FILE: TOWNS.FD
30573>>>    Clear Towns
30574>>>    Move aiTownID to Towns.Town_ID
30575>>>    Find Eq Towns By Index.1
30576>>>>
30576>>>    Function_Return Towns.Country_ID
30577>>>End_Function
30578>>>
30578>>>Function fsTownDescr Global Integer aiTownID Returns String
30579>>>    String rVal
30580>>>    Open Towns
30582>>>    Clear Towns
30583>>>    Move aiTownID to Towns.Town_ID
30584>>>    Find Eq Towns By Index.1
30585>>>>
30585>>>    If (Found=1) Move Towns.Town_descr to rVal
30588>>>    Else         Move '' to rVal
30590>>>    Function_Return rVal
30591>>>End_Function
30592>>>
30592>>>Function fsCountryDescr Global Integer aiCountryID Returns String
30593>>>    String rVal
30594>>>    Open Country
INCLUDING FILE: COUNTRY.FD
30596>>>    Clear Country
30597>>>    Move aiCountryID to Country.Country_ID
30598>>>    Find Eq Country By Index.1
30599>>>>
30599>>>    If (Found=1) Move Country.Country_descr to rVal
30602>>>    Else         Move '' to rVal
30604>>>    Function_Return rVal
30605>>>End_Function
30606>>>
30606>>>Function fsAreaDescr Global Integer aiAreaID Returns String
30607>>>    String rVal
30608>>>    Open Areas
INCLUDING FILE: AREAS.FD
30610>>>    Clear Areas
30611>>>    Move aiAreaID to Areas.Area_ID
30612>>>    Find Eq Areas By Index.1
30613>>>>
30613>>>    If (Found=1) Move Areas.Area_descr to rVal
30616>>>    Else         Move '' to rVal
30618>>>    Function_Return rVal
30619>>>End_Function
30620>>>
30620>>>Function fsConvert_Time_Number_To_String_With_Zeroes Global Number anTime Returns String
30621>>>    Local String rVal lsTmp lsOO lsLL
30622>>>    Local Number lnOO lnLL
30622>>>
30622>>>    Move '' to lsOO
30623>>>    Move '' to lsLL
30624>>>    Move '' to rVal
30625>>>
30625>>>    Move (Integer(anTime))                              to lnOO
30626>>>
30626>>>    Move ((anTime - (Integer(anTime))) * 100)           to lnLL
30627>>>
30627>>>    If (lnOO<10) Move (Append(lsOO,'0'+(String(lnOO)))) to lsOO
30630>>>    Else         Move (String(lnOO))                    to lsOO
30632>>>    Move (Trim(lsOO))                                   to lsOO
30633>>>
30633>>>    If (lnLL<10) Move (Append(lsLL,'0'+(String(lnLL)))) to lsLL
30636>>>    Else         Move (String(lnLL))                    to lsLL
30638>>>    Move (Trim(lsLL))                                   to lsLL
30639>>>
30639>>>    Move (Append(rVal,(lsOO+':'+lsLL))) to rVal
30640>>>
30640>>>    Move (Trim(rVal)) to rVal
30641>>>
30641>>>    Function_Return rVal
30642>>>End_Function
30643>>>
30643>>>Function fnConvert_Minutes_to_Time Global Integer aiMinutes Returns Number
30644>>>    Local Number rVal nOres nLepta
30645>>>    Move (Integer(aiMinutes/60))    to nOres
30646>>>    Move (    Mod(aiMinutes,60))    to nLepta
30647>>>    Move (nOres+(nLepta/100))       to rVal
30648>>>    Function_Return rVal
30649>>>End_Function
30650>>>
30650>>>Function fiConvert_Time_to_Minutes Global Number anTime Returns Integer
30651>>>    Local Integer rVal
30652>>>    Move ((Integer(anTime)*60)+((anTime-(Integer(anTime)))*100)) to rVal
30653>>>    Function_Return rVal
30654>>>End_Function
30655>>>
30655>>>Function fiConvert_Difference_StartTime_EndTime_to_Minutes Global   Number anStartTime  ;                                                                    Number anEndTime    ;                                                                    Returns Integer
30656>>>    Local Integer rVal iMinStart iMinEnd
30657>>>
30657>>>    If (anStartTime >= anEndTime) Add 24 to anEndTime
30660>>>
30660>>>    Move ((Integer(anStartTime)*60)+((anStartTime-(Integer(anStartTime)))*100))  to iMinStart
30661>>>    Move ((Integer(anEndTime  )*60)+((anEndTime  -(Integer(anEndTime  )))*100))  to iMinEnd
30662>>>    Move (iMinEnd-iMinStart)                                                     to rVal
30663>>>    Function_Return rVal
30664>>>End_Function
30665>>>
30665>>>
30665>>>Function fnConvert_Difference_StartTime_EndTime_to_Time Global  Number anStartTime  ;                                                                Number anEndTime    ;                                                                Returns Number
30666>>>    Local Integer iTmp
30667>>>    Local Number  rVal
30667>>>
30667>>>    If (anStartTime >= anEndTime) Add 24 to anEndTime
30670>>>
30670>>>    Move (fiConvert_Difference_StartTime_EndTime_to_Minutes(anStartTime,anEndTime)) to iTmp
30671>>>    Move (fnConvert_Minutes_to_Time(iTmp))                                          to rVal
30672>>>    Function_Return rVal
30673>>>End_Function
30674>>>
30674>>>
30674>>>
30674>>>Open WitemCL
INCLUDING FILE: WITEMCL.FD
30676>>>Open WitemCld
INCLUDING FILE: WITEMCLD.FD
30678>>>Open WitemxT
INCLUDING FILE: WITEMXT.FD
30680>>>
30680>>>Function fnTeleytaiaTimhAgoras String asPromCode String asItemCode  ;                               Date   adHmnia    Number anQty       ;                               Returns Number
30681>>>  Integer iExodos
30682>>>  Number nPoso nPct
30682>>>  Move 0 to nPoso
30683>>>  Move 0 to nPct
30684>>>  Move 0 to iExodos
30685>>>
30685>>>  Move (Trim(asItemCode)) to asItemCode
30686>>>  Move (Trim(asPromCode)) to asPromCode
30687>>>
30687>>>  // 1.Anazhthsh sto arxeio Witemcld
30687>>>  Clear Witemcld
30688>>>  Move asItemCode to Witemcld.Item_Code
30689>>>  Move asPromCode to Witemcld.Client_Code
30690>>>  Find Gt Witemcld By Index.1 // Witemcld:Index.1:Item_Code+Client_Code+Value_Date+Qty
30691>>>>
30691>>>  While ((Found=1) And (Witemcld.Item_Code  = asItemCode) And ;                       (Witemcld.Client_Code= asPromCode) And ;                       (iExodos=0))
30695>>>      If ((adHmnia>=Witemcld.Value_Date) And (anQty<=Witemcld.Qty)) Begin
30697>>>          Move 1 to iExodos
30698>>>               If (Witemcld.Axia00<>0) Move Witemcld.Axia00         to nPoso
30701>>>          Else If (Witemcld.PcDisc<>0) Move (Witemcld.PcDisc*(-1))  to nPct
30705>>>      End
30705>>>>
30705>>>      Find Gt Witemcld By Index.1 // Witemcld:Index.1:Item_Code+Client_Code+Value_Date+Qty
30706>>>>
30706>>>  Loop
30707>>>>
30707>>>  If (iExodos) Begin
30709>>>      If (nPoso) Function_Return nPoso
30712>>>      Else Function_Return nPct
30714>>>  End
30714>>>>
30714>>>
30714>>>  // 2.Anazhthsh sto arxeio Witemcl
30714>>>  Clear WitemCL
30715>>>  Move (Trim(asPromCode)) to WitemCL.Client_Code
30716>>>  Move (Trim(asItemCode)) to WitemCL.Item_Code
30717>>>  Find Eq WitemCL By Index.1
30718>>>>
30718>>>  If (Found=1) Function_Return WitemCL.Client_Price
30721>>>
30721>>>  Function_Return 0
30722>>>End_Function
30723>>>
30723>>>Open BtnOrdd
INCLUDING FILE: BTNORDD.FD
30725>>>Function fnTeleytaiaTimhPolhshs String asWitemxRecr String asClientID ;                                String asWitemxCode Date   adHmnia    ;                                String asItemCode   Number anQty      ;                                String asCNCode     Returns Number
30726>>>
30726>>>  Integer iExodos iCheckDeop
30727>>>  Number nPoso nPct
30727>>>
30727>>>  Move (Num_Arguments=7) to iCheckDeop
30728>>>
30728>>>  Move 0 to nPoso
30729>>>  Move 0 to nPct
30730>>>  Move 0 to iExodos
30731>>>
30731>>>  Move (Trim(asItemCode))                 to asItemCode
30732>>>  Move (Trim(asClientID))                 to asClientID
30733>>>  Move (Trim(asWitemxRecr))               to asWitemxRecr
30734>>>  Move (Trim(asWitemxCode))               to asWitemxCode
30735>>>  If (iCheckDeop) Move (Trim(asCNCode))   to asCNCode
30738>>>
30738>>>  // 1. Anazhthsh apo DEOP ef' oson yparxei kodikos ergou
30738>>>  If (iCheckDeop) Begin
30740>>>      Clear btnordd
30741>>>      Move asClientID   to btnordd.vclient_id
30742>>>      Move asCNCode     to btnordd.vcn_code
30743>>>      Move asWitemxCode to btnordd.vitem
30744>>>      Move 0            to btnordd.vactive
30745>>>      Move adHmnia      to btnordd.arxh_date
30746>>>      Find LE btnordd by index.4//client_id+cn_code+item+arxh_date
30747>>>>
30747>>>      If ((found=1) and (asWitemxCode=btnordd.vitem)    and (adHmnia>=btnordd.arxh_date) ;                    and (adHmnia<=btnordd.deop_date)    and (btnordd.vactive=0)          ;                    and (asCNCode=btnordd.vcn_code)) begin
30749>>>          move btnordd.vprice to nPoso
30750>>>          If (nPoso) Function_Return nPoso
30753>>>      End
30753>>>>
30753>>>  End
30753>>>>
30753>>>
30753>>>  // 2.Anazhthsh sto arxeio Witemcld (Timokatalogos Pelath/Eidous)
30753>>>  Clear Witemcld
30754>>>  Move asItemCode to Witemcld.Item_Code
30755>>>  Move asClientID to Witemcld.Client_Code
30756>>>  Find Gt Witemcld By Index.1 // Witemcld:Index.1:Item_Code+Client_Code+Value_Date+Qty
30757>>>>
30757>>>  While ((Found=1) And (Witemcld.Item_Code  = asItemCode) And ;                       (Witemcld.Client_Code= asClientID) And ;                       (iExodos=0))
30761>>>      If ((adHmnia>=Witemcld.Value_Date) And (anQty<=Witemcld.Qty)) Begin
30763>>>          Move 1 to iExodos
30764>>>               If (Witemcld.Axia00<>0) Move Witemcld.Axia00         to nPoso
30767>>>          Else If (Witemcld.PcDisc<>0) Move (Witemcld.PcDisc*(-1))  to nPct
30771>>>      End
30771>>>>
30771>>>      Find Gt Witemcld By Index.1 // Witemcld:Index.1:Item_Code+Client_Code+Value_Date+Qty
30772>>>>
30772>>>  Loop
30773>>>>
30773>>>  If (iExodos) Begin
30775>>>      If (nPoso) Function_Return nPoso
30778>>>      Else Function_Return nPct
30780>>>  End
30780>>>>
30780>>>
30780>>>
30780>>>  // 3.Anazhthsh sto arxeio Witemxt (Timokatalogos Eidous)
30780>>>  Clear Witemxt
30781>>>  Move SysCurXr.Company_Code  to Witemxt.Company_Code
30782>>>  Move SysCurXr.Branch_Code   to Witemxt.Branch_Code
30783>>>  Move SysCurXr.Year_Year     to Witemxt.Year_Year
30784>>>  Move asWitemxRecr           to Witemxt.Witemx_Recr
30785>>>  Find Gt Witemxt By Index.1 // Witemxt:Index.1
30786>>>>
30786>>>  While ((Found=1) And (Witemxt.Company_Code = SysCurXr.Company_Code) And ;                       (Witemxt.Branch_Code  = SysCurXr.Branch_Code ) And ;                       (Witemxt.Year_Year    = SysCurXr.Year_Year   ) And ;                       (Witemxt.Witemx_Recr  = asWitemxRecr         ) And ;                       (iExodos=0))
30790>>>      If ((adHmnia>=Witemxt.Value_Date) And (anQty<=Witemxt.Qty)) Begin
30792>>>          Move 1 to iExodos
30793>>>               If (Witemxt.Axia0 <>0) Move  Witemxt.Axia0         to nPoso
30796>>>          Else If (Witemxt.PcDisc<>0) Move (Witemxt.PcDisc*(-1))  to nPct
30800>>>      End
30800>>>>
30800>>>      Find Gt Witemxt By Index.1 // Witemxt:Index.1
30801>>>>
30801>>>  Loop
30802>>>>
30802>>>  If (iExodos) Begin
30804>>>      If (nPoso) Function_Return nPoso
30807>>>      Else Function_Return nPct
30809>>>  End
30809>>>>
30809>>>
30809>>>
30809>>>  // 4.Anazhthsh sto arxeio Witemcl (Teleytaia Timh Agoras)
30809>>>  Clear WitemCL
30810>>>  Move (Trim(asClientID)) to WitemCL.Client_Code
30811>>>  Move (Trim(asItemCode)) to WitemCL.Item_Code
30812>>>  Find Eq WitemCL By Index.1
30813>>>>
30813>>>  If (Found=1) Function_Return WitemCL.Client_Price
30816>>>
30816>>>  Function_Return 0
30817>>>End_Function
30818>>>
30818>>>Function fsStripTextFieldFromEnter Global String asStr Returns String
30819>>>    String sEnter
30820>>>    Move '' to sEnter
30821>>>    Move (Trim(asStr)) to asStr
30822>>>    Append sEnter (Character(13)) (Character(10))
30824>>>    Move (Replaces(sEnter,asStr,' ')) to asStr
30825>>>    Function_return (Trim(asStr))
30826>>>End_function
30827>>>
30827>>>
30827>>>//end   of global functions and procedures
30827>>>Use Wait.DG
INCLUDING FILE: WAIT.DG
30827>>>>>USE AllEntSc
30827>>>>>
30827>>>>>//AB-IgnoreEnd
30827>>>>>
30827>>>>>
30827>>>>>//AB-IgnoreEnd
30827>>>>>
30827>>>>>Object Wait is a ModalPanelSub
30829>>>>>
30829>>>>>    //AB-StoreTopStart
30829>>>>>
30829>>>>>    // How to Use It
30829>>>>>    // Get the maximum position of the bar
30829>>>>>    // Move (Bar_Maximum_position(Wait(self))) to iMax
30829>>>>>    //
30829>>>>>    // Set the maximum position of the bar
30829>>>>>    // Set Bar_Maximum_position of (Wait(self)) to iMax
30829>>>>>    //
30829>>>>>    // Start Bar Progress from beginning
30829>>>>>    // Send Bar_Current_Position to (Wait(Self)) 0 0 0 False
30829>>>>>    //
30829>>>>>    // End Bar Progress
30829>>>>>    // Send Bar_Current_Position to (Wait(Self)) iMax iMax iMax False
30829>>>>>    //
30829>>>>>    // Update Bar Progress
30829>>>>>    // Send Bar_Current_Position to (Wait(Self)) i iCounter iMax True OR
30829>>>>>    // Send Bar_Current_Position to (Wait(Self)) i iCounter iMax False
30829>>>>>    // When you want the update to be done for every i (this is slower)
30829>>>>>    // Where i=Counter's current value, icounter=Counter's Max Value and iMax=Bar Max Position
30829>>>>>    //
30829>>>>>    // Display Buttons on the object
30829>>>>>    // Set Button_State of (Wait(Self)) to False/True
30829>>>>>    // If the Progress Bar gets initialized without buttons, it MUST be Deactivated
30829>>>>>    //
30829>>>>>    // Initialization of the Progress Bar
30829>>>>>    // Send Popup to (Wait(Self))
30829>>>>>    //
30829>>>>>    // Deactivation of the Progress Bar
30829>>>>>    // Send Deactivate to (Wait(Self))
30829>>>>>    //
30829>>>>>    // Message during the process
30829>>>>>    // Set Wait_Message of (Wait(Self)) to "Now Processing..."
30829>>>>>    //
30829>>>>>    // Extra Info for button "Info >>"
30829>>>>>    // Send Wait_Details to (Wait(Self)) sFile sDetail bInitData
30829>>>>>    // If sFile<>'' then reads the contents of the file
30829>>>>>    // Else Fills the Edit with the string of sDetail
30829>>>>>    // If bInitData is True then the edit object is cleared first else extra info is appended
30829>>>>>    //
30829>>>>>    // Remarks instead of Progress Bar
30829>>>>>    // Set Button_State of (Wait(Self))     to False
30829>>>>>    // Set BarVisibleState of (Wait(Self))  to 'Remarks' False
30829>>>>>    // Update During Process
30829>>>>>    // Send UpdateWait to (Wait(Self)) 'Remarks'
30829>>>>>
30829>>>>>    //AB-StoreTopEnd
30829>>>>>
30829>>>>>    Set Exit_Application_Local_State to FALSE
30830>>>>>    Set Modal_State to FALSE
30831>>>>>    Set Popup_State to TRUE
30832>>>>>    Set Border_Style to Border_Thick
30833>>>>>    Set Minimize_Icon to FALSE
30834>>>>>    Set Label to "˜¨˜¡˜¢é §œ¨ £â¤œ«œ..."
30835>>>>>    Set Size to 138 256
30836>>>>>
30836>>>>>    //AB-DDOStart
30836>>>>>
30836>>>>>
30836>>>>>    //AB-DDOEnd
30836>>>>>
30836>>>>>    Object WaitBar is a ProgressBarSub
30838>>>>>
30838>>>>>        //AB-StoreTopStart
30838>>>>>
30838>>>>>        //AB-StoreTopEnd
30838>>>>>
30838>>>>>        Set Size to 21 243
30839>>>>>        Set Location to 7 4
30840>>>>>
30840>>>>>        //AB-StoreStart
30840>>>>>        Send DoRegSize  self smTopRight
30841>>>>>        //AB-StoreEnd
30841>>>>>
30841>>>>>    End_Object
30842>>>>>
30842>>>>>    Object WaitText is a TextBoxSub
30844>>>>>
30844>>>>>        //AB-StoreTopStart
30844>>>>>
30844>>>>>        //AB-StoreTopEnd
30844>>>>>
30844>>>>>        Set Enabled_State to TRUE
30845>>>>>        Set Label to "Processing"
30846>>>>>        Set FontSize to 4 0
30847>>>>>        Set Size to 10 81
30848>>>>>        Set Location to 36 5
30849>>>>>
30849>>>>>        //AB-StoreStart
30849>>>>>
30849>>>>>        //AB-StoreEnd
30849>>>>>
30849>>>>>    End_Object
30850>>>>>
30850>>>>>    Object bnCancel is a ButtonSub
30852>>>>>
30852>>>>>        //AB-StoreTopStart
30852>>>>>
30852>>>>>        //AB-StoreTopEnd
30852>>>>>
30852>>>>>        Set Default_State to TRUE
30853>>>>>        Set Label to "OK"
30854>>>>>        Set Location to 34 143
30855>>>>>
30855>>>>>        //AB-StoreStart
30855>>>>>
30855>>>>>        Procedure OnClick
30857>>>>>             Send Deactivate to (Wait(Self))
30858>>>>>        End_Procedure
30859>>>>>
30859>>>>>        Send DoRegAlign self amTopRight
30860>>>>>        //AB-StoreEnd
30860>>>>>
30860>>>>>    End_Object
30861>>>>>
30861>>>>>    Object bnDetail is a ButtonSub
30863>>>>>
30863>>>>>        //AB-StoreTopStart
30863>>>>>
30863>>>>>        //AB-StoreTopEnd
30863>>>>>
30863>>>>>        Set Focus_Mode to Pointer_Only
30864>>>>>        Set Label to "Info >>"
30865>>>>>        Set Location to 34 197
30866>>>>>
30866>>>>>        //AB-StoreStart
30866>>>>>
30866>>>>>        Procedure OnClick
30868>>>>>            Delegate Send Show_Details False
30870>>>>>        End_Procedure
30871>>>>>
30871>>>>>        Send DoRegAlign self amTopRight
30872>>>>>        //AB-StoreEnd
30872>>>>>
30872>>>>>    End_Object
30873>>>>>
30873>>>>>    Object LineControlSub1 is a LineControlSub
30875>>>>>
30875>>>>>        //AB-StoreTopStart
30875>>>>>
30875>>>>>        //AB-StoreTopEnd
30875>>>>>
30875>>>>>        Set Size to 2 243
30876>>>>>        Set Location to 54 4
30877>>>>>
30877>>>>>        //AB-StoreStart
30877>>>>>
30877>>>>>        Send DoRegSize  self smTopRight
30878>>>>>        //AB-StoreEnd
30878>>>>>
30878>>>>>    End_Object
30879>>>>>
30879>>>>>    Object WaitEdit is a editSub
30881>>>>>
30881>>>>>        //AB-StoreTopStart
30881>>>>>
30881>>>>>        //AB-StoreTopEnd
30881>>>>>
30881>>>>>        Set Enabled_State to FALSE
30882>>>>>        Set Read_Only_State to TRUE
30883>>>>>        Set Size to 58 243
30884>>>>>        Set Location to 60 4
30885>>>>>        Set Color to clWhite
30886>>>>>
30886>>>>>        //AB-StoreStart
30886>>>>>
30886>>>>>        Send DoRegSize Self amBottomRight
30887>>>>>        Delegate Set Size to 66 256
30889>>>>>
30889>>>>>        //AB-StoreEnd
30889>>>>>
30889>>>>>    End_Object
30890>>>>>
30890>>>>>    Object oTxtAntiBar is a TextBoxSub
30892>>>>>        Set Enabled_State to TRUE
30893>>>>>        Set Visible_State to FALSE
30894>>>>>        Set Label to "˜¨˜¡˜¢é §œ¨ £â¤œ«œ..."
30895>>>>>        Set Justification_Mode to (jMode_Center IOR jMode_VCenter)
30896>>>>>        Set Auto_Size_State to FALSE
30897>>>>>        Set FontWeight to 600
30898>>>>>        Set FontSize to 4 0
30899>>>>>        Set Size to 10 209
30900>>>>>        Set Location to 10 4
30901>>>>>        Set TextColor to clNavy
30902>>>>>    End_Object
30903>>>>>
30903>>>>>
30903>>>>>    //AB-StoreStart
30903>>>>>    Property Integer piWaitSize  Public (Size(Self))
30905>>>>>    Property Integer piPrevSize  Public (Size(Self))
30907>>>>>    Property Integer piState     Public False
30909>>>>>
30909>>>>>    Set Locate_Mode to Center_On_Screen
30910>>>>>    Set Destroy_Object_State to True
30911>>>>>
30911>>>>>    Procedure Show_Details Integer bAlways
30913>>>>>        Local Integer liOriSize liSize hiSize hiOriSize lowSize bState
30914>>>>>        Local String sLabel
30914>>>>>        Get Size                to liSize
30915>>>>>        Get piState             to bState
30916>>>>>        Get piWaitSize          to liOriSize
30917>>>>>        Move (Hi(liSize))       to hiSize
30918>>>>>        Move (Low(liSize))      to lowSize
30919>>>>>        Move (Hi(liOriSize))    to hiOriSize
30920>>>>>        If (bAlways) Begin
30922>>>>>            Set piState         to False
30923>>>>>            Move 0              to bState
30924>>>>>        End
30924>>>>>>
30924>>>>>        If bState Begin
30926>>>>>             Set Size to hiOriSize lowSize
30927>>>>>             Set Label of (bnDetail(Self)) to "Info >>"
30928>>>>>        End
30928>>>>>>
30928>>>>>        Else Begin
30929>>>>>             Set Size to 138 lowSize
30930>>>>>             Set Label of (bnDetail(Self)) to "<< Info"
30931>>>>>        End
30931>>>>>>
30931>>>>>        Set piState to (1-bState)
30932>>>>>    End_Procedure
30933>>>>>
30933>>>>>    Procedure Bar_Current_Position Integer iCount Integer iOccurances Integer iMaximum Integer bState
30935>>>>>       If (bState) Begin
30937>>>>>         If (Mod(iCount,(iCount*((Number(iMaximum))/(Number(iOccurances)))))=0) ;            Set Current_Position of (WaitBar(Self)) to (iCount*((Number(iMaximum))/(Number(iOccurances))))
30940>>>>>       End
30940>>>>>>
30940>>>>>       Else Set Current_Position of (WaitBar(Self)) to (iCount*((Number(iMaximum))/(Number(iOccurances))))
30942>>>>>    End_Procedure
30943>>>>>
30943>>>>>    Procedure DoInitialize_WaitBar
30945>>>>>        Send Bar_Current_Position to (Wait(Self)) 0 0 0 False
30946>>>>>    End_Procedure
30947>>>>>
30947>>>>>    Procedure DoTerminate_WaitBar
30949>>>>>        Local Integer iMax
30950>>>>>        Get Maximum_position of (WaitBar(Self)) to iMax
30951>>>>>        Send Bar_Current_Position to (Wait(Self)) iMax iMax Imax False
30952>>>>>    End_Procedure
30953>>>>>
30953>>>>>    Procedure Set Bar_Maximum_Position Integer iMaximum
30955>>>>>         Set Maximum_position of (WaitBar(Self)) to iMaximum
30956>>>>>    End_Procedure
30957>>>>>
30957>>>>>    Function Bar_Maximum_Position Returns Integer
30959>>>>>        Function_Return (Maximum_position(WaitBar(Self)))
30960>>>>>    End_Function
30961>>>>>
30961>>>>>    Procedure Set Bar_Minimum_Position Integer iMinimum
30963>>>>>         Set Minimum_position of (WaitBar(Self)) to iMinimum
30964>>>>>    End_Procedure
30965>>>>>
30965>>>>>    Function Bar_Minimum_Position Returns Integer
30967>>>>>        Function_Return (Minimum_position(WaitBar(Self)))
30968>>>>>    End_Function
30969>>>>>
30969>>>>>    Procedure Set Bar_Step_Value Integer iStep
30971>>>>>         Set Step_Value of (WaitBar(Self)) to iStep
30972>>>>>    End_Procedure
30973>>>>>
30973>>>>>    Function Bar_Step_Value Returns Integer
30975>>>>>        Function_Return (Step_Value(WaitBar(Self)))
30976>>>>>    End_Function
30977>>>>>
30977>>>>>    Procedure Set Wait_Message String sMessage
30979>>>>>        Set Value of (WaitText(Self)) to sMessage
30980>>>>>    End_Procedure
30981>>>>>
30981>>>>>    Procedure Wait_Details String sFile String sDetail Integer bInitData
30983>>>>>        Local Integer liEditId
30984>>>>>        Move (WaitEdit(Self)) to liEditId
30985>>>>>        If bInitData Send Delete_Data to liEditId
30988>>>>>        If sFile ne "" Begin
30990>>>>>           Send Read to liEditId sFile
30991>>>>>           Send Beginning_Of_Data to liEditId
30992>>>>>        End
30992>>>>>>
30992>>>>>        Else Begin
30993>>>>>           Send Insert to liEditId sDetail
30994>>>>>        End
30994>>>>>>
30994>>>>>    End_Procedure
30995>>>>>
30995>>>>>    Procedure OnResize
30997>>>>>        Local Integer liSize liHiSize liPrevSize liHiPrevSize bState liHiLoc liLoc
30998>>>>>        Get Size to liPrevSize
30999>>>>>        Move (Hi(liPrevSize)) to liHiPrevSize
31000>>>>>        Forward Send OnResize
31002>>>>>        Get Location of (WaitEdit(Self)) to liLoc
31003>>>>>        Move (Hi(liLoc)) to liHiLoc
31004>>>>>        Get piState to bState
31005>>>>>        Get Size to liSize
31006>>>>>        Move (Hi(liSize)) to liHiSize
31007>>>>>        If (liHiSize > (liHiLoc +30)) Begin
31009>>>>>            Set Value of (bnDetail(Self)) to "<< Info"
31010>>>>>            If (liHiPrevSize <= (liHiLoc +30)) Set piState to (1-bState)
31013>>>>>        End
31013>>>>>>
31013>>>>>        Else Begin
31014>>>>>            Set Value of (bnDetail(Self)) to "Info >>"
31015>>>>>            If (liHiPrevSize > (liHiLoc +30)) Set piState to (1-bState)
31018>>>>>        End
31018>>>>>>
31018>>>>>    End_Procedure
31019>>>>>
31019>>>>>    Procedure Set Button_State Integer bState
31021>>>>>        If bState Begin
31023>>>>>            Set Caption_Bar to True
31024>>>>>            Set Size to 66 256
31025>>>>>        End
31025>>>>>>
31025>>>>>        Else Begin
31026>>>>>            Set Caption_Bar to False
31027>>>>>            Set Size to 38 256
31028>>>>>        End
31028>>>>>>
31028>>>>>    End_Procedure
31029>>>>>
31029>>>>>    Procedure Set BarVisibleState String sMsg Integer bState
31031>>>>>        Set Visible_State of (oTxtAntiBar(Self)) to (bState = 0)
31032>>>>>        Set Visible_State of (WaitBar(Self))     to (bState = 1)
31033>>>>>        If (bState = 0) Begin
31035>>>>>            Set Size to 24 256
31036>>>>>            Set Location of (oTxtAntiBar(Self)) to 6 5
31037>>>>>        End
31037>>>>>>
31037>>>>>        If sMsg ne "" Set Value of (oTxtAntiBar(Self)) to sMsg
31040>>>>>    End_Procedure
31041>>>>>
31041>>>>>    Procedure Deactivating integer search_mode Returns Integer
31043>>>>>        local integer rval
31044>>>>>        Forward Get MSG_Deactivating search_mode to rval
31046>>>>>        Set Modal_State of (Wait(Self)) to False
31047>>>>>        Set BarVisibleState of (Wait(Self)) to "˜¨˜¡˜¢é §œ¨ £â¤œ«œ..." True
31048>>>>>        Procedure_Return rval
31049>>>>>    End_Procedure
31050>>>>>
31050>>>>>    Procedure UpdateWait String sMsg
31052>>>>>        Set Value of (oTxtAntiBar(Self)) to sMsg
31053>>>>>    End_Procedure
31054>>>>>
31054>>>>>
31054>>>>>    Procedure Set Horizontal_Justification Integer aiMode
31056>>>>>        Set Justification_Mode of oTxtAntiBar to (jMode_VCenter IOR aiMode)
31057>>>>>    End_Procedure
31058>>>>>
31058>>>>>
31058>>>>>
31058>>>>>
31058>>>>>
31058>>>>>
31058>>>>>    //AB-StoreEnd
31058>>>>>
31058>>>>>End_Object
31059>>>>>
31059>>>>>
31059>>>>>//AB-StoreStart
31059>>>>>
31059>>>>>//AB-StoreEnd
31059>>>>>
31059>>>>>//AB/ End_Object    // prj
31059>>>
31059>Use Calendar.sl
INCLUDING FILE: CALENDAR.SL
31059>>>//AB/ Project Calendar
31059>>>//AB/ Object prj is a Lookup_Project
31059>>>//AB/     Set ProjectName to "Calendar"
31059>>>//AB/     Set ProjectFileName to "Calendar.sl"
31059>>>
31059>>>// Project Object Structure
31059>>>//   oCalendar is a dbModalPanel
31059>>>//     Container3d1 is a Container3d
31059>>>//       Grid2 is a Grid
31059>>>//       Textbox2 is a Textbox
31059>>>//       Textbox3 is a Textbox
31059>>>//       Textbox4 is a Textbox
31059>>>//       Textbox5 is a Textbox
31059>>>//       Textbox6 is a Textbox
31059>>>//       Textbox7 is a Textbox
31059>>>//       Textbox8 is a Textbox
31059>>>//       LineControl1 is a LineControl
31059>>>//       Container3d2 is a Container3d
31059>>>//         oRght is a BitmapContainer
31059>>>//         oLeft is a BitmapContainer
31059>>>//         oMonth is a Textbox
31059>>>//           oSelectMonth is a FloatingPopupMenu
31059>>>//         oYear is a Textbox
31059>>>//         oSelectYear is a Form
31059>>>//     BitmapContainer3 is a BitmapContainer
31059>>>//     oToday is a Textbox
31059>>>
31059>>>// Register all objects
31059>>>Register_Object BitmapContainer3
31059>>>Register_Object Container3d1
31059>>>Register_Object Container3d2
31059>>>Register_Object Grid2
31059>>>Register_Object LineControl1
31059>>>Register_Object oCalendar
31059>>>Register_Object oLeft
31059>>>Register_Object oMonth
31059>>>Register_Object oRght
31059>>>Register_Object oSelectMonth
31059>>>Register_Object oSelectYear
31059>>>Register_Object oToday
31059>>>Register_Object oYear
31059>>>Register_Object Textbox2
31059>>>Register_Object Textbox3
31059>>>Register_Object Textbox4
31059>>>Register_Object Textbox5
31059>>>Register_Object Textbox6
31059>>>Register_Object Textbox7
31059>>>Register_Object Textbox8
31059>>>
31059>>>
31059>>>
31059>>>//AB-StoreTopStart
31059>>>Use dates.utl
INCLUDING FILE: DATES.UTL
31059>>>>>// **********************************************************************
31059>>>>>// Use Dates.utl    // Date manipulation for VDF and DF3.1
31059>>>>>//
31059>>>>>// by Sture Andersen (sa1@vd.dk)
31059>>>>>//
31059>>>>>// The file contains a number of global functions for manipulating
31059>>>>>// dates. The package may be used with DataFlex 3.1 and Visual DataFlex.
31059>>>>>// This package is public domain.
31059>>>>>//
31059>>>>>// The package file is accompanied by a Word document (dfutil.doc)
31059>>>>>// listing the functions and their use.
31059>>>>>//
31059>>>>>//
31059>>>>>// Create: Fri  06-06-1997 - Merger of s_utl020, 021, 022, 023, 024, 025.
31059>>>>>// Update: Thu  26-06-1997 - Fixes for strange behavior when date4_state is set.
31059>>>>>//                         - Addition of popup_calendar to VDF.
31059>>>>>//         Sun  29-06-1997 - Character mode popup calender.
31059>>>>>//         Fri  04-07-1997 - Function WeekToDate added.
31059>>>>>//         Thu  10-07-1997 - Fixes.
31059>>>>>//         Mon  11-08-1997 - WeekToDate fixed.
31059>>>>>//         Sun  24-08-1997 - Character mode popup calender finished.
31059>>>>>//         Mon  15-12-1997 - Procedure Request_Popup_Calendar added.
31059>>>>>//         Mon  29-12-1997 - Procedures ItemYear2to4, ItemDate2to4 and
31059>>>>>//                           ItemSysdate added.
31059>>>>>//         Mon  29-12-1997 - Procedures FieldYear2to4, FieldDate2to4 and
31059>>>>>//                           FieldSysdate added.
31059>>>>>//         Sun  01-02-1998 - Functions Module_Compile_Date and
31059>>>>>//                           Module_Compile_Time added.
31059>>>>>//         Wed  25-02-1998 - Request_Popup in calendar object now only
31059>>>>>//                           responds if entry_state of the calling object
31059>>>>>//                           is true (VDF version). (No apparent effect)
31059>>>>>//         Sat  28-03-1998 - Added the following functions:
31059>>>>>//                             TS_SysTime      TS_ExtractDate
31059>>>>>//                             TS_ExtractTime  TS_ConvertToString
31059>>>>>//         Tue  26-05-1998 - Procedure TS_UI_Update added
31059>>>>>//         Sat  01-08-1998 - mask_date_window taken into account
31059>>>>>//         Mon  10-08-1998 - Functions Module_Start_Date and
31059>>>>>//                           Module_Start_Time added.
31059>>>>>//         Wed  02-09-1998 - Parameter for Module_Start_Date removed
31059>>>>>//         Mon  12-10-1998 - Portuguese added
31059>>>>>//         Wed  04-11-1998 - TS_TimeEstimator class added
31059>>>>>//         Tue  29-12-1998 - Function DateAsString added
31059>>>>>//         Wed  13-01-1999 - Function DateWeekNumber changed according to
31059>>>>>//                           Kjetil Johanson
31059>>>>>//         Mon  18-01-1999 - Function DateWeekNumber changed according to
31059>>>>>//                           Kjetil Johanson (again)
31059>>>>>//         Tue  19-01-1999 - Changed procedure names in TS_TimeEstimator
31059>>>>>//                           class (Continue->TS_Continue and Pause->
31059>>>>>//                           TS_Pause)
31059>>>>>//         Thu  21-01-1999 - Procedures DateFormatAsString and DateFormatName
31059>>>>>//                           added.
31059>>>>>//                         - Procedures DateCurrentSeparator and
31059>>>>>//                           DateCurrentFormat added.
31059>>>>>//         Tue  13-04-1999 - Julian constants added: Jan1st1900, Jan1st2000
31059>>>>>//                           Jan1st1000 and Jan1st100
31059>>>>>//         Mon  26-04-1999 - Changed procedure FieldYear2to4 and ItemYear2to4
31059>>>>>//                           to trap 3 digit years.
31059>>>>>//         Wed  27-04-1999 - Changed Dutch abbriviated day names (to 2 characters)
31059>>>>>//         Sun  02-05-1999 - Added function TS_Compose2
31059>>>>>//                         - Fixed error in TS_ConvertToString
31059>>>>>//         Tue  01-06-1999 - Added procedure popup_no_export to calendar.
31059>>>>>//         Thu  15-06-1999 - Fixed Date4to2 function and exporting dates
31059>>>>>//                           from the calendar to forms with no form_margin.
31059>>>>>//         Tue  07-09-1999 - Added function DateAsText
31059>>>>>//         Wed  27-10-1999 - Temporary fix for Module_Compile_Date function
31059>>>>>//                           in combination with y2k.
31059>>>>>//         Wed  19-12-1999 - Function StringToDate added.
31059>>>>>//                         - Existing function DateAsString renamed to
31059>>>>>//                           DateToString.
31059>>>>>//         Mon  03-01-2000 - Fix for VDF4. Popup calendar on empty date field
31059>>>>>//                           would result in seeding the calendar on year 100.
31059>>>>>//                           This error was caused by the fact that VDF 4
31059>>>>>//                           ignores SYSDATE4_STATE such that the sysdate
31059>>>>>//                           command returns 03-01-100
31059>>>>>//         Wed  01-02-2000 - Define instead of #REPLACE
31059>>>>>//         Wed  23-08-2000 - Function TS_Module_Compile_Time added
31059>>>>>//
31059>>>>>// NOTE:  There is language dependent string constants in this file.
31059>>>>>//        Currently there are sections for dutch, english, danish, swedish,
31059>>>>>//        norwegian, spanish, german and portuguese
31059>>>>>//
31059>>>>>//        These sections may be identified by searching the symbol LNG_DEFAULT
31059>>>>>//
31059>>>>>// ***********************************************************************
31059>>>>>
31059>>>>>Use ui
31059>>>>>Use Language    // Set default languange if not set by compiler command line
INCLUDING FILE: LANGUAGE.PKG
31059>>>>>>>// Use Language     // Default language setup
31059>>>>>>>// Sets default languange if not set by compiler command line
31059>>>>>>>
31059>>>>>>>define lng_dutch      for 131
31059>>>>>>>define lng_french     for 133 // NOT TRANSLATED. DO NOT SELECT!
31059>>>>>>>define lng_spanish    for 134
31059>>>>>>>define lng_italian    for 139 // NOT TRANSLATED. DO NOT SELECT!
31059>>>>>>>define lng_english    for 144
31059>>>>>>>define lng_danish     for 145
31059>>>>>>>define lng_swedish    for 146
31059>>>>>>>define lng_norwegian  for 147
31059>>>>>>>define lng_Greek    for 148
31059>>>>>>>define lng_german     for 149
31059>>>>>>>define lng_portuguese for 155
31059>>>>>>>define lng_papiamentu for 199 // NOT TRANSLATED. DO NOT SELECT!
31059>>>>>>>
31059>>>>>>>
31059>>>>>>>define lng_default for !@
31059>>>>>>>
31059>>>>>>>  define _LANGUAGE_ for $ENGLISH$
31059>>>>>>>
#REM LANGUAGE SET BY LANGUAGE.PKG: $ENGLISH$
31059>>>>>Use Seq_Chnl    // Defines global sequential device management operations (DAC)
31059>>>>>Use Macros.utl  // Various macros (DESKTOP_SECTION)
INCLUDING FILE: MACROS.UTL
31059>>>>>>>// Use Macros.utl   // Various macros (FOR_EX...)
31059>>>>>>>
31059>>>>>>>//  FOR_EX (extended FOR command)
31059>>>>>>>//  -----------------------------
31059>>>>>>>//> The FOR_EX command is exactly like the standard FOR command except
31059>>>>>>>//> that it will allow you to use keyword "DOWN_TO" instead of "TO" if
31059>>>>>>>//> you need to do a decremental loop.
31059>>>>>>>
31059>>>>>>>
31059>>>>>>>//  DESKTOP_SECTION
31059>>>>>>>//  ---------------
31059>>>>>>>//> The DESKTOP_SECTION/END_DESKTOP_SECTION commands will make a sequence of
31059>>>>>>>//> code compile (or rather instantiate) as if it was situated on the DESKTOP
31059>>>>>>>//> even when it isn't. DESKTOP_SECTION's may not be nested.
31059>>>>>>>
31059>>>>>>>
31059>>>>>>>
31059>>>>>
31059>>>>>// Switches
31059>>>>>
31059>>>>>define DATES_INCLUDE_POPUP for 1   // If set to 0 the popup calendar will not be included
31059>>>>>define DATES_DF31B_EPOCH   for 40  // DF3.1b didn't have an epoch setting. Therefore this symbol defines the epoch value for that version.
31059>>>>>
31059>>>>> define t.calendar.year           for "Year"
31059>>>>> define t.calendar.month          for "Month"
31059>>>>> define t.calendar.day            for "Day"
31059>>>>> define t.calendar.week           for "Wk."
31059>>>>> define t.calendar.calendar_popup for "Calendar Popup"
31059>>>>> define t.calendar.Monday         for "Monday"
31059>>>>> define t.calendar.Tuesday        for "Tuesday"
31059>>>>> define t.calendar.Wednesday      for "Wednesday"
31059>>>>> define t.calendar.Thursday       for "Thursday"
31059>>>>> define t.calendar.Friday         for "Friday"
31059>>>>> define t.calendar.Saturday       for "Saturday"
31059>>>>> define t.calendar.Sunday         for "Sunday"
31059>>>>> define t.calendar.January        for "January"
31059>>>>> define t.calendar.February       for "February"
31059>>>>> define t.calendar.March          for "March"
31059>>>>> define t.calendar.April          for "April"
31059>>>>> define t.calendar.May            for "May"
31059>>>>> define t.calendar.June           for "June"
31059>>>>> define t.calendar.July           for "July"
31059>>>>> define t.calendar.August         for "August"
31059>>>>> define t.calendar.September      for "September"
31059>>>>> define t.calendar.October        for "October"
31059>>>>> define t.calendar.November       for "November"
31059>>>>> define t.calendar.December       for "December"
31059>>>>> define t.calendar.ok             for "OK"
31059>>>>> define t.calendar.Cancel         for "Cancel"
31059>>>>> define t.calendar.Activate       for "Activate popup calendar (Ctrl+D)"
31059>>>>>
31059>>>>>define LargestPossibleDate for 913490 // December 31st 2500
31059>>>>>define Jan1st1900          for 693975
31059>>>>>define Jan1st2000          for 730500
31059>>>>>define Jan1st1000          for 365250
31059>>>>>define Jan1st105           for 38352
31059>>>>>define Jan1st100           for 36525
31059>>>>>
31059>>>>>enumeration_list // Date Segments
31059>>>>>  define DS_DAY
31059>>>>>  define DS_WEEK
31059>>>>>  define DS_MONTH
31059>>>>>  define DS_YEAR
31059>>>>>end_enumeration_list
31059>>>>>
31059>>>>>integer Dates$Year Dates$Month Dates$Day // internal use
31059>>>>>
31059>>>>>procedure DateDecompose global date date# //very internal!!
31060>>>>>  local integer pos1# pos2# format#
31061>>>>>  local string str# sep#
31061>>>>>  get_attribute DF_DATE_FORMAT to format#
31064>>>>>  get_attribute DF_DATE_SEPARATOR to pos1# // overload
31067>>>>>  character pos1# to sep#                  // end overload
31068>>>>>>
31068>>>>>  move date# to str#
31069>>>>>  replace sep# in str# with "$"
31071>>>>>  move strmark to pos1#
31072>>>>>  if [found] begin
31074>>>>>    replace sep# in str# with "$"
31076>>>>>    move strmark to pos2#
31077>>>>>  end
31077>>>>>>
31077>>>>>  else begin
31078>>>>>    move 0 to Dates$Year
31079>>>>>    move 0 to Dates$Month
31080>>>>>    move 0 to Dates$Day
31081>>>>>  end
31081>>>>>>
31081>>>>>  [ found] begin
31083>>>>>>
31083>>>>>    if format# eq DF_DATE_EUROPEAN ;          left str# to Dates$Day    (pos1#-1)
31087>>>>>    if format# eq DF_DATE_USA begin
31089>>>>>          mid  str# to Dates$Day    (pos2#-pos1#-1) (pos1#+1)
31092>>>>>>
31092>>>>>          left str# to Dates$Month  (pos1#-1)
31094>>>>>>
31094>>>>>    end
31094>>>>>>
31094>>>>>    else  mid  str# to Dates$Month  (pos2#-pos1#-1) (pos1#+1)
31098>>>>>
31098>>>>>    if format# eq DF_DATE_MILITARY begin
31100>>>>>          mid  str# to Dates$Day  2 (pos2#+1)
31103>>>>>>
31103>>>>>          left str# to Dates$Year   (pos1#-1)
31105>>>>>>
31105>>>>>    end
31105>>>>>>
31105>>>>>    else  mid  str# to Dates$Year 4 (pos2#+1)
31109>>>>>  end
31109>>>>>>
31109>>>>>end_procedure
31110>>>>>
31110>>>>>function DateCompose global integer day# integer month# integer year# returns date
31111>>>>>  local integer format#
31112>>>>>  local date date#
31112>>>>>  local string sep#
31112>>>>>  ifnot (day#*month#*year#) function_return 0
31115>>>>>  get_attribute DF_DATE_SEPARATOR to format# // overload
31118>>>>>  character format# to sep#                  // end overload
31119>>>>>>
31119>>>>>  get_attribute DF_DATE_FORMAT to format#
31122>>>>>  if day# gt 28 begin
31124>>>>>    if format# eq DF_DATE_EUROPEAN move (date(string(day#)+sep#+string(month#)+sep#+string(year#))) to date# // DMY
31127>>>>>    if format# eq DF_DATE_USA      move (date(string(month#)+sep#+string(day#)+sep#+string(year#))) to date# // MDY
31130>>>>>    if format# eq DF_DATE_MILITARY move (date(string(year#)+sep#+string(month#)+sep#+string(day#))) to date# // YMD
31133>>>>>    send DateDecompose date#
31134>>>>>    if Dates$Month ne month# move (day#-Dates$Day) to day#
31137>>>>>  end
31137>>>>>>
31137>>>>>  if format# eq DF_DATE_EUROPEAN function_return (date(string(day#)+sep#+string(month#)+sep#+string(year#))) // DMY
31140>>>>>  if format# eq DF_DATE_USA function_return (date(string(month#)+sep#+string(day#)+sep#+string(year#))) // MDY
31143>>>>>  function_return (date(string(year#)+sep#+string(month#)+sep#+string(day#))) // YMD
31144>>>>>end_function
31145>>>>>
31145>>>>>function DateFormatName global integer format# returns string
31146>>>>>  if format# eq DF_DATE_EUROPEAN function_return "European"
31149>>>>>  if format# eq DF_DATE_USA      function_return "United States"
31152>>>>>  if format# eq DF_DATE_MILITARY function_return "Military"
31155>>>>>end_function
31156>>>>>
31156>>>>>function DateCurrentSeparator global returns string
31157>>>>>  local integer rval#
31158>>>>>  get_attribute DF_DATE_SEPARATOR to rval#
31161>>>>>  function_return (character(rval#))
31162>>>>>end_function
31163>>>>>
31163>>>>>function DateCurrentFormat global returns integer
31164>>>>>  local integer rval#
31165>>>>>  get_attribute DF_DATE_FORMAT to rval#
31168>>>>>  function_return rval#
31169>>>>>end_function
31170>>>>>
31170>>>>>function DateFormatAsString global integer format# integer long# string sep# returns string
31171>>>>>  local string rval# letter#
31172>>>>>  if format# eq DF_DATE_EUROPEAN move "3342241111" to rval#
31175>>>>>  if format# eq DF_DATE_USA      move "2243341111" to rval#
31178>>>>>  if format# eq DF_DATE_MILITARY move "1111422433" to rval#
31181>>>>>  left t.calendar.year to letter# 1
31183>>>>>>
31183>>>>>  replace "1" in rval# with letter#
31185>>>>>  replace "1" in rval# with letter#
31187>>>>>  ifnot long# move "" to letter#
31190>>>>>  move (replaces("1",rval#,letter#)) to rval#
31191>>>>>  move (replaces("2",rval#,left(t.calendar.month,1))) to rval#
31192>>>>>  move (replaces("3",rval#,left(t.calendar.day,1))) to rval#
31193>>>>>  if sep# eq "" begin
31195>>>>>    get_attribute DF_DATE_SEPARATOR to format#
31198>>>>>    character format# to sep#
31199>>>>>>
31199>>>>>  end
31199>>>>>>
31199>>>>>  move (replaces("4",rval#,sep#)) to rval#
31200>>>>>  function_return rval#
31201>>>>>end_function
31202>>>>>
31202>>>>>function StringToDate global string date# integer format# integer four_digit_year# string sep# returns date
31203>>>>>  local integer sep_len# day# month# year#
31204>>>>>  move (length(sep#)) to sep_len#
31205>>>>>  if four_digit_year# move 4 to four_digit_year#
31208>>>>>  else move 2 to four_digit_year#
31210>>>>>  if format# eq DF_DATE_EUROPEAN begin // DMY
31212>>>>>    move (mid(date#,2,1)) to day#
31213>>>>>    move (mid(date#,2,3+sep_len#)) to month#
31214>>>>>    move (mid(date#,four_digit_year#,5+sep_len#+sep_len#)) to year#
31215>>>>>  end
31215>>>>>>
31215>>>>>  if format# eq DF_DATE_USA begin // MDY
31217>>>>>    move (mid(date#,2,1)) to month#
31218>>>>>    move (mid(date#,2,3+sep_len#)) to year#
31219>>>>>    move (mid(date#,four_digit_year#,5+sep_len#+sep_len#)) to year#
31220>>>>>  end
31220>>>>>>
31220>>>>>  if format# eq DF_DATE_MILITARY begin // YMD
31222>>>>>    move (mid(date#,four_digit_year#,1)) to year#
31223>>>>>    move (mid(date#,2,1+four_digit_year#+sep_len#)) to month#
31224>>>>>    move (mid(date#,2,3+four_digit_year#+sep_len#+sep_len#)) to day#
31225>>>>>  end
31225>>>>>>
31225>>>>>  function_return (DateCompose(day#,month#,year#))
31226>>>>>end_function
31227>>>>>
31227>>>>>function DateToString global date date# integer format# integer four_digit_year# string sep# returns string
31228>>>>>  local string rval# day# month# year#
31229>>>>>  get Date2to4 date# to date#
31230>>>>>  if (integer(date#)) begin
31232>>>>>    send DateDecompose date#
31233>>>>>    move Dates$Day to day#
31234>>>>>    if Dates$Day lt 10 insert "0" in day# at 1
31238>>>>>    move Dates$Month to month#
31239>>>>>    if Dates$Month lt 10 insert "0" in month# at 1
31243>>>>>    move Dates$Year to year#
31244>>>>>    ifnot four_digit_year# move (right(year#,2)) to year#
31247>>>>>    if format# eq DF_DATE_EUROPEAN move (day#+sep#+month#+sep#+year#) to rval# // DMY
31250>>>>>    if format# eq DF_DATE_USA      move (month#+sep#+day#+sep#+year#) to rval# // MDY
31253>>>>>    if format# eq DF_DATE_MILITARY move (year#+sep#+month#+sep#+day#) to rval# // YMD
31256>>>>>  end
31256>>>>>>
31256>>>>>  function_return rval#
31257>>>>>end_function
31258>>>>>
31258>>>>>// Function DateAsString is only here for compatibility with earlier versions.
31258>>>>>// Use function DateToString instead.
31258>>>>>function DateAsString global date date# integer format# integer four_digit_year# string sep# returns string
31259>>>>>  function_return (DateToString(date#,format#,four_digit_year#,sep#))
31260>>>>>end_function
31261>>>>>
31261>>>>>function DateIncrement global date date# integer segment# integer amount# returns date
31262>>>>>  if (date#=0) function_return 0
31265>>>>>  if segment# eq DS_WEEK function_return (date#+(amount#*7)) //weeks
31268>>>>>  if (segment#<>DS_DAY) begin // months or years
31270>>>>>    send DateDecompose date#
31271>>>>>    if segment# eq DS_MONTH begin //months
31273>>>>>      move (Dates$Month+amount#) to Dates$Month
31274>>>>>      if amount# ge 0 function_return (DateCompose(Dates$Day,Dates$Month-(((Dates$Month-1)/12)*12),Dates$Year+((Dates$Month-1)/12)))
31277>>>>>      function_return (DateCompose(Dates$Day,Dates$Month-(((Dates$Month-12)/12)*12),Dates$Year+((Dates$Month-12)/12)))
31278>>>>>    end //years:
31278>>>>>>
31278>>>>>    if segment# eq DS_YEAR function_return (DateCompose(Dates$Day,Dates$Month,Dates$Year+amount#))
31281>>>>>  end
31281>>>>>>
31281>>>>>  else function_return (date#+amount#) //days
31283>>>>>end_function
31284>>>>>
31284>>>>>function DateSegment global date date# integer segment# returns integer
31285>>>>>  send DateDecompose date#
31286>>>>>  if segment# eq DS_DAY   function_return Dates$Day
31289>>>>>  if segment# eq DS_MONTH function_return Dates$Month
31292>>>>>  if segment# eq DS_YEAR  function_return Dates$Year
31295>>>>>end_function
31296>>>>>
31296>>>>>function DateToInteger global date date# returns integer
31297>>>>>  send DateDecompose date#
31298>>>>>  function_return (Dates$Year*100+Dates$Month*100+Dates$Day)
31299>>>>>end_function
31300>>>>>
31300>>>>>function FirstDayInMonth global date date# returns date
31301>>>>>  local integer month# year#
31302>>>>>  move (DateSegment(date#,DS_MONTH)) to month#
31303>>>>>  move (DateSegment(date#,DS_YEAR)) to year#
31304>>>>>  function_return (DateCompose(1,month#,year#))
31305>>>>>end_function
31306>>>>>
31306>>>>>function LastDayInMonth global date date# returns date
31307>>>>>  move (DateIncrement(date#,DS_MONTH,1)) to date#
31308>>>>>  function_return (FirstDayInMonth(date#)-1)
31309>>>>>end_function
31310>>>>>
31310>>>>>function FirstDayInYear global date date# returns date
31311>>>>>  local integer year#
31312>>>>>  move (DateSegment(date#,DS_YEAR)) to year#
31313>>>>>  function_return (DateCompose(1,1,year#))
31314>>>>>end_function
31315>>>>>
31315>>>>>function LastDayInYear global date date# returns date
31316>>>>>  move (DateIncrement(date#,DS_YEAR,1)) to date#
31317>>>>>  function_return (FirstDayInYear(date#)-1)
31318>>>>>end_function
31319>>>>>
31319>>>>>// Prior to 18/1-99 version of DateWeekNumber
31319>>>>>//function DateWeekNumber global date date# returns integer
31319>>>>>//  local integer week# first_wd# day_of_year# year#
31319>>>>>//  if (date#=0) function_return 0
31319>>>>>//  get Date2to4 date# to date#
31319>>>>>//  move (DateSegment(date#,DS_YEAR)) to year#
31319>>>>>//  get DateDayNumber (FirstDayInYear(date#)) to first_wd#
31319>>>>>//  move (date#-FirstDayInYear(date#)) to day_of_year#
31319>>>>>//  move (day_of_year#-1-7+first_wd#) to day_of_year#
31319>>>>>//  if (day_of_year#/7.0) ge 0 move (day_of_year#/7+1) to week#
31319>>>>>//  else move 0 to week#
31319>>>>>//  if first_wd# le 4 increment week#
31319>>>>>//  if week# gt 52 begin
31319>>>>>//    move 1 to week#
31319>>>>>//    if first_wd# eq 4 move 53 to week#
31319>>>>>//    if first_wd# eq 3 if ((year#/4)*4) eq year# ifnot ((year#/100)*100) eq year# move 53 to week#
31319>>>>>//  end
31319>>>>>//  if week# eq 0 begin
31319>>>>>//    //get DateWeekNumber (DateIncrement(date#,DS_YEAR,-1)) to first_wd# // Original line
31319>>>>>//    get DateDayNumber  (DateIncrement(FirstDayInYear(date#),DS_YEAR,-1)) to first_wd#ÿ // changed line
31319>>>>>//    move 52 to week#
31319>>>>>//    if first_wd# eq 4 move 53 to week#
31319>>>>>//    if first_wd# eq 3 if ((year#/4)*4) eq Year# ifnot ((Year#/100)*100) eq Year# move 53 to week#
31319>>>>>//  end
31319>>>>>//  function_return week#
31319>>>>>//end_function
31319>>>>>
31319>>>>>function DateWeekNumber global date date# returns integer
31320>>>>>  local integer week# first_wd# day_of_year# year# wd#
31321>>>>>  if (date#=0) function_return 0
31324>>>>>  get Date2to4 date# to date#
31325>>>>>  // Leap-year test for actual or previous year
31325>>>>>  // Year# only used for selection between 52 and
31325>>>>>  // Therefore get year# from the first day of actual week
31325>>>>>  get DateDayNumber date# to wd#
31326>>>>>  move (DateSegment(date#-wd#+1,DS_YEAR)) to year#
31327>>>>>
31327>>>>>  get DateDayNumber (FirstDayInYear(date#)) to first_wd#
31328>>>>>  move (date#-FirstDayInYear(date#)) to day_of_year#
31329>>>>>  move (day_of_year#-1-7+first_wd#) to day_of_year#
31330>>>>>  if (day_of_year#/7.0) ge 0 move (day_of_year#/7+1) to week#
31333>>>>>  else move 0 to week#
31335>>>>>  if first_wd# le 4 increment week#
31338>>>>>  if week# gt 52 begin
31340>>>>>    move 1 to week#
31341>>>>>    if first_wd# eq 4 move 53 to week#
31344>>>>>    if first_wd# eq 3 if ((year#/4)*4) eq year# ifnot ((year#/100)*100) eq year# move 53 to week#
31351>>>>>  end
31351>>>>>>
31351>>>>>  if week# eq 0 begin
31353>>>>>    // Week 52 or 53
31353>>>>>    get DateDayNumber (DateIncrement(FirstDayInYear(date#),DS_YEAR,-1)) to first_wd#
31354>>>>>    move 52 to week#
31355>>>>>    if first_wd# eq 4 move 53 to week#
31358>>>>>    if first_wd# eq 3 if ((year#/4)*4) eq Year# ifnot ((Year#/100)*100) eq Year# move 53 to week#
31365>>>>>  end
31365>>>>>>
31365>>>>>  function_return week#
31366>>>>>end_function
31367>>>>>
31367>>>>>function DayName global integer int# returns string
31368>>>>>  if int# eq 1 function_return t.calendar.Monday
31371>>>>>  if int# eq 2 function_return t.calendar.Tuesday
31374>>>>>  if int# eq 3 function_return t.calendar.Wednesday
31377>>>>>  if int# eq 4 function_return t.calendar.Thursday
31380>>>>>  if int# eq 5 function_return t.calendar.Friday
31383>>>>>  if int# eq 6 function_return t.calendar.Saturday
31386>>>>>  if int# eq 7 function_return t.calendar.Sunday
31389>>>>>  function_return ""
31390>>>>>end_function
31391>>>>>
31391>>>>>function DateDayNumber global date date# returns integer
31392>>>>>  local integer rval# // 1=Monday, ... , 7=Sunday
31393>>>>>  get Date2to4 date# to date#
31394>>>>>  move date# to rval#
31395>>>>>  if rval# begin
31397>>>>>    if rval# gt 693975 move (rval#-2) to rval#
31400>>>>>    move (rval#-((rval#/7)*7)) to rval#
31401>>>>>    if rval# eq 0 move 7 to rval#
31404>>>>>  end
31404>>>>>>
31404>>>>>  function_return rval#
31405>>>>>end_function
31406>>>>>
31406>>>>>function DateDayName global date date# returns string
31407>>>>>  function_return (DayName(DateDayNumber(date#)))
31408>>>>>end_function
31409>>>>>
31409>>>>>function YearMaxWeek global integer year# returns integer
31410>>>>>  local integer wk1# wk2#
31411>>>>>  get DateWeekNumber (DateCompose(31,12,year#)) to wk1#
31412>>>>>  get DateWeekNumber (DateCompose(24,12,year#)) to wk2#
31413>>>>>  function_return (wk1# max wk2#)
31414>>>>>end_function
31415>>>>>
31415>>>>>function WeekToDate global integer year# integer week# returns date
31416>>>>>  local date date#
31417>>>>>  move (DateCompose(1,1,year#)) to date#
31418>>>>>  if (DateWeekNumber(date#)) ne 1 move (date#+7) to date# // week 52 or 53
31421>>>>>  move (date#-DateDayNumber(date#)+1) to date# // Now it's a Monday
31422>>>>>  function_return (week#-1*7+date#)
31423>>>>>end_function
31424>>>>>
31424>>>>>function MonthName global integer int# returns string
31425>>>>>  if int# eq  1 function_return t.calendar.January
31428>>>>>  if int# eq  2 function_return t.calendar.February
31431>>>>>  if int# eq  3 function_return t.calendar.March
31434>>>>>  if int# eq  4 function_return t.calendar.April
31437>>>>>  if int# eq  5 function_return t.calendar.May
31440>>>>>  if int# eq  6 function_return t.calendar.June
31443>>>>>  if int# eq  7 function_return t.calendar.July
31446>>>>>  if int# eq  8 function_return t.calendar.August
31449>>>>>  if int# eq  9 function_return t.calendar.September
31452>>>>>  if int# eq 10 function_return t.calendar.October
31455>>>>>  if int# eq 11 function_return t.calendar.November
31458>>>>>  if int# eq 12 function_return t.calendar.December
31461>>>>>  function_return ""
31462>>>>>end_function
31463>>>>>
31463>>>>>function DateMonthName global date date# returns string
31464>>>>>  function_return (MonthName(DateSegment(date#,DS_MONTH)))
31465>>>>>end_function
31466>>>>>
31466>>>>>function DateAsText global date date# string format# returns string
31467>>>>>  if date# eq 0 function_return ""
31470>>>>>  move (replace("#DN",format#,DateDayName(date#)))                  to format#
31471>>>>>  move (replace("#MN",format#,DateMonthName(date#)))                to format#
31472>>>>>  move (replace("#D" ,format#,string(DateSegment(date#,DS_DAY))))   to format#
31473>>>>>  move (replace("#Y" ,format#,string(DateSegment(date#,DS_YEAR))))  to format#
31474>>>>>  move (replace("#M" ,format#,string(DateSegment(date#,DS_MONTH)))) to format#
31475>>>>>  function_return format#
31476>>>>>end_function
31477>>>>>
31477>>>>>function Year2to4 global integer year# returns integer
31478>>>>>  local integer epoch_value#
31479>>>>>   get_date_attribute EPOCH_VALUE to epoch_value#
31480>>>>>  if year# lt 100 begin
31482>>>>>    if year# gt epoch_value# function_return (year#+1900)
31485>>>>>    function_return (year#+2000)
31486>>>>>  end
31486>>>>>>
31486>>>>>  function_return year# // No conversion done!
31487>>>>>end_function
31488>>>>>
31488>>>>>function Date2to4 global date date# returns date
31489>>>>>  local integer epoch_value#
31490>>>>>   get_date_attribute EPOCH_VALUE to epoch_value#
31491>>>>>  if date# gt 0 begin // Only if there is a date to convert
31493>>>>>    if (DateSegment(date#,DS_YEAR)) lt 105 begin
31495>>>>>      if Dates$Year gt epoch_value# function_return (DateIncrement(date#,DS_YEAR,1900))
31498>>>>>      function_return (DateIncrement(date#,DS_YEAR,2000))
31499>>>>>    end
31499>>>>>>
31499>>>>>    function_return date# // No conversion done!
31500>>>>>  end
31500>>>>>>
31500>>>>>end_function
31501>>>>>
31501>>>>>function Date4to2 global date date# returns date
31502>>>>>  local integer epoch_value# year#
31503>>>>>   get_date_attribute EPOCH_VALUE to epoch_value#
31504>>>>>  if date# gt 0 begin // Only if there is a date to convert
31506>>>>>    move (DateSegment(date#,DS_YEAR)) to year#
31507>>>>>    if year# ge 100 begin // Only then conversion is needed!
31509>>>>>      if (year#>=(1900+epoch_value#) and year#<(2000+epoch_value#)) begin
31511>>>>>        if year# lt 2000 function_return (DateIncrement(date#,DS_YEAR,-1900))
31514>>>>>        else             function_return (DateIncrement(date#,DS_YEAR,-2000))
31516>>>>>      end
31516>>>>>>
31516>>>>>      else error 301 "Date is out of epoch range"
31518>>>>>    end
31518>>>>>>
31518>>>>>  end
31518>>>>>>
31518>>>>>  function_return date# // No conversion done!
31519>>>>>end_function
31520>>>>>
31520>>>>>function dSysDate global returns date
31521>>>>>  local date date#
31522>>>>>  sysdate4 date#
31523>>>>>  function_return date#
31524>>>>>end_function
31525>>>>>
31525>>>>>function iSysYear global returns integer
31526>>>>>  local date date#
31527>>>>>  sysdate4 date#
31528>>>>>  function_return (DateSegment(date#,DS_YEAR))
31529>>>>>end_function
31530>>>>>
31530>>>>>procedure ItemSysdate for desktop integer itm#
31531>>>>>  local date date#
31532>>>>>  get value item itm# to date#
31533>>>>>  if date# eq 0 begin
31535>>>>>    sysdate4 date#
31536>>>>>    set changed_value item itm# to date#
31537>>>>>  end
31537>>>>>>
31537>>>>>end_procedure
31538>>>>>
31538>>>>>procedure ItemDate2to4 for desktop integer itm#
31539>>>>>  local integer year#
31540>>>>>  local date date# new_date#
31540>>>>>  get value item itm# to date#
31541>>>>>
31541>>>>>  move (DateSegment(date#,DS_YEAR)) to year#
31542>>>>>  if (year#=0 and date#<>0) move (DateIncrement(date#,3,iSysYear())) to new_date#
31545>>>>>  else move date# to new_date#
31547>>>>>
31547>>>>>  move (Date2to4(new_date#)) to new_date#
31548>>>>>  move (DateSegment(new_date#,3)) to year#
31549>>>>>  if (year#>99 and year#<1000) begin
31551>>>>>    error 15 // Illegal entry in this window
31552>>>>>>
31552>>>>>    procedure_return 1
31553>>>>>  end
31553>>>>>>
31553>>>>>  if new_date# ne date# set value item itm# to new_date#
31556>>>>>end_procedure
31557>>>>>
31557>>>>>procedure ItemYear2to4 for desktop integer itm#
31558>>>>>  local integer year# new_year#
31559>>>>>  get value item itm# to year#
31560>>>>>  if (year#>99 and year#<1000) begin
31562>>>>>    error 15 // Illegal entry in this window
31563>>>>>>
31563>>>>>    procedure_return 1
31564>>>>>  end
31564>>>>>>
31564>>>>>  move (Year2to4(year#)) to new_year#
31565>>>>>  if new_year# ne year# set value item itm# to new_year#
31568>>>>>end_procedure
31569>>>>>
31569>>>>> procedure FieldSysdate for DataDictionary integer fld#
31570>>>>>   local date date#
31571>>>>>   get field_current_value fld# to date#
31572>>>>>   if date# eq 0 begin
31574>>>>>     sysdate4 date#
31575>>>>>     set field_changed_value fld# to date#
31576>>>>>   end
31576>>>>>>
31576>>>>> end_procedure
31577>>>>>
31577>>>>> procedure FieldDate2to4 for DataDictionary integer fld#
31578>>>>>   local integer year#
31579>>>>>   local date date# new_date#
31579>>>>>   get field_current_value fld# to date#
31580>>>>>
31580>>>>>   move (DateSegment(date#,DS_YEAR)) to year#
31581>>>>>   if (year#=0 and date#<>0) move (DateIncrement(date#,3,iSysYear())) to new_date#
31584>>>>>   else move date# to new_date#
31586>>>>>
31586>>>>>   move (Date2to4(new_date#)) to new_date#
31587>>>>>   move (DateSegment(new_date#,3)) to year#
31588>>>>>   if (year#>99 and year# <=999) begin
31590>>>>>     error 15 // Illegal entry in this window
31591>>>>>>
31591>>>>>     procedure_return 1
31592>>>>>   end
31592>>>>>>
31592>>>>>   if new_date# ne date# set field_changed_value fld# to new_date#
31595>>>>> end_procedure
31596>>>>>
31596>>>>> procedure FieldYear2to4 for DataDictionary integer fld#
31597>>>>>   local integer year# new_year# changed#
31598>>>>>   get field_current_value fld# to year#
31599>>>>>   get field_changed_state fld# to changed#
31600>>>>>   if changed# begin
31602>>>>>     if (year#>99 and year#<1000) begin
31604>>>>>       error 15 // Illegal entry in this window
31605>>>>>>
31605>>>>>       procedure_return 1
31606>>>>>     end
31606>>>>>>
31606>>>>>     move (Year2to4(year#)) to new_year#
31607>>>>>     if new_year# ne year# set field_changed_value fld# to new_year#
31610>>>>>   end
31610>>>>>>
31610>>>>> end_procedure
31611>>>>>
31611>>>>> function SysDate global returns date
31612>>>>>   function_return (dSysDate())
31613>>>>> end_function
31614>>>>>
31614>>>>>function sSysTime global returns string
31615>>>>>  local integer h# m# s#
31616>>>>>  sysdate4 h# h# m# s#
31620>>>>>  function_return (if(h#<10,"0","")+string(h#)+":"+if(m#<10,"0","")+string(m#)+":"+if(s#<10,"0","")+string(s#))
31621>>>>>end_function
31622>>>>>
31622>>>>>function TS_SysTime global returns number
31623>>>>>  local integer d# h# m# s#
31624>>>>>  sysdate4 d# h# m# s#
31628>>>>>  function_return (d#*24.0+h#*60+m#*60+s#)
31629>>>>>end_function
31630>>>>>
31630>>>>>//> This function returns a TS value composed from the date and time
31630>>>>>//> passed to it. Note that the time variable must be of the format
31630>>>>>//> "hh:mm:ss".
31630>>>>>function TS_Compose global date date# string time# returns number
31631>>>>>  local integer h# m# s#
31632>>>>>  left time# to h# 2
31634>>>>>>
31634>>>>>  mid time# to m# 2 4
31637>>>>>>
31637>>>>>  mid time# to s# 2 7
31640>>>>>>
31640>>>>>  function_return (integer(date#)*24.0+h#*60+m#*60+s#)
31641>>>>>end_function
31642>>>>>
31642>>>>>function TS_Compose2 global date date# integer h# integer m# integer s# returns number
31643>>>>>  function_return (integer(date#)*24.0+h#*60+m#*60+s#)
31644>>>>>end_function
31645>>>>>
31645>>>>>function TS_ExtractDate global number time# returns date
31646>>>>>  function_return (time#/86400) // 86400=24*60*60
31647>>>>>end_function
31648>>>>>
31648>>>>>function TS_ExtractTime global number time# returns string
31649>>>>>  local integer h# m# s#
31650>>>>>  move (time#-(86400.0*integer(TS_ExtractDate(time#)))) to s#
31651>>>>>  move (s#/3600) to h#
31652>>>>>  move (s#-(h#*3600)) to s#
31653>>>>>  move (s#/60) to m#
31654>>>>>  move (s#-(m#*60)) to s#
31655>>>>>  function_return (if(h#<10,"0","")+string(h#)+":"+if(m#<10,"0","")+string(m#)+":"+if(s#<10,"0","")+string(s#))
31656>>>>>end_function
31657>>>>>
31657>>>>>function TS_ConvertToString global number time# returns string
31658>>>>>  local date d#
31659>>>>>  move (TS_ExtractDate(time#)) to d#
31660>>>>>  if (integer(d#)) function_return (string(d#)+" "+TS_ExtractTime(time#))
31663>>>>>  else function_return (TS_ExtractTime(time#))
31665>>>>>end_function
31666>>>>>
31666>>>>>function TS_ConvertToStringNoDate global number ts# returns string
31667>>>>>  local integer h# m#
31668>>>>>  move (ts#/3600) to h#
31669>>>>>  move (ts#-(h#*3600)) to ts#
31670>>>>>  move (ts#/60) to m#
31671>>>>>  move (ts#-(m#*60)) to ts#
31672>>>>>  function_return (if(h#<10,"0","")+string(h#)+":"+if(m#<10,"0","")+string(m#)+":"+if(ts#<10,"0","")+string(ts#))
31673>>>>>end_function
31674>>>>>
31674>>>>>// This procedure is used when a TS-variable must be displayed on screen.
31674>>>>>procedure TS_UI_Update global number TS# integer obj1# integer itm1# integer tmp_obj2# integer tmp_itm2#
31675>>>>>  local integer obj2# itm2#
31676>>>>>  if num_arguments gt 3 begin
31678>>>>>    move tmp_obj2# to obj2#
31679>>>>>    move tmp_itm2# to itm2#
31680>>>>>  end
31680>>>>>>
31680>>>>>  else begin
31681>>>>>    move obj1# to obj2#
31682>>>>>    move (itm1#+1) to itm2#
31683>>>>>  end
31683>>>>>>
31683>>>>>  set value of obj1# item itm1# to (TS_ExtractDate(TS#))
31684>>>>>  set value of obj2# item itm2# to (TS_ExtractTime(TS#))
31685>>>>>end_procedure
31686>>>>>
31686>>>>>class TS_TimeEstimator is an array
31687>>>>>  procedure construct_object
31688>>>>>    forward send construct_object
31690>>>>>    set delegation_mode to delegate_to_parent
31691>>>>>    property number  pnTotal   public 0 // Seconds needed to run the loop.
31692>>>>>    property number  pnElapsed public 0 // Seconds elapsed so far.
31693>>>>>    property number  pnLeft    public 0 // Number of seconds left
31694>>>>>    property number  pnStart   public 0
31695>>>>>    property number  pnPause   public 0
31696>>>>>    property number  pnPercent public 0
31697>>>>>    property integer piMin     public 0
31698>>>>>    property integer piMax     public 0
31699>>>>>  end_procedure
31700>>>>>
31700>>>>>  procedure TS_Start integer min# integer max#
31701>>>>>    set piMin to min#
31702>>>>>    set piMax to max#
31703>>>>>    set pnStart to (TS_SysTime())
31704>>>>>    set pnElapsed to 0
31705>>>>>    set pnPercent to 0
31706>>>>>  end_procedure
31707>>>>>
31707>>>>>  procedure TS_Calculate integer pos#
31708>>>>>    local integer min# max#
31709>>>>>    get piMin to min#
31710>>>>>    get piMax to max#
31711>>>>>    set pnElapsed to (TS_SysTime()-pnStart(current_object))
31712>>>>>    set pnTotal   to (pnElapsed(current_object)*(max#-min#)/number(pos#-min#))
31713>>>>>    set pnLeft    to (pnTotal(current_object)-pnElapsed(current_object))
31714>>>>>    set pnPercent to (100.0*(pos#-min#)/(max#-min#))
31715>>>>>  end_procedure
31716>>>>>
31716>>>>>  procedure TS_Pause
31717>>>>>    set pnPause to (TS_SysTime())
31718>>>>>  end_procedure
31719>>>>>
31719>>>>>  procedure TS_Continue
31720>>>>>    set pnStart to (pnStart(current_object)+TS_SysTime()-pnPause(current_object))
31721>>>>>  end_procedure
31722>>>>>end_class
31723>>>>>
31723>>>>>function TS_Module_Compile_Time global string path# returns number
31724>>>>>  local integer pos# day# month# year# seqeof# ch#
31725>>>>>  local string date# str# time#
31725>>>>>  move path# to str#
31726>>>>>  if str# ne "" begin
31728>>>>>    get Seq_New_Channel to ch#   // This method and Seq_Release_Channel are
31729>>>>>    send Seq_Release_Channel ch# // We only need it for a second
31730>>>>>      direct_input channel ch# (trim(str#)+".vd6") // VDF 6
31732>>>>>      [seqeof] direct_input channel ch# (trim(str#)+".vd5") // VDF 5
31734>>>>>    [ seqeof] move 1 to seqeof#
31735>>>>>    [~seqeof] move 0 to seqeof#
31736>>>>>    [~seqeof] readln str#
31737>>>>>    close_input channel ch#
31739>>>>>  end
31739>>>>>>
31739>>>>>  if seqeof# function_return 0
31742>>>>>  pos "," in str# to pos#
31744>>>>>>
31744>>>>>  move (mid(str#,18,pos#+2)) to str#
31745>>>>>  move (integer(mid(str#,2,4))) to day#
31746>>>>>  move (integer(mid(str#,2,1))) to month#
31747>>>>>  move (integer(mid(str#,2,7))) to year#
31748>>>>>  if year# eq 10 begin
31750>>>>>    move (integer(mid(str#,3,7))+1900) to year#
31751>>>>>    move (mid(str#,8,11)) to str#
31752>>>>>  end
31752>>>>>>
31752>>>>>  else move (mid(str#,8,10)) to str#
31754>>>>>  move (DateCompose(day#,month#,year#)) to date#
31755>>>>>  move (Date2to4(date#)) to date#
31756>>>>>  pos ":" in str# to pos#
31758>>>>>>
31758>>>>>  function_return (TS_Compose(date#,mid(str#,8,pos#-2)))
31759>>>>>end_function
31760>>>>>
31760>>>>>string Dates$Module_Compile_Time
31760>>>>>move "" to Dates$Module_Compile_Time
31761>>>>>
31761>>>>>function Module_Compile_Date global returns date
31762>>>>>  local number ts#
31763>>>>>  local string str#
31763>>>>>  get module_name to str# // 'module_name' is most likely the name of the .flx file.
31764>>>>>  get TS_Module_Compile_Time str# to ts#
31765>>>>>  move (TS_ExtractTime(ts#)) to Dates$Module_Compile_Time
31766>>>>>  function_return (TS_ExtractDate(ts#))
31767>>>>>end_function
31768>>>>>
31768>>>>>function Module_Compile_Time global returns string
31769>>>>>  local date grb#
31770>>>>>  // Module_Compile_Date must be called before this one!
31770>>>>>  if Dates$Module_Compile_Time eq "" move (Module_Compile_Date()) to grb#
31773>>>>>  function_return Dates$Module_Compile_Time
31774>>>>>end_function
31775>>>>>
31775>>>>>date   Dates$ModuleStartDate
31775>>>>>string Dates$ModuleStartTime 8
31775>>>>>move (dSysDate()) to Dates$ModuleStartDate
31776>>>>>move (sSysTime()) to Dates$ModuleStartTime
31777>>>>>
31777>>>>>function Module_Start_Date global returns date
31778>>>>>  function_return Dates$ModuleStartDate
31779>>>>>end_function
31780>>>>>
31780>>>>>function Module_Start_Time global returns string
31781>>>>>  function_return Dates$ModuleStartTime
31782>>>>>end_function
31783>>>>>
31783>>>>> register_procedure NotifyPopupCalendarChange date date#
31783>>>>> register_procedure NotifyPopupCalendarSelect date date#
31783>>>>>  use dfAllent
31783>>>>>  class calendar.textbox is a textbox
31784>>>>>    procedure construct_object
31785>>>>>      forward send construct_object
31787>>>>>      Set Auto_Size_State To False
31788>>>>>      Set Justification_Mode To (jMode_vCenter+jMode_Center)
31789>>>>>    end_procedure
31790>>>>>  end_class
31791>>>>>
31791>>>>>  register_object btn1
31791>>>>>  register_object btn6
31791>>>>>
31791>>>>>  class calendar.button is a button
31792>>>>>
31792>>>>>    procedure construct_object
31793>>>>>      forward send construct_object
31795>>>>>      set size to 15 18
31796>>>>>      on_key kleftarrow   send prev_day
31797>>>>>      on_key krightarrow  send next_day
31798>>>>>      on_key kuparrow     send prev_week
31799>>>>>      on_key kdownarrow   send next_week
31800>>>>>      property date p_assigned_date public 0
31801>>>>>    end_procedure
31802>>>>>
31802>>>>>    procedure switch // This makes all 42 buttons act as if they are one focus
31803>>>>>      send activate to (btn1(current_object))
31804>>>>>    end_procedure
31805>>>>>    procedure switch_back
31806>>>>>      send activate to (btn6(current_object))
31807>>>>>    end_procedure
31808>>>>>
31808>>>>>    procedure mouse_down
31809>>>>>      local integer current_object#
31810>>>>>      forward send mouse_down
31812>>>>>      move current_object to current_object#
31813>>>>>      delegate set p_current_date to (p_assigned_date(current_object#))
31815>>>>>    end_procedure
31816>>>>>  end_class
31817>>>>>
31817>>>>>  desktop_section
31823>>>>>    object popup_calendar is a ModalPanel
31825>>>>>      set size to 160 250
31826>>>>>      property date    p_current_date  public 0
31828>>>>>      property integer p_current_year  public -1
31830>>>>>      property integer p_current_month public -1
31832>>>>>      property integer pExportState    public 1
31834>>>>>
31834>>>>>      on_key key_ctrl+key_pgup send prev_year
31835>>>>>      on_key key_ctrl+key_pgdn send next_year
31836>>>>>      on_key          key_pgup send prev_month
31837>>>>>      on_key          key_pgdn send next_month
31838>>>>>      on_key key_ctrl+key_d    send go_today
31839>>>>>      on_key kcancel           send cancel
31840>>>>>
31840>>>>>      object cont3d is a container3d
31842>>>>>        set location to 5 5
31843>>>>>        set size to 120 237
31844>>>>>        object textbox_year is a calendar.textbox
31846>>>>>          set location to 5 5
31847>>>>>          set size to 15 30
31848>>>>>          set border_style to border_staticedge
31849>>>>>          procedure display
31851>>>>>            set value to (p_current_year(current_object))
31852>>>>>          end_procedure
31853>>>>>        end_object
31854>>>>>        object dayname_header is a container3d
31856>>>>>          set location to 5 39
31857>>>>>          set size to 15 126
31858>>>>>          set border_style to border_staticedge
31859>>>>>          procedure initialize
31861>>>>>            local integer itm#
31862>>>>>            for itm# from 0 to 6
31868>>>>>>
31868>>>>>              object txt is a calendar.textbox
31870>>>>>                set size to 12 17
31871>>>>>                set location to 0 (itm#*17.6+1)
31872>>>>>                 set value to (left(DayName(itm#+1),3))
31873>>>>>              end_object
31874>>>>>            loop
31875>>>>>>
31875>>>>>          end_procedure
31876>>>>>          send initialize
31877>>>>>        end_object
31878>>>>>        object weeknumber_header is a container3d
31880>>>>>          set location to 24 5
31881>>>>>          set size     to 89 30
31882>>>>>          set border_style to border_staticedge
31883>>>>>          object obj_id_array is an array
31885>>>>>          end_object
31886>>>>>          procedure initialize
31888>>>>>            local integer itm# obj#
31889>>>>>            move (obj_id_array(current_object)) to obj#
31890>>>>>            for itm# from 0 to 5
31896>>>>>>
31896>>>>>              object txt is a textbox
31898>>>>>                set size to 15 30
31899>>>>>                set location to (itm#*15+1) 1
31900>>>>>                set value of obj# item (item_count(obj#)) to current_object
31901>>>>>              end_object
31902>>>>>            loop
31903>>>>>>
31903>>>>>          end_procedure
31904>>>>>          procedure display
31906>>>>>            local integer itm# obj#
31907>>>>>            local date date# last_date#
31907>>>>>            move (obj_id_array(current_object)) to obj#
31908>>>>>            get p_current_date to date#
31909>>>>>            move (FirstDayInMonth(date#)) to date#
31910>>>>>            move (LastDayInMonth(date#)) to last_date#
31911>>>>>            move (date#-DateDayNumber(date#)+1) to date#
31912>>>>>            for itm# from 0 to 5
31918>>>>>>
31918>>>>>              if (itm#*7+date#) le last_date# ;                set value of (integer(value(obj#,itm#))) to (t.calendar.week*string(DateWeekNumber(itm#*7+date#)))
31921>>>>>              else set value of (integer(value(obj#,itm#))) to ""
31923>>>>>            loop
31924>>>>>>
31924>>>>>          end_procedure
31925>>>>>          send initialize
31926>>>>>        end_object
31927>>>>>        object days_grid is a container3d
31929>>>>>          set location to 23 39
31930>>>>>          set size     to 100 127
31931>>>>>          set border_style to border_none
31932>>>>>          object btn_array is an array
31934>>>>>          end_object
31935>>>>>          procedure initialize
31937>>>>>            local integer row# col# button_array#
31938>>>>>            move (btn_array(current_object)) to button_array#
31939>>>>>            for row# from 0 to 5
31945>>>>>>
31945>>>>>              for col# from 0 to 6
31951>>>>>>
31951>>>>>                object btn is a calendar.button
31953>>>>>                  set location to (row#*15) (col#*18)
31954>>>>>                  set value of button_array# item (item_count(button_array#)) to current_object
31955>>>>>                  on_item "" send move_value_out_ok
31956>>>>>                end_object
31957>>>>>              loop
31958>>>>>>
31958>>>>>            loop
31959>>>>>>
31959>>>>>          end_procedure
31960>>>>>          send initialize
31961>>>>>
31961>>>>>          procedure display.iii integer itm# integer day# integer activate#
31963>>>>>            local integer obj# current_day#
31964>>>>>            move (integer(value(btn_array(current_object),itm#))) to obj#
31965>>>>>            move (DateSegment(p_current_date(current_object),DS_DAY)) to current_day#
31966>>>>>            if activate# begin
31968>>>>>              if day# eq current_day# send activate to obj#
31971>>>>>            end
31971>>>>>>
31971>>>>>            else begin
31972>>>>>              if day# begin
31974>>>>>                set value of obj# to day#
31975>>>>>                set visible_state of obj# to true
31976>>>>>                set p_assigned_date of obj# to (DateCompose(day#,p_current_month(current_object),p_current_year(current_object)))
31977>>>>>              end
31977>>>>>>
31977>>>>>              else set visible_state of obj# to false
31979>>>>>            end
31979>>>>>>
31979>>>>>          end_procedure
31980>>>>>
31980>>>>>          procedure display integer activate#
31982>>>>>            local integer first_item# last_item# itm# day# date#
31983>>>>>            get p_current_date to date#
31984>>>>>            move (FirstDayInMonth(date#)) to date#
31985>>>>>            move (DateDayNumber(date#)-1) to first_item#
31986>>>>>            move (LastDayInMonth(date#)-date#+first_item#) to last_item#
31987>>>>>            ifnot activate# begin
31989>>>>>              for itm# from 0 to (first_item#-1)
31995>>>>>>
31995>>>>>                send display.iii itm# 0 0
31996>>>>>              loop
31997>>>>>>
31997>>>>>            end
31997>>>>>>
31997>>>>>            move 1 to day#
31998>>>>>            for itm# from first_item# to last_item#
32004>>>>>>
32004>>>>>              send display.iii itm# day# activate#
32005>>>>>              increment day#
32006>>>>>            loop
32007>>>>>>
32007>>>>>            ifnot activate# begin
32009>>>>>              for itm# from (last_item#+1) to 41
32015>>>>>>
32015>>>>>                send display.iii itm# 0 0
32016>>>>>              loop
32017>>>>>>
32017>>>>>            end
32017>>>>>>
32017>>>>>          end_procedure
32018>>>>>        end_object
32019>>>>>        object txt_month is a calendar.textbox
32021>>>>>          set size to 12 27
32022>>>>>          set location to 25 185
32023>>>>>          set value to t.calendar.month
32024>>>>>        end_object
32025>>>>>        object btn1 is a button
32027>>>>>          set size to 12 12
32028>>>>>          set location to 40 185
32029>>>>>          on_item "" send prev_month
32030>>>>>          set bitmap to "prev.bmp"
32031>>>>>          procedure switch_back
32033>>>>>            send display_main
32034>>>>>          end_procedure
32035>>>>>        end_object
32036>>>>>        object btn2 is a button
32038>>>>>          set size to 12 12
32039>>>>>          set location to 40 200
32040>>>>>          on_item "" send next_month
32041>>>>>          set bitmap to "next.bmp"
32042>>>>>        end_object
32043>>>>>        object txt_year is a calendar.textbox
32045>>>>>          set size to 12 27
32046>>>>>          set location to 70 185
32047>>>>>          set value to t.calendar.year
32048>>>>>        end_object
32049>>>>>        object btn3 is a button
32051>>>>>          set size to 12 12
32052>>>>>          set location to 85 185
32053>>>>>          on_item "" send prev_year
32054>>>>>          set bitmap to "prev.bmp"
32055>>>>>        end_object
32056>>>>>        object btn4 is a button
32058>>>>>          set size to 12 12
32059>>>>>          set location to 85 200
32060>>>>>          on_item "" send next_year
32061>>>>>          set bitmap to "next.bmp"
32062>>>>>        end_object
32063>>>>>      end_object
32064>>>>>      object btn5 is a button
32066>>>>>        set size to 14 60
32067>>>>>        set location to 129 115
32068>>>>>        on_item t.calendar.ok send move_value_out_ok
32069>>>>>      end_object
32070>>>>>      object btn6 is a button
32072>>>>>        set size to 14 60
32073>>>>>        set location to 129 182
32074>>>>>        on_item t.calendar.cancel send cancel
32075>>>>>        procedure switch
32077>>>>>          send display_main
32078>>>>>        end_procedure
32079>>>>>      end_object
32080>>>>>      procedure next_year
32082>>>>>        set p_current_date to (DateIncrement(p_current_date(current_object),DS_YEAR,1))
32083>>>>>        send display_main
32084>>>>>      end_procedure
32085>>>>>      procedure prev_year
32087>>>>>        set p_current_date to (DateIncrement(p_current_date(current_object),DS_YEAR,-1))
32088>>>>>        send display_main
32089>>>>>      end_procedure
32090>>>>>      procedure next_month
32092>>>>>        set p_current_date to (DateIncrement(p_current_date(current_object),DS_MONTH,1))
32093>>>>>        send display_main
32094>>>>>      end_procedure
32095>>>>>      procedure prev_month
32097>>>>>        set p_current_date to (DateIncrement(p_current_date(current_object),DS_MONTH,-1))
32098>>>>>        send display_main
32099>>>>>      end_procedure
32100>>>>>      procedure next_week
32102>>>>>        set p_current_date to (DateIncrement(p_current_date(current_object),DS_WEEK,1))
32103>>>>>        send display_main
32104>>>>>      end_procedure
32105>>>>>      procedure prev_week
32107>>>>>        set p_current_date to (DateIncrement(p_current_date(current_object),DS_WEEK,-1))
32108>>>>>        send display_main
32109>>>>>      end_procedure
32110>>>>>      procedure next_day
32112>>>>>        set p_current_date to (DateIncrement(p_current_date(current_object),DS_DAY,1))
32113>>>>>        send display_main
32114>>>>>      end_procedure
32115>>>>>      procedure prev_day
32117>>>>>        set p_current_date to (DateIncrement(p_current_date(current_object),DS_DAY,-1))
32118>>>>>        send display_main
32119>>>>>      end_procedure
32120>>>>>      procedure go_today
32122>>>>>        local date date#
32123>>>>>        sysdate4 date#
32124>>>>>        set p_current_date to date#
32125>>>>>        send display_main
32126>>>>>      end_procedure
32127>>>>>      property integer invoking_object_id public 0
32129>>>>>      procedure OnChange date date#
32131>>>>>        local integer focus# dm#
32132>>>>>        get invoking_object_id to focus#
32133>>>>>        if focus# gt desktop begin
32135>>>>>          get delegation_mode of focus# to dm#
32136>>>>>          set delegation_mode of focus# to no_delegate_or_error
32137>>>>>          send NotifyPopupCalendarChange to focus# date#
32138>>>>>          set delegation_mode of focus# to dm#
32139>>>>>        end
32139>>>>>>
32139>>>>>      end_procedure
32140>>>>>      procedure display
32142>>>>>        local integer date# month# year#
32143>>>>>        get p_current_date to date#
32144>>>>>        send OnChange date#
32145>>>>>        move (DateSegment(date#,DS_YEAR)) to year#
32146>>>>>        move (DateSegment(date#,DS_MONTH)) to month#
32147>>>>>        if (p_current_year(current_object)<>year# or p_current_month(current_object)<>month#) begin
32149>>>>>          set p_current_year to year#
32150>>>>>          set p_current_month to month#
32151>>>>>          set value to (t.calendar.calendar_popup+", "+MonthName(month#))
32152>>>>>          send display to (textbox_year(cont3d(current_object)))
32153>>>>>          send display to (weeknumber_header(cont3d(current_object)))
32154>>>>>          send display to (days_grid(cont3d(current_object))) 0
32155>>>>>        end
32155>>>>>>
32155>>>>>      end_procedure
32156>>>>>      procedure display_main
32158>>>>>        send display
32159>>>>>        send display to (days_grid(cont3d(current_object))) 1
32160>>>>>      end_procedure
32161>>>>>      procedure popup_no_export
32163>>>>>        set pExportState to false
32164>>>>>        send popup
32165>>>>>        set pExportState to true
32166>>>>>      end_procedure
32167>>>>>
32167>>>>>      procedure popup_group
32169>>>>>        local integer focus#
32170>>>>>        local date date#
32170>>>>>        move (focus(desktop)) to focus#
32171>>>>>        set invoking_object_id to focus#
32172>>>>>        get value of focus# item current to date#
32173>>>>>        ifnot (integer(date#)) move (dSysdate()) to date#
32176>>>>>        move (Date2to4(date#)) to date#
32177>>>>>        set p_current_date to date#
32178>>>>>        send display
32179>>>>>        forward send popup_group
32181>>>>>        send display to (days_grid(cont3d(current_object))) 1
32182>>>>>      end_procedure
32183>>>>>
32183>>>>>      procedure move_value_out
32185>>>>>        local integer focus# dm# margin# datatype#
32186>>>>>        if (pExportState(current_object)) begin
32188>>>>>          get invoking_object_id to focus#
32189>>>>>          if focus# gt desktop begin
32191>>>>>            get delegation_mode of focus# to dm#
32192>>>>>            set delegation_mode of focus# to no_delegate_or_error
32193>>>>>            send NotifyPopupCalendarSelect to focus# (p_current_date(current_object))
32194>>>>>            get form_margin of focus# item current to margin#
32195>>>>>            get form_datatype of focus# item current to datatype#
32196>>>>>            set delegation_mode of focus# to dm#
32197>>>>>            if (margin#>=10 or datatype#=mask_date_window or datatype#=date_window) set value of focus# item current to (p_current_date(current_object))
32200>>>>>            else             set value of focus# item current to (Date4to2(p_current_date(current_object)))
32202>>>>>            set item_changed_state of focus# item current to true
32203>>>>>          end
32203>>>>>>
32203>>>>>        end
32203>>>>>>
32203>>>>>      end_procedure
32204>>>>>
32204>>>>>      procedure move_value_out_ok
32206>>>>>        send move_value_out
32207>>>>>        send deactivate
32208>>>>>      end_procedure
32209>>>>>
32209>>>>>      procedure request_popup
32211>>>>>        local integer focus# type# dm#
32212>>>>>        move (focus(desktop)) to focus#
32213>>>>>        if focus# gt desktop begin
32215>>>>>          get delegation_mode of focus# to dm#
32216>>>>>          set delegation_mode of focus# to no_delegate_or_error
32217>>>>>          get form_datatype of focus# item current to type#
32218>>>>>          if (type#=date_window or type#=mask_date_window) send popup
32221>>>>>          set delegation_mode of focus# to dm#
32222>>>>>        end
32222>>>>>>
32222>>>>>      end_procedure
32223>>>>>    end_object
32224>>>>>  end_desktop_section
32226>>>>>  // If the procedure below was not defined "for BaseClass" its symbolic
32226>>>>>  // substitute would become negative (because located on the desktop). This
32226>>>>>  // would result in the toolbar object not being able to handle it. Therefore:
32226>>>>>  procedure request_popup_calendar for BaseClass
32227>>>>>    send request_popup to (popup_calendar(current_object))
32228>>>>>  end_procedure
32229>>>>>  procedure popup_calendar_no_export
32230>>>>>    send popup_no_export to (popup_calendar(current_object))
32231>>>>>  end_procedure
32232>>>>>  register_procedure Add_Toolbar_Button_Bitmap string bmp# string Tip# string StHlp# integer msg# integer obj#
32232>>>>>  procedure Add_Calendar_tbButton integer oTb#
32233>>>>>    send Add_Toolbar_Button_Bitmap to oTb# "DfCalend.bmp" t.calendar.calendar_popup t.calendar.Activate msg_request_popup_calendar
32234>>>>>  end_procedure
32235>>>>> function s.calendar returns integer // Backwards compatible!!
32236>>>>>   function_return (popup_calendar(current_object))
32237>>>>> end_function
32238>>>>>
32238>>>>>// Karl,
32238>>>>>// Structure is as follows,
32238>>>>>//
32238>>>>>// //put this code in the top portion of the view code or in the program
32238>>>>>// code.
32238>>>>>//
32238>>>>>// Type SystemTime
32238>>>>>//   field SystemTime.iYear As Word
32238>>>>>//   field SystemTime.iMonth As Word
32238>>>>>//   field SystemTime.iDayOfWeek As Word
32238>>>>>//   field SystemTime.iDay As Word
32238>>>>>//   field SystemTime.iHour As Word
32238>>>>>//   field SystemTime.iMinute As Word
32238>>>>>//   field SystemTime.iSecond As Word
32238>>>>>//   field SystemTime.iMilliseconds As Word
32238>>>>>// End_Type
32238>>>>>//
32238>>>>>// external_function GetSystemTime "GetSystemTime" kernel32.dll Pointer lpGST Returns VOID_TYPE
32238>>>>>//
32238>>>>>// //put this code in an onClick or wherever
32238>>>>>// procedure onclick
32238>>>>>//   local integer iRetVal
32238>>>>>//   local string TimeData
32238>>>>>//   local pointer GST
32238>>>>>//
32238>>>>>//   ZeroType SystemTime to TimeData
32238>>>>>//   getAddress from TimeData to GST
32238>>>>>//
32238>>>>>//   move (GetSystemTime(GST)) to iRetVal
32238>>>>>// end_procedure
32238>>>>>//
32238>>>>>// To extract the data from the Structure after calling the function use
32238>>>>>// the getbuff command as follows:
32238>>>>>//
32238>>>>>// getbuff from TimeData as SystemTime.IVAL to var
32238>>>>>//
32238>>>>>// where IVAL is one of the vars such as iYear or iDay, etc.
32238>>>>>//
32238>>>>>// OLIVER NELSON
32238>>>>>//
32238>>>>>//
32238>>>
32238>>>//AB-StoreTopEnd
32238>>>
32238>>>//AB-IgnoreStart
32238>>>
32238>>>Use DFAllEnt.pkg
32238>>>
32238>>>
32238>>>//AB-IgnoreEnd
32238>>>
32238>>>CD_Popup_Object oCalendar is a dbModalPanel
32257>>>
32257>>>    //AB-StoreTopStart
32257>>>    on_key kcancel           send cancel
32258>>>    //AB-StoreTopEnd
32258>>>
32258>>>    Set Border_Style to Border_Normal
32259>>>    Set Caption_Bar to FALSE
32260>>>    Set Label to "Ÿ­¢ àì, 2001"
32261>>>    Set Size to 98 123
32262>>>    Set Location to 10 22
32263>>>    Set Color to clWhite
32264>>>
32264>>>    //AB-DDOStart
32264>>>
32264>>>
32264>>>    //AB-DDOEnd
32264>>>
32264>>>    Object Container3d1 is a Container3d
32266>>>        Set Size to 88 135
32267>>>        Set Location to -2 -1
32268>>>        Set Color to clWhite
32269>>>        Set Border_Style to Border_None
32270>>>        Object Grid2 is a Grid
32272>>>
32272>>>            //AB-StoreTopStart
32272>>>            property date    p_current_date     public 0
32274>>>            property integer p_current_year     public -1
32276>>>            property integer p_current_month    public -1
32278>>>            property integer p_selected_day     public -1
32280>>>            property integer pExportState       public 1
32282>>>            property integer invoking_object_id public 0
32284>>>            
32284>>>            Set Border_Style To BORDER_NONE
32285>>>            Set header_visible_state To False
32286>>>            set select_mode to no_select
32287>>>            Set Gridline_mode To GRID_VISIBLE_NONE
32288>>>            
32288>>>            on_key Key_F1 Send Help
32289>>>            on_key key_ctrl+key_pgup send prev_year
32290>>>            on_key key_ctrl+key_pgdn send next_year
32291>>>            on_key          key_pgup send prev_month
32292>>>            on_key          key_pgdn send next_month
32293>>>            on_key key_enter         send move_value_out
32294>>>            on_key key_ctrl+key_d    send go_today
32295>>>            
32295>>>            //AB-StoreTopEnd
32295>>>
32295>>>            Set Color to clWhite
32296>>>            Set CurrentCellColor to clWhite
32297>>>            Set CurrentCellTextColor to clWhite
32298>>>            Set Size to 61 145
32299>>>            Set Location to 30 1
32300>>>            Set Resize_Column_state to FALSE
32301>>>
32301>>>            Set Line_Width to 7 0
32302>>>
32302>>>            Set Form_Width    item 0 to 18
32303>>>            Set Header_Label  item 0 to "­"
32304>>>            
32304>>>            Set Form_Width    item 1 to 18
32305>>>            Set Header_Label  item 1 to "‚â"
32306>>>            
32306>>>            Set Form_Width    item 2 to 18
32307>>>            Set Header_Label  item 2 to "‘à"
32308>>>            
32308>>>            Set Form_Width    item 3 to 18
32309>>>            Set Header_Label  item 3 to "—â"
32310>>>            
32310>>>            Set Form_Width    item 4 to 18
32311>>>            Set Header_Label  item 4 to "â"
32312>>>            
32312>>>            Set Form_Width    item 5 to 18
32313>>>            Set Header_Label  item 5 to "‘¡"
32314>>>            
32314>>>            Set Form_Width    item 6 to 18
32315>>>            Set Header_Label  item 6 to "‚á"
32316>>>            
32316>>>
32316>>>            //AB-StoreStart
32316>>>            
32316>>>            procedure go_today
32318>>>                Date date#
32319>>>                sysdate4 date#
32320>>>                set p_current_date to date#
32321>>>                Send Update_Calendar
32322>>>            end_procedure
32323>>>            
32323>>>            procedure next_month
32325>>>                set p_current_date to (DateIncrement(p_current_date(current_object),DS_MONTH,1))
32326>>>                Send Update_Calendar
32327>>>            end_procedure
32328>>>            
32328>>>            procedure prev_month
32330>>>                set p_current_date to (DateIncrement(p_current_date(current_object),DS_MONTH,-1))
32331>>>                Send Update_Calendar
32332>>>            end_procedure
32333>>>            
32333>>>            procedure next_year
32335>>>                set p_current_date to (DateIncrement(p_current_date(current_object),DS_YEAR,1))
32336>>>                Send Update_Calendar
32337>>>            end_procedure
32338>>>            
32338>>>            procedure prev_year
32340>>>                set p_current_date to (DateIncrement(p_current_date(current_object),DS_YEAR,-1))
32341>>>                Send Update_Calendar
32342>>>            end_procedure
32343>>>            
32343>>>            Procedure Activate
32345>>>                Date date#
32346>>>                Forward Send Activate
32348>>>                Set current_item to (p_selected_day(Self))
32349>>>            End_Procedure
32350>>>            
32350>>>            Procedure Update_Calendar
32352>>>                Set Dynamic_Update_State To False
32353>>>                send Fill_List
32354>>>                Set Dynamic_Update_State To True
32355>>>                // Send Update_Label
32355>>>                Set current_item to (p_selected_day(Self))
32356>>>                Send Date_Changing to (oYear(Container3d2(self)))
32357>>>                Send Date_Changing to (oMonth(Container3d2(self)))
32358>>>            End_Procedure
32359>>>            
32359>>>            Procedure Fill_List
32361>>>                Integer iFor prevdate# date# first_item# last_item# day# prev_last# nextdate# next_first#
32362>>>                Integer cur_year# cur_month# cur_day# sel_month# sel_day# sel_year#
32362>>>                Date dToday
32362>>>                Send Delete_Data
32363>>>            
32363>>>                Get p_current_date to date#
32364>>>            
32364>>>                SysDate4 dToday
32365>>>                move (DateSegment(dToday,DS_DAY)) to cur_day#
32366>>>                move (DateSegment(dToday,DS_MONTH)) to cur_month#
32367>>>                move (DateSegment(dToday,DS_YEAR)) to cur_year#
32368>>>            
32368>>>                move (DateSegment(date#,DS_DAY)) to sel_day#
32369>>>                move (DateSegment(date#,DS_MONTH)) to sel_month#
32370>>>                move (DateSegment(date#,DS_YEAR)) to sel_year#
32371>>>                Set p_current_month To sel_month#
32372>>>                Set p_current_year To sel_year#
32373>>>            
32373>>>                move (FirstDayInMonth(date#)) to date#
32374>>>                move (DateDayNumber(date#)-1) to first_item#
32375>>>                move (LastDayInMonth(date#)-date#+first_item#) to last_item#
32376>>>                move (DateIncrement(date#,DS_Month,-1)) To prevdate#
32377>>>                move (DateSegment((LastDayInMonth(prevdate#)),DS_DAY)) to prev_last#
32378>>>            
32378>>>                If (first_item# > 0) Begin
32380>>>                    Move (first_item#-1) to day#
32381>>>                    For iFor from 0 to (first_item#-1)
32387>>>>
32387>>>                        Send Add_Item msg_move_value_out (prev_last#-day#)
32388>>>                        Set Entry_State Item iFor To False
32389>>>                        Set ItemTextColor Item iFor To clGray
32390>>>                        Decrement day#
32391>>>                    Loop
32392>>>>
32392>>>                End
32392>>>>
32392>>>            
32392>>>                Move 1 To day#
32393>>>                For iFor from first_item# to last_item#
32399>>>>
32399>>>                    Send Add_Item Msg_Move_Value_Out day#
32400>>>                    Set Entry_State Item iFor To False
32401>>>                    If ((cur_month# eq sel_month#)and(cur_year# eq sel_year#)and(Day# eq cur_day#)) Set Form_Bitmap Item iFor To "cdate.bmp"
32404>>>                    If Day# eq sel_day# Set p_selected_day To iFor
32407>>>                    Set Form_justification_mode Item iFor To FORM_DISPLAYRIGHT
32408>>>                    Set form_datatype item iFor To mask_numeric_window
32409>>>                    Set form_Mask item iFor To "## "
32410>>>                    Increment day#
32411>>>                Loop
32412>>>>
32412>>>            
32412>>>                move (DateIncrement(date#,DS_Month,1)) To nextdate#
32413>>>                move (DateSegment((LastDayInMonth(nextdate#)),DS_DAY)) to next_first#
32414>>>            
32414>>>                If (last_item# < 41) Begin
32416>>>                    Move 1 to day#
32417>>>                    For iFor from (last_item#+1) to 41
32423>>>>
32423>>>                        Send Add_Item msg_move_value_out day#
32424>>>                        Set Entry_State Item iFor To False
32425>>>                        Set ItemTextColor Item iFor To clGray
32426>>>                        Increment day#
32427>>>                    Loop
32428>>>>
32428>>>                End
32428>>>>
32428>>>            
32428>>>            End_Procedure
32429>>>            
32429>>>            Procedure Help
32431>>>                Send Info_Box ("<Up>, <Dn>, <Lft>, <Rgt> - select date.\n<PgUp>, <PgDn> - select month.\n<Ctrl>+<D> - set current date.\n<Ctrl>+<PgUp>, <PgDn> - Select year.\n\n(c) 2001, SCR. Special thanks to Sture Andersen.") ("Help on Calendar")
32432>>>            End_Procedure
32433>>>            
32433>>>            procedure mouse_click integer window integer char_pos
32435>>>                Send Move_Value_Out
32436>>>                forward send mouse_click window char_pos
32438>>>            end_procedure
32439>>>            
32439>>>            Procedure Move_Value_Out
32441>>>                Integer iYear iMonth iDay iItm
32442>>>                Date Date# next_date# prev_date#
32442>>>                Get Current_Item To iItm
32443>>>                If (pExportState(Self)) Begin
32445>>>                    Get Value Item iItm To iDay
32446>>>                    Get p_current_month to iMonth
32447>>>                    Get p_current_year  to iYear
32448>>>                    Move (DateCompose(iDay,iMonth,iYear)) To date#
32449>>>            
32449>>>                    If ((iItm>27)and(iDay<15)) Begin
32451>>>                        Move (DateCompose(1,iMonth,iYear)) To next_date#
32452>>>                        move (DateIncrement(next_date#,DS_Month,1)) To next_date#
32453>>>                        move (DateSegment(next_date#,DS_MONTH)) to iMonth
32454>>>                        move (DateSegment(next_date#,DS_YEAR)) to iYear
32455>>>                        move (DateCompose(iDay,iMonth,iYear)) to date#
32456>>>                    End
32456>>>>
32456>>>                    If ((iItm<7)and(iDay>20)) Begin
32458>>>                        Move (DateCompose(1,iMonth,iYear)) To prev_date#
32459>>>                        move (DateIncrement(prev_date#,DS_Month,-1)) To prev_date#
32460>>>                        move (DateSegment(prev_date#,DS_MONTH)) to iMonth
32461>>>                        move (DateSegment(prev_date#,DS_YEAR)) to iYear
32462>>>                        move (DateCompose(iDay,iMonth,iYear)) to date#
32463>>>                    End
32463>>>>
32463>>>            
32463>>>                    Send Export_Date date#
32464>>>                End
32464>>>>
32464>>>            End_Procedure
32465>>>            
32465>>>            Procedure Export_Date date date#
32467>>>                local integer focus# dm# margin# datatype#
32468>>>                get invoking_object_id to focus#
32469>>>            
32469>>>                if focus# gt desktop begin
32471>>>                     get delegation_mode of focus# to dm#
32472>>>                     set delegation_mode of focus# to no_delegate_or_error
32473>>>                     get form_margin of focus# item current to margin#
32474>>>                     get form_datatype of focus# item current to datatype#
32475>>>                     set delegation_mode of focus# to dm#
32476>>>                     if (margin#>=10 or datatype#=mask_date_window or datatype#=date_window) set value of focus# item current to date#
32479>>>                     else             set value of focus# item current to (Date4to2(date#))
32481>>>                     set item_changed_state of focus# item current to true
32482>>>                end
32482>>>>
32482>>>                Send Close_Calendar
32483>>>            End_Procedure
32484>>>            //AB-StoreEnd
32484>>>
32484>>>        End_Object    // Grid2
32485>>>
32485>>>        Object Textbox2 is a Textbox
32487>>>            Set Label to "­"
32488>>>            Set Auto_Size_State to FALSE
32489>>>            Set Transparent_State to TRUE
32490>>>            Set Color to clWhite
32491>>>            Set TextColor to clNavy
32492>>>            Set Location to 19 4
32493>>>            Set Size to 10 15
32494>>>
32494>>>            //AB-StoreStart
32494>>>                                        
32494>>>            Set Label To (left(t.calendar.Monday,2))
32495>>>            //AB-StoreEnd
32495>>>
32495>>>        End_Object    // Textbox2
32496>>>
32496>>>        Object Textbox3 is a Textbox
32498>>>            Set Label to "‚â"
32499>>>            Set Auto_Size_State to FALSE
32500>>>            Set Transparent_State to TRUE
32501>>>            Set Color to clWhite
32502>>>            Set TextColor to clNavy
32503>>>            Set Location to 19 22
32504>>>            Set Size to 10 12
32505>>>
32505>>>            //AB-StoreStart
32505>>>                                        
32505>>>            Set Label To (left(t.calendar.Tuesday,2))
32506>>>            //AB-StoreEnd
32506>>>
32506>>>        End_Object    // Textbox3
32507>>>
32507>>>        Object Textbox4 is a Textbox
32509>>>            Set Label to "‘à"
32510>>>            Set Auto_Size_State to FALSE
32511>>>            Set Transparent_State to TRUE
32512>>>            Set Color to clWhite
32513>>>            Set TextColor to clNavy
32514>>>            Set Location to 19 39
32515>>>            Set Size to 10 15
32516>>>
32516>>>            //AB-StoreStart
32516>>>                                        
32516>>>            Set Label To (left(t.calendar.Wednesday,2))
32517>>>            //AB-StoreEnd
32517>>>
32517>>>        End_Object    // Textbox4
32518>>>
32518>>>        Object Textbox5 is a Textbox
32520>>>            Set Label to "—â"
32521>>>            Set Auto_Size_State to FALSE
32522>>>            Set Transparent_State to TRUE
32523>>>            Set Color to clWhite
32524>>>            Set TextColor to clNavy
32525>>>            Set Location to 19 57
32526>>>            Set Size to 10 17
32527>>>
32527>>>            //AB-StoreStart
32527>>>                                        
32527>>>            Set Label To (left(t.calendar.Thursday,2))
32528>>>            //AB-StoreEnd
32528>>>
32528>>>        End_Object    // Textbox5
32529>>>
32529>>>        Object Textbox6 is a Textbox
32531>>>            Set Label to "â"
32532>>>            Set Auto_Size_State to FALSE
32533>>>            Set Transparent_State to TRUE
32534>>>            Set Color to clWhite
32535>>>            Set TextColor to clNavy
32536>>>            Set Location to 19 76
32537>>>            Set Size to 10 17
32538>>>
32538>>>            //AB-StoreStart
32538>>>                                        
32538>>>            Set Label To (left(t.calendar.Friday,2))
32539>>>            //AB-StoreEnd
32539>>>
32539>>>        End_Object    // Textbox6
32540>>>
32540>>>        Object Textbox7 is a Textbox
32542>>>            Set Label to "‘¡"
32543>>>            Set Auto_Size_State to FALSE
32544>>>            Set Transparent_State to TRUE
32545>>>            Set Color to clWhite
32546>>>            Set TextColor to clNavy
32547>>>            Set Location to 19 91
32548>>>            Set Size to 10 18
32549>>>
32549>>>            //AB-StoreStart
32549>>>                                        
32549>>>            Set Label To (left(t.calendar.Saturday,2))
32550>>>            //AB-StoreEnd
32550>>>
32550>>>        End_Object    // Textbox7
32551>>>
32551>>>        Object Textbox8 is a Textbox
32553>>>            Set Label to "‚á"
32554>>>            Set Auto_Size_State to FALSE
32555>>>            Set Transparent_State to TRUE
32556>>>            Set Color to clWhite
32557>>>            Set TextColor to clNavy
32558>>>            Set Location to 19 109
32559>>>            Set Size to 10 17
32560>>>
32560>>>            //AB-StoreStart
32560>>>                                        
32560>>>            Set Label To (left(t.calendar.Sunday,2))
32561>>>            //AB-StoreEnd
32561>>>
32561>>>        End_Object    // Textbox8
32562>>>
32562>>>        Object LineControl1 is a LineControl
32564>>>            Set Line_Style to lnSINGLE
32565>>>            Set Size to 1 116
32566>>>            Set Location to 28 4
32567>>>
32567>>>            //AB-StoreStart
32567>>>                                        
32567>>>            //AB-StoreEnd
32567>>>
32567>>>        End_Object    // LineControl1
32568>>>
32568>>>        Object Container3d2 is a Container3d
32570>>>            Set Size to 18 131
32571>>>            Set Location to 1 1
32572>>>            Set Color to clNavy
32573>>>            Set Border_Style to Border_None
32574>>>            Object oRght is a BitmapContainer
32576>>>                Set Size to 10 14
32577>>>                Set Location to 4 105
32578>>>                Set Bitmap to "rght.bmp"
32579>>>                Set Border_Style to Border_None
32580>>>
32580>>>                //AB-StoreStart
32580>>>                Procedure Mouse_Down
32582>>>                    Send Next_Month to Grid2
32583>>>                End_Procedure
32584>>>                //AB-StoreEnd
32584>>>
32584>>>            End_Object    // oRght
32585>>>
32585>>>            Object oLeft is a BitmapContainer
32587>>>                Set Size to 10 14
32588>>>                Set Location to 4 3
32589>>>                Set Bitmap to "lft.bmp"
32590>>>                Set Border_Style to Border_None
32591>>>
32591>>>                //AB-StoreStart
32591>>>                Procedure Mouse_Down
32593>>>                    Send Prev_Month to Grid2
32594>>>                End_Procedure
32595>>>                //AB-StoreEnd
32595>>>
32595>>>            End_Object    // oLeft
32596>>>
32596>>>            Object oMonth is a Textbox
32598>>>
32598>>>                //AB-StoreTopStart
32598>>>                Property integer piSelected_Month public 0
32600>>>                //AB-StoreTopEnd
32600>>>
32600>>>                Set Label to "January"
32601>>>                Set Auto_Size_State to FALSE
32602>>>                Set Transparent_State to TRUE
32603>>>                Set Color to clWhite
32604>>>                Set TextColor to clWhite
32605>>>                Set Location to 4 23
32606>>>                Set Size to 10 43
32607>>>                Set FontWeight to 800
32608>>>                Set Justification_Mode to jMode_Center
32609>>>
32609>>>                //AB-StoreStart
32609>>>                                    
32609>>>                Procedure Mouse_Down
32611>>>                    Integer iState
32612>>>                    Get Visible_State of oSelectYear to iState
32613>>>                    If (iState) Send OnKillFocus to oSelectYear
32616>>>                    Send Popup to oSelectMonth
32617>>>                End_Procedure
32618>>>                
32618>>>                Procedure pSelectJan
32620>>>                    Set Label to t.calendar.january
32621>>>                    Set piSelected_Month to 1
32622>>>                    Send Adjust_Calendar
32623>>>                End_Procedure
32624>>>                Procedure pSelectFeb
32626>>>                    Set Label to t.calendar.february
32627>>>                    Set piSelected_Month to 2
32628>>>                    Send Adjust_Calendar
32629>>>                End_Procedure
32630>>>                Procedure pSelectMar
32632>>>                    Set Label to t.calendar.march
32633>>>                    Set piSelected_Month to 3
32634>>>                    Send Adjust_Calendar
32635>>>                End_Procedure
32636>>>                Procedure pSelectApr
32638>>>                    Set Label to t.calendar.april
32639>>>                    Set piSelected_Month to 4
32640>>>                    Send Adjust_Calendar
32641>>>                End_Procedure
32642>>>                Procedure pSelectMay
32644>>>                    Set Label to t.calendar.may
32645>>>                    Set piSelected_Month to 5
32646>>>                    Send Adjust_Calendar
32647>>>                End_Procedure
32648>>>                Procedure pSelectJun
32650>>>                    Set Label to t.calendar.june
32651>>>                    Set piSelected_Month to 6
32652>>>                    Send Adjust_Calendar
32653>>>                End_Procedure
32654>>>                Procedure pSelectJul
32656>>>                    Set Label to t.calendar.july
32657>>>                    Set piSelected_Month to 7
32658>>>                    Send Adjust_Calendar
32659>>>                End_Procedure
32660>>>                Procedure pSelectAug
32662>>>                    Set Label to t.calendar.august
32663>>>                    Set piSelected_Month to 8
32664>>>                    Send Adjust_Calendar
32665>>>                End_Procedure
32666>>>                Procedure pSelectSep
32668>>>                    Set Label to t.calendar.september
32669>>>                    Set piSelected_Month to 9
32670>>>                    Send Adjust_Calendar
32671>>>                End_Procedure
32672>>>                Procedure pSelectOct
32674>>>                    Set Label to t.calendar.october
32675>>>                    Set piSelected_Month to 10
32676>>>                    Send Adjust_Calendar
32677>>>                End_Procedure
32678>>>                Procedure pSelectNov
32680>>>                    Set Label to t.calendar.november
32681>>>                    Set piSelected_Month to 11
32682>>>                    Send Adjust_Calendar
32683>>>                End_Procedure
32684>>>                Procedure pSelectDec
32686>>>                    Set Label to t.calendar.december
32687>>>                    Set piSelected_Month to 12
32688>>>                    Send Adjust_Calendar
32689>>>                End_Procedure
32690>>>                
32690>>>                Object oSelectMonth is a FloatingPopupMenu
32692>>>                    Send Add_Item msg_pSelectJan t.calendar.january
32693>>>                    Send Add_Item msg_pSelectFeb t.calendar.february
32694>>>                    Send Add_Item msg_pSelectMar t.calendar.march
32695>>>                    Send Add_Item msg_pSelectApr t.calendar.april
32696>>>                    Send Add_Item msg_pSelectMay t.calendar.may
32697>>>                    Send Add_Item msg_pSelectJun t.calendar.june
32698>>>                    Send Add_Item msg_pSelectJul t.calendar.july
32699>>>                    Send Add_Item msg_pSelectAug t.calendar.august
32700>>>                    Send Add_Item msg_pSelectSep t.calendar.september
32701>>>                    Send Add_Item msg_pSelectOct t.calendar.october
32702>>>                    Send Add_Item msg_pSelectNov t.calendar.november
32703>>>                    Send Add_Item msg_pSelectDec t.calendar.december
32704>>>                End_Object
32705>>>                
32705>>>                Procedure Adjust_Calendar
32707>>>                    Date date#
32708>>>                    Integer iDay iMonth iYear iItm
32708>>>                    Set Visible_State to false
32709>>>                    Set Visible_State to true
32710>>>                    Get Current_Item of (Grid2(Container3D1(Self))) to iItm
32711>>>                    Get value of (Grid2(Container3D1(Self))) item iItm to iDay
32712>>>                    Get piSelected_Month to iMonth
32713>>>                    Get Label of oYear to iYear
32714>>>                    Move (DateCompose(iDay,iMonth,iYear)) To date#
32715>>>                    Set p_current_date of (Grid2(Container3D1(Self))) to date#
32716>>>                    Send Update_Calendar to (Grid2(Container3D1(Self)))
32717>>>                End_Procedure
32718>>>                
32718>>>                Procedure Activating
32720>>>                    Forward Send Activating
32722>>>                    Send Date_Changing
32723>>>                End_Procedure
32724>>>                
32724>>>                Procedure Date_Changing
32726>>>                    Set Visible_State to false
32727>>>                    Set Label to (MonthName(p_current_Month(Grid2(Container3D1(Self)))))
32728>>>                    Set piSelected_Month to (p_current_Month(Grid2(Container3D1(Self))))
32729>>>                    Set Visible_State to true
32730>>>                End_Procedure
32731>>>                
32731>>>                
32731>>>                //AB-StoreEnd
32731>>>
32731>>>            End_Object    // oMonth
32732>>>
32732>>>            Object oYear is a Textbox
32734>>>                Set Label to "2001"
32735>>>                Set Transparent_State to TRUE
32736>>>                Set Color to clWhite
32737>>>                Set TextColor to clWhite
32738>>>                Set Location to 4 77
32739>>>                Set Size to 10 18
32740>>>                Set FontWeight to 800
32741>>>
32741>>>                //AB-StoreStart
32741>>>                                                    
32741>>>                Procedure Mouse_Down
32743>>>                    String sVal
32744>>>                    Get Label to sVal
32745>>>                    Set Value of oSelectYear item 0 to sVal
32746>>>                    Set Visible_State of oSelectYear to True
32747>>>                    Send Activate to (oSelectYear(Self))
32748>>>                End_Procedure
32749>>>                
32749>>>                Procedure Activating
32751>>>                    Forward Send Activating
32753>>>                    Send Date_Changing
32754>>>                End_Procedure
32755>>>                
32755>>>                Procedure Date_Changing
32757>>>                    Set Visible_State to false
32758>>>                    Set Label to (String(p_current_Year(Grid2(Container3D1(Self)))))
32759>>>                    Set Visible_State to true
32760>>>                End_Procedure
32761>>>                //AB-StoreEnd
32761>>>
32761>>>            End_Object    // oYear
32762>>>
32762>>>            Object oSelectYear is a Form
32764>>>
32764>>>                //AB-StoreTopStart
32764>>>                Set Visible_State To False
32765>>>                //AB-StoreTopEnd
32765>>>
32765>>>                Set Size to 10 24
32766>>>                Set Location to 4 75
32767>>>                Set Color to clWhite
32768>>>                Set TextColor to clNavy
32769>>>                Set Form_Border Item 0 to Border_Normal
32770>>>
32770>>>                //AB-StoreStart
32770>>>                                                    
32770>>>                On_Key Key_Enter Send OnKillFocus
32771>>>                On_Key Key_Escape Send OnKillFocus
32772>>>                
32772>>>                Procedure SetFontWeight
32774>>>                    Set Form_FontWeight item 0 to 800
32775>>>                End_Procedure
32776>>>                
32776>>>                Procedure OnKillFocus
32778>>>                    String sVal
32779>>>                    Integer iMonth iDay iYear iItm
32779>>>                    Date date#
32779>>>                    Get Value item 0 to sVal
32780>>>                    Set Visible_State of oYear to false
32781>>>                    Set Label of oYear to sVal
32782>>>                    Set Visible_State of oYear to true
32783>>>                    Set Visible_State to false
32784>>>                    Get Current_Item of (Grid2(Container3D1(Self))) to iItm
32785>>>                    Get value of (Grid2(Container3D1(Self))) item iItm to iDay
32786>>>                    Get piSelected_Month of oMonth to iMonth
32787>>>                    Get Value item 0 to iYear
32788>>>                    Move (DateCompose(iDay,iMonth,iYear)) To date#
32789>>>                    Set p_current_date of (Grid2(Container3D1(Self))) to date#
32790>>>                    Send Update_Calendar to (Grid2(Container3D1(Self)))
32791>>>                End_Procedure
32792>>>                
32792>>>                Send SetFontWeight
32793>>>                //AB-StoreEnd
32793>>>
32793>>>            End_Object    // oSelectYear
32794>>>
32794>>>
32794>>>            //AB-StoreStart
32794>>>                            
32794>>>            Procedure Mouse_Down
32796>>>                Integer iState
32797>>>                Get Visible_State of oSelectYear to iState
32798>>>                If (iState) Send OnKillFocus to oSelectYear
32801>>>            End_Procedure
32802>>>            
32802>>>            //AB-StoreEnd
32802>>>
32802>>>        End_Object    // Container3d2
32803>>>
32803>>>
32803>>>        //AB-StoreStart
32803>>>                            
32803>>>        //AB-StoreEnd
32803>>>
32803>>>    End_Object    // Container3d1
32804>>>
32804>>>    Object BitmapContainer3 is a BitmapContainer
32806>>>        Set Size to 9 19
32807>>>        Set Location to 88 3
32808>>>        Set Color to clWhite
32809>>>        Set Bitmap to "cdate.bmp"
32810>>>        Set Border_Style to Border_None
32811>>>
32811>>>        //AB-StoreStart
32811>>>        Procedure Mouse_Down
32813>>>            Send go_today to (Grid2(Container3d1(Self)))
32814>>>            Send Adjust_Label to oToday
32815>>>        End_Procedure
32816>>>        //AB-StoreEnd
32816>>>
32816>>>    End_Object    // BitmapContainer3
32817>>>
32817>>>    Object oToday is a Textbox
32819>>>        Set Label to "Today: 01.01.2001"
32820>>>        Set Auto_Size_State to FALSE
32821>>>        Set Color to clWhite
32822>>>        Set Location to 88 22
32823>>>        Set Size to 8 73
32824>>>        Set FontWeight to 800
32825>>>
32825>>>        //AB-StoreStart
32825>>>        Procedure Mouse_Down
32827>>>            Send go_today to (Grid2(Container3d1(Self)))
32828>>>            Send Adjust_Label
32829>>>        End_Procedure
32830>>>        
32830>>>        Procedure Adjust_Label
32832>>>            date date#
32833>>>            SysDate4 date#
32834>>>            Set Visible_State To false
32835>>>            Set Label         to (t.calendar.today+": "+String(date#))
32836>>>            Set Visible_State To true
32837>>>        End_Procedure
32838>>>        
32838>>>        Procedure Activating
32840>>>            Forward Send Activating
32842>>>            Send Adjust_Label
32843>>>        End_Procedure
32844>>>        //AB-StoreEnd
32844>>>
32844>>>    End_Object    // oToday
32845>>>
32845>>>
32845>>>    //AB-StoreStart
32845>>>                
32845>>>    procedure popup
32847>>>        local integer focus# icItm iYear iMonth
32848>>>        local date date#
32848>>>        move (focus(desktop)) to focus#
32849>>>        set invoking_object_id of (Grid2(Container3d1(self))) to focus#
32850>>>        get value of focus# item current to date#
32851>>>        ifnot (integer(date#)) sysdate date#
32854>>>        move (Date2to4(date#)) to date#
32855>>>        set p_current_date of (Grid2(Container3d1(self))) to date#
32856>>>        send fill_list to (Grid2(Container3d1(self)))
32857>>>        move (DateSegment(date#,DS_YEAR)) to iYear
32858>>>        move (DateSegment(date#,DS_MONTH)) to iMonth
32859>>>        Set Label To (MonthName(iMonth)+', '+String(iYear))
32860>>>        forward send popup
32862>>>    end_procedure
32863>>>    
32863>>>    Procedure Close_Calendar
32865>>>        Send Exit
32866>>>    End_Procedure
32867>>>    //AB-StoreEnd
32867>>>
32867>>>CD_End_Object    // oCalendar
32869>>>>
32869>>>
32869>>>
32869>>>//AB-StoreStart
32869>>>    
32869>>>    
32869>>>//AB-StoreEnd
32869>>>
32869>>>//AB/ End_Object    // prj
32869>Use Dates.Utl
32869>use roundfn.fnc
INCLUDING FILE: ROUNDFN.FNC
32869>>>// ===========================================================================
32869>>>//
32869>>>// The ROUND_NUMBER global function has been designed to return the rounded
32869>>>// value of a given 'numeric' argument at a specified rounding precision.
32869>>>//
32869>>>// ---------------------------------------------------------------------------
32869>>>// This version dispenses with the use of powers (10 ^ n) to perform the
32869>>>// necessary calculations.  It uses a string handling technique instead.
32869>>>// ---------------------------------------------------------------------------
32869>>>//
32869>>>// The function requires two arguments, as follows:-
32869>>>//
32869>>>// (a) The numeric value to be rounded, where the range of valid values is
32869>>>//     +/- 99,999,999,999,999.99999999.
32869>>>//
32869>>>// (b) The rounding precision required.  This must be an integer value in the
32869>>>//     range -13 to +8.  If a value outside this range is used, the nearest
32869>>>//     threshold value is substituted.
32869>>>//
32869>>>//     Values in the range +1 to +7 perform rounding on the decimal part of
32869>>>//     the number.  A value of +8 will perform no rounding at all.  A zero
32869>>>//     value will round to the nearest whole number.  Values -1 to -13 will
32869>>>//     round progressively to the left of the decimal point (a frequent
32869>>>//     requirement in financial reporting).
32869>>>//
32869>>>// If the result of the rounding produces a value outside the valid numeric
32869>>>// range (+/- 99,999,999,999,999.99999999) then a zero value is returned.
32869>>>//
32869>>>// Assumptions:-  The only assumptions made have been that the range of
32869>>>// numeric values and the limit of eight decimal places are unlikely to change
32869>>>// in the forseeable future.
32869>>>//
32869>>>// Examples:-
32869>>>//
32869>>>//  1st Argument      2nd Argument   Return Value
32869>>>//  ------------      ------------   ------------
32869>>>//  123456.87654321         8         123456.87654321
32869>>>//  123456.87654321         2         123456.88
32869>>>// -123456.87654321         2        -123456.88
32869>>>//  123456.98765432         0         123457
32869>>>// -123456.98765432        -1        -123460
32869>>>//  123456.98765432        -2         123500
32869>>>//  123456.98765432        -3         123000
32869>>>//  987654                 -4         990000
32869>>>//  987654                 -5        1000000
32869>>>//  987654                 -6        1000000
32869>>>//  987654                 -7              0
32869>>>//
32869>>>// ===========================================================================
32869>>>
32869>>>
32869>>>Function Round_Number GLOBAL number nVal integer iRnd returns Number
32870>>>
32870>>>  Local Number nAdj
32871>>>
32871>>>  Move 10000000000000 to nAdj
32872>>>
32872>>>  // If the rounding precision falls in the range 0 to 8, then return:-
32872>>>
32872>>>  If (iRnd >= 0) Function_Return ;    (Number(Abs(nVal) / nVal) * 0.5 / (Number(Left(nAdj, ((iRnd + 1) ;      min 9)))) + nVal / (Number(Left(nAdj, (9 - (iRnd min 8))))) ;        * (Number(Left(nAdj, (9 - (iRnd min 8))))))
32875>>>
32875>>>  // Else, where the rounding precision is in the range -1 to -5, return:-
32875>>>
32875>>>  If (iRnd >= -5) Function_Return ;    (Number(Abs(nVal) / nVal) * 0.5 * (Number(Left(nAdj, (Abs(iRnd) + 1)))) ;      + nVal / (Number(Left(nAdj, (Abs(iRnd) + 9)))) ;        * (Number(Left(nAdj, (Abs(iRnd) + 9)))))
32878>>>
32878>>>  // Else, where the rounding precision is in the range -6 to -13, return:-
32878>>>
32878>>>  Function_Return ;    (Number(Abs(nVal) / nVal) * 0.5 * (Number(Left(nAdj, (Abs(iRnd) + 1)))) ;      + nVal / (Number(nAdj)) / (Number(Left(nAdj, ((Abs(iRnd) - 4) min 9)))) ;        * (Number(nAdj)) * (Number(Left(nAdj, ((Abs(iRnd) - 4) min 9)))))
32879>>>
32879>>>End_Function
32880>Use Wait.Dg
32880>//use checkafm.pkg
32880>//use checklog.pkg
32880>Use Menu_Sec.Sub
INCLUDING FILE: MENU_SEC.SUB
32880>>>
32880>>>Use Idiotht.pkg
INCLUDING FILE: IDIOTHT.PKG
32880>>>>>
32880>>>>>Open Users
INCLUDING FILE: USERS.FD
32882>>>>>Open UserGrps
INCLUDING FILE: USERGRPS.FD
32884>>>>>Open Pedia
INCLUDING FILE: PEDIA.FD
32886>>>>>Open Arxeia
INCLUDING FILE: ARXEIA.FD
32888>>>>>Open GrpPedia
INCLUDING FILE: GRPPEDIA.FD
32890>>>>>Open GrpPed0
INCLUDING FILE: GRPPED0.FD
32892>>>>>Open GrpArx
INCLUDING FILE: GRPARX.FD
32894>>>>>Open GrpArx0
INCLUDING FILE: GRPARX0.FD
32896>>>>>Open ViewFlds
INCLUDING FILE: VIEWFLDS.FD
32898>>>>>Open Oth
INCLUDING FILE: OTH.FD
32900>>>>>Open GrpOth
INCLUDING FILE: GRPOTH.FD
32902>>>>>Open GrpOth0
INCLUDING FILE: GRPOTH0.FD
32904>>>>>Open Departm
INCLUDING FILE: DEPARTM.FD
32906>>>>>
32906>>>>>
32906>>>>>External_Function32 WNetGetUser "WNetGetUserA" MPR.DLL ;    Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
32907>>>>>
32907>>>>>Function Network_User_Name Returns String
32908>>>>>    Local String sName sLength
32909>>>>>    Local Pointer lpName_Addr lpLength_Addr
32909>>>>>    Local Integer iRetval
32909>>>>>    Movestr (Repeat (Character (0), 255)) To sName
32910>>>>>>
32910>>>>>    GetAddress Of sName To lpName_Addr
32911>>>>>    Movestr (DwordToBytes (255)) To sLength
32912>>>>>>
32912>>>>>    GetAddress Of sLength To lpLength_Addr
32913>>>>>    Moveint (WNetGetUser (0, lpName_Addr, lpLength_Addr)) To iRetval
32914>>>>>>
32914>>>>>    If iRetval Eq 0 Function_Return (CString (sName))
32917>>>>>    Else Function_Return "User Unknown"
32919>>>>>End_Function // Network_User_Name
32920>>>>>
32920>>>>>Function fsGetOfficePath Global Returns String
32921>>>>>    String sRegistryKeyPath sRegOfficePath
32922>>>>>    Set_Registry_Root                                                   to HKEY_LOCAL_MACHINE "Software"
32923>>>>>    Move "Microsoft\Office\9.0\Word"                                    to sRegistryKeyPath
32924>>>>>    Get_Foreign_Profile_String sRegistryKeyPath "InstallRoot" "Path"    to sRegOfficePath
32928>>>>>    Move (Trim(sRegOfficePath))                                         to sRegOfficePath
32929>>>>>    If (sRegOfficePath='') Begin
32931>>>>>        Move "Microsoft\Office\8.0\Word"                                to sRegistryKeyPath
32932>>>>>        Get_Foreign_Profile_String sRegistryKeyPath "InstallRoot" "Path" to sRegOfficePath
32936>>>>>        Move (Trim(sRegOfficePath))                                     to sRegOfficePath
32937>>>>>        If (sRegOfficePath='') Begin
32939>>>>>            Move "Microsoft\Office\7.0\Word"                             to sRegistryKeyPath
32940>>>>>            Get_Foreign_Profile_String sRegistryKeyPath "InstallRoot" "Path" to sRegOfficePath
32944>>>>>            Move (Trim(sRegOfficePath))                                     to sRegOfficePath
32945>>>>>            If (sRegOfficePath='') Begin
32947>>>>>                Move "Microsoft\Office\10.0\Word"                                to sRegistryKeyPath
32948>>>>>                Get_Foreign_Profile_String sRegistryKeyPath "InstallRoot" "Path" to sRegOfficePath
32952>>>>>                Move (Trim(sRegOfficePath))                                     to sRegOfficePath
32953>>>>>            End
32953>>>>>>
32953>>>>>        End
32953>>>>>>
32953>>>>>    End
32953>>>>>>
32953>>>>>    Function_Return sRegOfficePath
32954>>>>>End_Procedure
32955>>>>>
32955>>>>>
32955>>>>>Function fsGetLastDir Global Returns String
32956>>>>>    String sRegistryKeyPath sRegDir sUserName
32957>>>>>    Get Network_User_Name to sUserName
32958>>>>>
32958>>>>>    Get_Profile_String "WorkSpaces" "CurrentWorkspace" to sRegistryKeyPath
32961>>>>>    If sRegistryKeyPath eq "" Get WorkspaceName of (ProgramWorkspace(Self)) to sRegistryKeyPath
32964>>>>>    insert "WorkSpaces\" in sRegistryKeyPath at 1
32966>>>>>    Append sRegistryKeyPath  "\" (Module_Name(Self))
32968>>>>>    Append sRegistryKeyPath  "\LastDirUsed\"
32969>>>>>    Append sRegistryKeyPath  (Trim(sUserName))
32970>>>>>    Get_profile_string sRegistryKeyPath "Path" to sRegDir
32973>>>>>    Function_Return sRegDir
32974>>>>>End_Procedure
32975>>>>>
32975>>>>>Function fiPutLastDir Global String asDirectory Returns Integer
32976>>>>>    String sRegistryKeyPath sRegDir sUserName
32977>>>>>    Get Network_User_Name to sUserName
32978>>>>>    Get_Profile_String "WorkSpaces" "CurrentWorkspace" to sRegistryKeyPath
32981>>>>>    If sRegistryKeyPath eq "" Get WorkspaceName of (ProgramWorkspace(Self)) to sRegistryKeyPath
32984>>>>>    insert "WorkSpaces\" in sRegistryKeyPath at 1
32986>>>>>    Append sRegistryKeyPath  "\" (Module_Name(Self))
32988>>>>>    Append sRegistryKeyPath  "\LastDirUsed\"
32989>>>>>    Append sRegistryKeyPath  (Trim(sUserName))
32990>>>>>    Set_profile_string sRegistryKeyPath "Path" to asDirectory
32993>>>>>    Function_Return 0
32994>>>>>End_Procedure
32995>>>>>
32995>>>>>
32995>>>>>Function fsVresExt Global String asFileName Returns String
32996>>>>>    String rVal
32997>>>>>    Integer iPos iLen
32997>>>>>    Move (UpperCase(asFileName)) to asFileName
32998>>>>>    Move (Trim(asFileName)) to asFileName
32999>>>>>    Move 0 to iPos
33000>>>>>    For iLen from 1 to (length(asFileName))
33006>>>>>>
33006>>>>>        If (Mid(asFileName,1,iLen)='.') Move iLen to iPos
33009>>>>>    Loop
33010>>>>>>
33010>>>>>    If (Not(iPos)) Function_Return ''
33013>>>>>    Move (Right(asFileName,(Length(asFileName)-iPos))) to rVal
33014>>>>>    Move (Trim(rVal)) to rVal
33015>>>>>    Function_Return rVal
33016>>>>>End_Function
33017>>>>>
33017>>>>>
33017>>>>>Function fiScreenFieldStatus Global String asViewName String asDbFormName Returns Integer
33018>>>>>    Integer rVal iUser iGroup
33019>>>>>    String  sUser sRecr
33019>>>>>    Move (Trim(asViewName))     to asViewName
33020>>>>>    Move (Trim(asDbFormName))   to asDbFormName
33021>>>>>
33021>>>>>    If ((asViewName<>'') And (asDbFormName<>'')) Begin
33023>>>>>        Get fsLoginUserID to sUser
33024>>>>>        Clear Users
33025>>>>>        Move sUser        to Users.Login_ID
33026>>>>>        Find eq Users by Index.1 // Users:Index.1:Users.Login_ID
33027>>>>>>
33027>>>>>        If (Found=1) Begin
33029>>>>>            Move Users.User_ID  to iUser
33030>>>>>            Move Users.Grp_ID   to iGroup
33031>>>>>            Clear GrpOth
33032>>>>>            Move iUser          to GrpOth.User_ID
33033>>>>>            Move asViewName     to GrpOth.View_Name
33034>>>>>            Move asDbFormName   to GrpOth.Scr_Field_Name
33035>>>>>            Find eq GrpOth by Index.2 // GrpOth:Index.2:User_ID+View_Name+Scr_Field_Name
33036>>>>>>
33036>>>>>            If (Found=1) Begin
33038>>>>>                // rVal=1 ==> NO READ ALLOWED
33038>>>>>                // rVal=2 ==> NO EDIT BUT CAN COPY
33038>>>>>                // rVal=3 ==> NO EDIT AND NO COPY
33038>>>>>                If (GrpOth.Allow_Read <>'1') Move 1 to rVal
33041>>>>>                Else Begin
33042>>>>>                    If (GrpOth.Allow_Change<>'1') Begin
33044>>>>>                        If (GrpOth.Allow_Copy<>'1') Move 3 to rVal
33047>>>>>                        Else                        Move 2 to rVal
33049>>>>>                    End
33049>>>>>>
33049>>>>>                End
33049>>>>>>
33049>>>>>            End
33049>>>>>>
33049>>>>>            Else Begin
33050>>>>>                Clear GrpOth0
33051>>>>>                Move iGroup         to GrpOth0.Group_ID
33052>>>>>                Move asViewName     to GrpOth0.View_Name
33053>>>>>                Move asDbFormName   to GrpOth0.Scr_Field_Name
33054>>>>>
33054>>>>>                Find eq GrpOth0 by Index.2 // GrpOth0:Index.2:Group_ID+View_Name+Scr_Field_Name
33055>>>>>>
33055>>>>>                If (Found=1) Begin
33057>>>>>                    // rVal=1 ==> NO READ ALLOWED
33057>>>>>                    // rVal=2 ==> NO EDIT BUT CAN COPY
33057>>>>>                    // rVal=3 ==> NO EDIT AND NO COPY
33057>>>>>                    If (GrpOth0.Allow_Read <>'1') Move 1 to rVal
33060>>>>>                    Else Begin
33061>>>>>                        If (GrpOth0.Allow_Change<>'1') Begin
33063>>>>>                            If (GrpOth0.Allow_Copy<>'1') Move 3 to rVal
33066>>>>>                            Else                         Move 2 to rVal
33068>>>>>                        End
33068>>>>>>
33068>>>>>                    End
33068>>>>>>
33068>>>>>                End
33068>>>>>>
33068>>>>>                Else Move 0 to rVal
33070>>>>>            End
33070>>>>>>
33070>>>>>        End
33070>>>>>>
33070>>>>>        Else Move 0 to rVal
33072>>>>>    End
33072>>>>>>
33072>>>>>    Function_Return rVal
33073>>>>>End_Function
33074>>>>>
33074>>>>>Function fiFieldStatus Global Integer aiFileNumber Integer aiFieldNumber Returns Integer
33075>>>>>    Integer rVal iUser iGroup
33076>>>>>    String  sUser sRecr
33076>>>>>    If ((aiFileNumber) And (aiFieldNumber)) Begin
33078>>>>>        Get fsLoginUserID to sUser
33079>>>>>        Clear Users
33080>>>>>        Move sUser        to Users.Login_ID
33081>>>>>        Find eq Users by Index.1 // Users:Index.1:Users.Login_ID
33082>>>>>>
33082>>>>>        If (Found=1) Begin
33084>>>>>            Move Users.User_ID  to iUser
33085>>>>>            Move Users.Grp_ID   to iGroup
33086>>>>>            Clear Pedia
33087>>>>>            Move aiFileNumber  to Pedia.Arxeio_ID
33088>>>>>            Move aiFieldNumber to Pedia.Pedio_Number
33089>>>>>            Find eq Pedia By Index.1 // Pedia:Index.1:Arxeio_ID+Pedio_Number
33090>>>>>>
33090>>>>>            If (Found=1) Begin
33092>>>>>                Move (Trim(Pedia.Pedio_Recr))   to sRecr
33093>>>>>                // Find Combination User/File/Field in GRPPEDIA
33093>>>>>                Clear GrpPedia
33094>>>>>                Move iUser                      to GrpPedia.User_ID
33095>>>>>                Move (Trim(sRecr))              to GrpPedia.Pedio_Recr
33096>>>>>                Find eq GrpPedia by Index.4 // GrpPedia:Index.4:Pedio_Recr + User_ID
33097>>>>>>
33097>>>>>                If (Found=1) Begin
33099>>>>>                    // rVal=1 ==> NO READ ALLOWED
33099>>>>>                    // rVal=2 ==> NO EDIT BUT CAN COPY
33099>>>>>                    // rVal=3 ==> NO EDIT AND NO COPY
33099>>>>>                    If (GrpPedia.Allow_Read <>'1') Move 1 to rVal
33102>>>>>                    Else Begin
33103>>>>>                        If (GrpPedia.Allow_Change<>'1') Begin
33105>>>>>                            If (GrpPedia.Allow_Copy<>'1')   Move 3 to rVal
33108>>>>>                            Else                            Move 2 to rVal
33110>>>>>                        End
33110>>>>>>
33110>>>>>                    End
33110>>>>>>
33110>>>>>                End
33110>>>>>>
33110>>>>>                Else Begin
33111>>>>>                    // Find Combination UserGrps/File/Field in GRPPED0
33111>>>>>                    Clear GrpPed0
33112>>>>>                    Move iGroup         to GrpPed0.Group_ID
33113>>>>>                    Move (Trim(sRecr))  to GrpPed0.Pedio_Recr
33114>>>>>                    Find eq GrpPed0 by Index.4 // GrpPed0:Index.4:Pedio_Recr + Group_ID
33115>>>>>>
33115>>>>>                    If (Found=1) Begin
33117>>>>>                        // rVal=1 ==> NO READ ALLOWED
33117>>>>>                        // rVal=2 ==> NO EDIT BUT CAN COPY
33117>>>>>                        // rVal=3 ==> NO EDIT AND NO COPY
33117>>>>>                        If (GrpPed0.Allow_Read <>'1') Move 1 to rVal
33120>>>>>                        Else Begin
33121>>>>>                            If (GrpPed0.Allow_Change<>'1') Begin
33123>>>>>                                If (GrpPed0.Allow_Copy<>'1')   Move 3 to rVal
33126>>>>>                                Else                           Move 2 to rVal
33128>>>>>                            End
33128>>>>>>
33128>>>>>                        End
33128>>>>>>
33128>>>>>                    End
33128>>>>>>
33128>>>>>                End
33128>>>>>>
33128>>>>>            End
33128>>>>>>
33128>>>>>            Else Begin
33129>>>>>                Move 0 to rVal
33130>>>>>            End
33130>>>>>>
33130>>>>>        End
33130>>>>>>
33130>>>>>        Else Begin
33131>>>>>            Move 0 to rVal
33132>>>>>        End
33132>>>>>>
33132>>>>>    End
33132>>>>>>
33132>>>>>    Function_Return rVal
33133>>>>>End_Function
33134>>>>>
33134>>>>>Function fsReturnFileFromPath Global String asFullPath Returns String
33135>>>>>    String rVal lsDirSep
33136>>>>>    Integer iPos iMet iLen iCnt
33136>>>>>    Move (Trim(asFullPath))                 To rVal
33137>>>>>    Move (Sysconf(SYSCONF_DIR_SEPARATOR))   To lsDirSep
33138>>>>>    If (rVal Contains lsDirSep) Begin
33140>>>>>        Move (Length(rVal)) to iLen
33141>>>>>        Move iLen to iCnt
33142>>>>>        While iCnt Gt 0
33146>>>>>            If (Mid(rVal,1,iCnt)=lsDirSep) Begin
33148>>>>>                If (iCnt=iLen) Function_Return asFullPath
33151>>>>>                Else Function_Return (Right(rVal,(iLen-iCnt)))
33153>>>>>            End
33153>>>>>>
33153>>>>>            Decrement iCnt
33154>>>>>        End // While iCnt Gt 0
33155>>>>>>
33155>>>>>    End
33155>>>>>>
33155>>>>>    Else  Function_Return (Trim(asFullPath))
33157>>>>>    Function_Return rVal
33158>>>>>End_Function
33159>>>>>
33159>>>>>Function fsReturnDirectoriesFromPath Global String asFullPath Returns String
33160>>>>>    String rVal lsDirSep
33161>>>>>    Integer iPos iMet iLen iCnt
33161>>>>>    Move (Trim(asFullPath))                 To rVal
33162>>>>>    Move (Sysconf(SYSCOnF_DIR_SEPARATOR))   To lsDirSep
33163>>>>>    If (rVal Contains lsDirSep) Begin
33165>>>>>        Move (Length(rVal)) to iLen
33166>>>>>        Move iLen to iCnt
33167>>>>>        While iCnt Gt 0
33171>>>>>            If (Mid(rVal,1,iCnt)=lsDirSep) Function_Return (Left(rVal,iCnt))
33174>>>>>            Decrement iCnt
33175>>>>>        End // While iCnt Gt 0
33176>>>>>>
33176>>>>>    End
33176>>>>>>
33176>>>>>    Function_Return rVal
33177>>>>>End_Function
33178>>>>>
33178>>>>>//Function fsConvert_Time_Number_To_String_With_Zeroes Global Number anTime Returns String
33178>>>>>//    Local String rVal lsTmp lsOO lsLL
33178>>>>>//    Local Number lnOO lnLL
33178>>>>>
33178>>>>>//    Move '' to lsOO
33178>>>>>//    Move '' to lsLL
33178>>>>>//    Move '' to rVal
33178>>>>>
33178>>>>>//    Move (Integer(anTime))                              to lnOO
33178>>>>>//    ////////////////////////////////////////////
33178>>>>>//    // sos sos sos jsjsjsjsjs yannis 30/03/2000
33178>>>>>//    //If ((lnOO=24) and (lnll=0)) Move 0 to lnOO
33178>>>>>//    ////////////////////////////////////////////
33178>>>>>
33178>>>>>//    Move ((anTime - (Integer(anTime))) * 100)           to lnLL
33178>>>>>
33178>>>>>//    If (lnOO<10) Move (Append(lsOO,'0'+(String(lnOO)))) to lsOO
33178>>>>>//    Else         Move (String(lnOO))                    to lsOO
33178>>>>>//    Move (Trim(lsOO))                                   to lsOO
33178>>>>>
33178>>>>>//    If (lnLL<10) Move (Append(lsLL,'0'+(String(lnLL)))) to lsLL
33178>>>>>//    Else         Move (String(lnLL))                    to lsLL
33178>>>>>//    Move (Trim(lsLL))                                   to lsLL
33178>>>>>
33178>>>>>//    Move (Append(rVal,(lsOO+':'+lsLL))) to rVal
33178>>>>>
33178>>>>>//    Move (Trim(rVal)) to rVal
33178>>>>>
33178>>>>>//    Function_Return rVal
33178>>>>>//End_Function
33178>>>>>
33178>>>>>//Function fnConvert_Minutes_to_Time Global Integer aiMinutes Returns Number
33178>>>>>//    Local Number rVal nOres nLepta
33178>>>>>//    Move (Integer(aiMinutes/60))    to nOres
33178>>>>>//    Move (    Mod(aiMinutes,60))    to nLepta
33178>>>>>//    Move (nOres+(nLepta/100))       to rVal
33178>>>>>//    Function_Return rVal
33178>>>>>//End_Function
33178>>>>>
33178>>>>>//Function fiConvert_Time_to_Minutes Global Number anTime Returns Integer
33178>>>>>//    Local Integer rVal
33178>>>>>//    Move ((Integer(anTime)*60)+((anTime-(Integer(anTime)))*100)) to rVal
33178>>>>>//    Function_Return rVal
33178>>>>>//End_Function
33178>>>>>
33178>>>>>//Function fiConvert_Difference_StartTime_EndTime_to_Minutes Global   Number anStartTime  ;
33178>>>>>//                                                                    Number anEndTime    ;
33178>>>>>//                                                                    Returns Integer
33178>>>>>//    Local Integer rVal iMinStart iMinEnd
33178>>>>>
33178>>>>>//    If (anStartTime >= anEndTime) Add 24 to anEndTime
33178>>>>>
33178>>>>>//    Move ((Integer(anStartTime)*60)+((anStartTime-(Integer(anStartTime)))*100))  to iMinStart
33178>>>>>//    Move ((Integer(anEndTime  )*60)+((anEndTime  -(Integer(anEndTime  )))*100))  to iMinEnd
33178>>>>>//    Move (iMinEnd-iMinStart)                                                     to rVal
33178>>>>>//    Function_Return rVal
33178>>>>>//End_Function
33178>>>>>
33178>>>>>
33178>>>>>//Function fnConvert_Difference_StartTime_EndTime_to_Time Global  Number anStartTime  ;
33178>>>>>//                                                                Number anEndTime    ;
33178>>>>>//                                                                Returns Number
33178>>>>>//    Local Integer iTmp
33178>>>>>//    Local Number  rVal
33178>>>>>
33178>>>>>//    If (anStartTime >= anEndTime) Add 24 to anEndTime
33178>>>>>
33178>>>>>//    Move (fiConvert_Difference_StartTime_EndTime_to_Minutes(anStartTime,anEndTime)) to iTmp
33178>>>>>//    Move (fnConvert_Minutes_to_Time(iTmp))                                          to rVal
33178>>>>>//    Function_Return rVal
33178>>>>>//End_Function
33178>>>>>
33178>>>>>
33178>>>>>Function fsLoginUserID Global Returns String
33179>>>>>    Local String LastLogin# LoginUserid#
33180>>>>>    get_profile_string "WorkSpaces" "CurrentWorkspace" to LastLogin#
33183>>>>>    If LastLogin# eq "" Get WorkspaceName of (ProgramWorkspace(Self)) to LastLogin#
33186>>>>>    insert "WorkSpaces\" in LastLogin# at 1
33188>>>>>    Append LastLogin# "\" (Module_Name(Self)) "\LastLogin"
33191>>>>>    get_profile_string LastLogin# "LoginUserId"  to LoginUserId#
33194>>>>>    Trim LoginUserID# to LoginUserID#
33195>>>>>>
33195>>>>>    If LoginUserId# eq "" Move (Network_User_Name(Current_Object)) to LoginUserId#
33198>>>>>    Function_Return LoginUserID#
33199>>>>>End_Function
33200>>>>>
33200>>>>>Function fiWriteRegistryLastSDFPath Global String asLastPath Returns Integer
33201>>>>>    Integer rVal
33202>>>>>    String  lsCurrentWksp
33202>>>>>    Get_Profile_String "WorkSpaces" "CurrentWorkspace" to lsCurrentWksp
33205>>>>>    If (lsCurrentWksp="") Get WorkspaceName of (ProgramWorkspace(Self)) to lsCurrentWksp
33208>>>>>    Insert "WorkSpaces\" in lsCurrentWksp at 1
33210>>>>>    // Œœ¦ ¡¢œ ›   - Last_SDF_Path -  ¡˜«à ˜§¦ «¦ ©¬š¡œ¡¨ £œ¤¦
33210>>>>>    // workspace §¦¬ ›¦¬¢œ¬¦¬£œ
33210>>>>>    Append lsCurrentWksp "\" (Module_Name(Self)) "\Last_SDF_Path"
33213>>>>>    Set_Profile_String lsCurrentWksp "Path"  to (Trim(asLastPath))
33216>>>>>    Function_Return rVal
33217>>>>>End_Function
33218>>>>>
33218>>>>>
33218>>>>>Function fsReadRegistryLastSDFPath Global Returns String
33219>>>>>    String rVal lsCurrentWksp
33220>>>>>    Get_Profile_String "WorkSpaces" "CurrentWorkspace" to lsCurrentWksp
33223>>>>>    If (lsCurrentWksp="") Get WorkspaceName of (ProgramWorkspace(Self)) to lsCurrentWksp
33226>>>>>    Insert "WorkSpaces\" in lsCurrentWksp at 1
33228>>>>>    // Œœ¦ ¡¢œ ›   - LastParastUsed -  ¡˜«à ˜§¦ «¦ ©¬š¡œ¡¨ £œ¤¦
33228>>>>>    // workspace §¦¬ ›¦¬¢œ¬¦¬£œ
33228>>>>>    Append lsCurrentWksp "\" (Module_Name(Self)) "\Last_SDF_Path"
33231>>>>>    Get_Profile_String lsCurrentWksp "Path"  to rVal
33234>>>>>    Function_Return (Trim(rVal))
33235>>>>>End_Function
33236>>>>>
33236>>>>>
33236>>>>>Function fiWriteRegistryLastMCryptPath Global String asLastPath Returns Integer
33237>>>>>    Integer rVal
33238>>>>>    String  lsCurrentWksp
33238>>>>>    Get_Profile_String "WorkSpaces" "CurrentWorkspace" to lsCurrentWksp
33241>>>>>    If (lsCurrentWksp="") Get WorkspaceName of (ProgramWorkspace(Self)) to lsCurrentWksp
33244>>>>>    Insert "WorkSpaces\" in lsCurrentWksp at 1
33246>>>>>    Append lsCurrentWksp "\" (Module_Name(Self)) "\Last_MCrypt_Path"
33249>>>>>    Set_Profile_String lsCurrentWksp "Path"  to (Trim(asLastPath))
33252>>>>>    Function_Return rVal
33253>>>>>End_Function
33254>>>>>
33254>>>>>
33254>>>>>Function fsReadRegistryLastMCryptPath Global Returns String
33255>>>>>    String rVal lsCurrentWksp
33256>>>>>    Get_Profile_String "WorkSpaces" "CurrentWorkspace" to lsCurrentWksp
33259>>>>>    If (lsCurrentWksp="") Get WorkspaceName of (ProgramWorkspace(Self)) to lsCurrentWksp
33262>>>>>    Insert "WorkSpaces\" in lsCurrentWksp at 1
33264>>>>>    Append lsCurrentWksp "\" (Module_Name(Self)) "\Last_MCrypt_Path"
33267>>>>>    Get_Profile_String lsCurrentWksp "Path"  to rVal
33270>>>>>    Function_Return (Trim(rVal))
33271>>>>>End_Function
33272>>>>>
33272>>>>>Function fiWriteRegistryLastWEBPath Global String asLastPath Returns Integer
33273>>>>>    Integer rVal
33274>>>>>    String  lsCurrentWksp
33274>>>>>    Get_Profile_String "WorkSpaces" "CurrentWorkspace" to lsCurrentWksp
33277>>>>>    If (lsCurrentWksp="") Get WorkspaceName of (ProgramWorkspace(Self)) to lsCurrentWksp
33280>>>>>    Insert "WorkSpaces\" in lsCurrentWksp at 1
33282>>>>>    Append lsCurrentWksp "\" (Module_Name(Self)) "\Last_WEB_Path"
33285>>>>>    Set_Profile_String lsCurrentWksp "Path"  to (Trim(asLastPath))
33288>>>>>    Function_Return rVal
33289>>>>>End_Function
33290>>>>>
33290>>>>>
33290>>>>>Function fsReadRegistryLastWEBPath Global Returns String
33291>>>>>    String rVal lsCurrentWksp
33292>>>>>    Get_Profile_String "WorkSpaces" "CurrentWorkspace" to lsCurrentWksp
33295>>>>>    If (lsCurrentWksp="") Get WorkspaceName of (ProgramWorkspace(Self)) to lsCurrentWksp
33298>>>>>    Insert "WorkSpaces\" in lsCurrentWksp at 1
33300>>>>>    Append lsCurrentWksp "\" (Module_Name(Self)) "\Last_WEB_Path"
33303>>>>>    Get_Profile_String lsCurrentWksp "Path"  to rVal
33306>>>>>    Function_Return (Trim(rVal))
33307>>>>>End_Function
33308>>>>>
33308>>>>>Function fsReadRegistryFEMRootDir Global Returns String
33309>>>>>    String rVal lsCurrentWksp
33310>>>>>    Get_Profile_String "WorkSpaces" "CurrentWorkspace" to lsCurrentWksp
33313>>>>>    If (lsCurrentWksp="") Get WorkspaceName of (ProgramWorkspace(Self)) to lsCurrentWksp
33316>>>>>    Insert "WorkSpaces\" in lsCurrentWksp at 1
33318>>>>>    Append lsCurrentWksp "\FEM"
33319>>>>>    Get_Profile_String lsCurrentWksp "RootDir"  to rVal
33322>>>>>    Function_Return (Trim(rVal))
33323>>>>>End_Function
33324>>>>>
33324>>>>>Function fsReadRegistryFEMDevicePath Global Returns String
33325>>>>>    String rVal lsCurrentWksp
33326>>>>>    Get_Profile_String "WorkSpaces" "CurrentWorkspace" to lsCurrentWksp
33329>>>>>    If (lsCurrentWksp="") Get WorkspaceName of (ProgramWorkspace(Self)) to lsCurrentWksp
33332>>>>>    Insert "WorkSpaces\" in lsCurrentWksp at 1
33334>>>>>    Append lsCurrentWksp "\FEM"
33335>>>>>    Get_Profile_String lsCurrentWksp "DevicePath"  to rVal
33338>>>>>    Function_Return (Trim(rVal))
33339>>>>>End_Function
33340>>>>>
33340>>>>>Function fiWriteRegistryFEMRootDir Global Returns Integer
33341>>>>>    Integer rVal
33342>>>>>    String  lsCurrentWksp
33342>>>>>    Get_Profile_String "WorkSpaces" "CurrentWorkspace" to lsCurrentWksp
33345>>>>>    If (lsCurrentWksp="") Get WorkspaceName of (ProgramWorkspace(Self)) to lsCurrentWksp
33348>>>>>    Insert "WorkSpaces\" in lsCurrentWksp at 1
33350>>>>>    Append lsCurrentWksp "\FEM"
33351>>>>>    Set_Profile_String lsCurrentWksp "RootDir"  to "C:\FEM_ROOT\"
33354>>>>>    Function_Return rVal
33355>>>>>End_Function
33356>>>>>
33356>>>>>Function fiWriteRegistryFEMDevicePath Global Returns Integer
33357>>>>>    Integer rVal
33358>>>>>    String  lsCurrentWksp
33358>>>>>    Get_Profile_String "WorkSpaces" "CurrentWorkspace" to lsCurrentWksp
33361>>>>>    If (lsCurrentWksp="") Get WorkspaceName of (ProgramWorkspace(Self)) to lsCurrentWksp
33364>>>>>    Insert "WorkSpaces\" in lsCurrentWksp at 1
33366>>>>>    Append lsCurrentWksp "\FEM"
33367>>>>>    Set_Profile_String lsCurrentWksp "DevicePath"  to "C:\FEM_ROOT\Device_File1.dat"
33370>>>>>    Function_Return rVal
33371>>>>>End_Function
33372>>>>>
33372>>>>>
33372>>>>>
33372>>>>>
33372>>>>>
33372>>>>>Function fig_Is_Admin Global Returns Integer
33373>>>>>    String sUser
33374>>>>>    Integer rVal
33374>>>>>    Get fsLoginUserID to sUser
33375>>>>>    Move (trim(sUser)) to sUser
33376>>>>>    Clear Users
33377>>>>>    Move sUser to Users.Login_ID
33378>>>>>    Find eq Users By Index.1 // Users:Index.1:Login_ID
33379>>>>>>
33379>>>>>    Move Users.Admin_Rights to rVal
33380>>>>>    Function_Return rVal
33381>>>>>End_Function
33382>>>>>
33382>>>>>Function fig_The_User_Group Global Returns Integer
33383>>>>>    String sUser
33384>>>>>    Get fsLoginUserID   to sUser
33385>>>>>    Move (trim(sUser))  to sUser
33386>>>>>    Clear Users
33387>>>>>    Move sUser          to Users.Login_ID
33388>>>>>    Find eq Users By Index.1 // Users:Index.1:Login_ID
33389>>>>>>
33389>>>>>    Clear UserGrps
33390>>>>>    Move Users.Grp_ID   to UserGrps.Grp_ID
33391>>>>>    Find eq UserGrps By Index.1 // UserGrps:Index.1:Grp_ID
33392>>>>>>
33392>>>>>    Function_Return UserGrps.Grp_ID
33393>>>>>End_Function
33394>>>>>
33394>>>>>Function fsg_The_User_Department Global Returns String
33395>>>>>    String sUser
33396>>>>>    Get fsLoginUserID   to sUser
33397>>>>>    Move (trim(sUser))  to sUser
33398>>>>>    Clear Users
33399>>>>>    Move sUser          to Users.Login_ID
33400>>>>>    Find eq Users By Index.1 // Users:Index.1:Login_ID
33401>>>>>>
33401>>>>>    Clear Departm
33402>>>>>    Move Users.Departm_Code   to Departm.Code
33403>>>>>    Find eq Departm By Index.1 // Departm:Index.1:Code
33404>>>>>>
33404>>>>>    Function_Return Departm.Code
33405>>>>>End_Function
33406>>>>>
33406>>>>>
33406>>>>>Function fig_Is_Specific_Admin Global String asUser Returns Integer
33407>>>>>    Integer rVal
33408>>>>>    Move (trim(asUser)) to asUser
33409>>>>>    Clear Users
33410>>>>>    Move asUser to Users.Login_ID
33411>>>>>    Find eq Users By Index.1 // Users:Index.1:Login_ID
33412>>>>>>
33412>>>>>    Move Users.Admin_Rights to rVal
33413>>>>>    Function_Return rVal
33414>>>>>End_Function
33415>>>>>
33415>>>>>Function fig_The_Specific_User_Group Global String asUser Returns Integer
33416>>>>>    Move (trim(asUser))  to asUser
33417>>>>>    Clear Users
33418>>>>>    Move asUser          to Users.Login_ID
33419>>>>>    Find eq Users By Index.1 // Users:Index.1:Login_ID
33420>>>>>>
33420>>>>>    Clear UserGrps
33421>>>>>    Move Users.Grp_ID   to UserGrps.Grp_ID
33422>>>>>    Find eq UserGrps By Index.1 // UserGrps:Index.1:Grp_ID
33423>>>>>>
33423>>>>>    Function_Return UserGrps.Grp_ID
33424>>>>>End_Function
33425>>>>>
33425>>>>>Function fsg_The_Specific_User_Department Global String asUser Returns String
33426>>>>>    Move (trim(asUser))  to asUser
33427>>>>>    Clear Users
33428>>>>>    Move asUser          to Users.Login_ID
33429>>>>>    Find eq Users By Index.1 // Users:Index.1:Login_ID
33430>>>>>>
33430>>>>>    Clear Departm
33431>>>>>    Move Users.Departm_Code   to Departm.Code
33432>>>>>    Find eq Departm By Index.1 // Departm:Index.1:Code
33433>>>>>>
33433>>>>>    Function_Return Departm.Code
33434>>>>>End_Function
33435>>>>>
33435>>>>>
33435>>>
33435>>>Class ViewPopupMenu_Sec Is A ViewPopupMenu
33436>>>
33436>>>    Open Sysfile
INCLUDING FILE: SYSFILE.FD
33438>>>    Open Users
33440>>>    Open Views
INCLUDING FILE: VIEWS.FD
33442>>>    Open GrpViews
INCLUDING FILE: GRPVIEWS.FD
33444>>>    Open GrpView0
INCLUDING FILE: GRPVIEW0.FD
33446>>>    Open Arxeia
33448>>>    Open GrpArx
33450>>>
33450>>>    Function Find_User_Rights_In_Class String asView Returns Integer
33451>>>        String  lsView lsLogin
33452>>>        Integer liUser  liViews iGroup
33452>>>
33452>>>        Move (fsLoginUserID())      to lsLogin
33453>>>        Move (Trim(ToOEM(asView)))  to lsView
33454>>>
33454>>>        //////  /////////////////////////////////////
33454>>>        Clear Users
33455>>>        Move lsLogin    to Users.Login_ID
33456>>>
33456>>>        Find eq Users by Index.1 // Users:Index.1:Users.Login_ID
33457>>>>
33457>>>        If (Found=1)  Begin
33459>>>            Move Users.User_ID  to liUser
33460>>>            Move Users.Grp_ID   to iGroup
33461>>>        End
33461>>>>
33461>>>        Else Function_Return 0
33463>>>
33463>>>        Clear Views
33464>>>        Move (Trim(lsView)) to Views.Menu_Name
33465>>>        Find eq Views by Index.2 // Views:Index.2:Views.Menu_Name
33466>>>>
33466>>>        If (Found=1) Begin
33468>>>            Move Views.View_ID to liViews
33469>>>            Clear GrpViews
33470>>>            Move liUser    to GrpViews.User_ID
33471>>>            Move liViews   to GrpViews.View_ID
33472>>>            Find Eq GrpViews by Index.1 // GrpViews:Index.1:GrpViews.User_ID+GrpViews.View_ID
33473>>>>
33473>>>            If (Found=1) Begin // And (liUser=GrpViews.User_ID) And (liViews=GrpViews.View_ID)) Begin
33475>>>                Function_Return (GrpViews.Allow_Read<>'1')
33476>>>            End
33476>>>>
33476>>>            Else Begin
33477>>>                Clear GrpView0
33478>>>                Move iGroup    to GrpView0.Group_ID
33479>>>                Move liViews   to GrpView0.View_ID
33480>>>                Find eq GrpView0 by Index.1 // GrpView0:Index.1:Group_ID+View_ID
33481>>>>
33481>>>                If (Found=1) Begin
33483>>>                    Function_Return (GrpView0.Allow_Read<>'1')
33484>>>                End
33484>>>>
33484>>>                Else         Function_Return 0
33486>>>            End
33486>>>>
33486>>>        End
33486>>>>
33486>>>        Else Function_Return 0
33488>>>    End_Function
33489>>>
33489>>>//    Procedure Enhmerose_Views_File_In_Class
33489>>>//        Integer liCount liInt liLastNo
33489>>>//        String lsStr
33489>>>//        Get Item_Count to liCount
33489>>>//        // find last view_id
33489>>>//        Clear Views
33489>>>//        Move 9999 to Views.View_ID
33489>>>//        Find lt Views by index.1 // view_id
33489>>>//        If (Found=1)    Move Views.View_ID  to liLastNo
33489>>>//        Else            Move 0              to liLastNo
33489>>>//        For liInt From 0 to (liCount-1)
33489>>>//            Get Value item liInt to lsStr
33489>>>//            Move (Trim(ToOEM(lsStr))) to lsStr
33489>>>//            //Move (Trim(lsStr)) to lsStr
33489>>>//            If (lsStr<>'') Begin
33489>>>//                Clear Views
33489>>>//                Move lsStr to Views.Menu_Name
33489>>>//                Find eq Views by index.2 // Views.Menu_Name
33489>>>//                If (NOT(Found)) Begin
33489>>>//                    Add 1 to liLastNo
33489>>>//                    Move liLastNo to Views.View_ID
33489>>>//                    Saverecord Views
33489>>>//                End
33489>>>//            End
33489>>>//        Loop
33489>>>//        For liInt From 0 to (liCount-1)
33489>>>//            Get Value item liInt to lsStr
33489>>>//            Move (Trim(ToOEM(lsStr))) to lsStr
33489>>>//            //Move (Trim(lsStr)) to lsStr
33489>>>//            If (lsStr<>'') Set Shadow_State item liInt to (Find_User_Rights_In_Class(Self,lsStr))
33489>>>//        Loop
33489>>>//    End_procedure
33489>>>
33489>>>    Procedure OnInitMenu
33490>>>        Integer liCount liInt liLastNo
33491>>>        String lsStr
33491>>>
33491>>>        Get Item_Count to liCount
33492>>>
33492>>>        // find last view_id
33492>>>        Clear Views
33493>>>        Move 9999 to Views.View_ID
33494>>>        Find lt Views by index.1 // view_id
33495>>>>
33495>>>        If (Found=1)    Move Views.View_ID  to liLastNo
33498>>>        Else            Move 0              to liLastNo
33500>>>        For liInt From 0 to (liCount-1)
33506>>>>
33506>>>            Get Value item liInt to lsStr
33507>>>            Move (Trim(lsStr)) to lsStr
33508>>>            If ((lsStr<>'') and (Length(lsStr)>2)) Begin
33510>>>                Clear Views
33511>>>                Move (ToOEM(lsStr)) to Views.Menu_Name
33512>>>                Find eq Views by index.2 // Views.Menu_Name
33513>>>>
33513>>>                If (NOT(Found)) Begin
33515>>>                    Add 1 to liLastNo
33516>>>                    Move liLastNo to Views.View_ID
33517>>>                    //Move (ToOEM(lsStr)) to Views.Menu_Name
33517>>>                    Saverecord Views
33518>>>                End
33518>>>>
33518>>>            End
33518>>>>
33518>>>        Loop
33519>>>>
33519>>>        For liInt From 0 to (liCount-1)
33525>>>>
33525>>>            Get Value item liInt to lsStr
33526>>>            Move (Trim(lsStr)) to lsStr
33527>>>            Set Shadow_State item liInt to (Find_User_Rights_In_Class(Self,lsStr))
33528>>>        Loop
33529>>>>
33529>>>
33529>>>    End_procedure
33530>>>
33530>>>//    Procedure End_Construct_Object
33530>>>//        Forward Send End_Construct_Object
33530>>>//        Send Enhmerose_Views_File_In_Class
33530>>>//    End_Procedure
33530>>>
33530>>>End_Class //ButtonSub
33531>>>
33531>>>
33531>Use TranLock
INCLUDING FILE: TRANLOCK.PKG
33531>>>// Statement of purpose:
33531>>>// When using a reread command in VDF you will unfortunately lock many more
33531>>>// files than are necessary.  In order to only lock the files necessary I
33531>>>// use the following procedure to set all files to readonly, manually set
33531>>>// the files being worked on to (default) and then reset all back at the end.
33531>>>// This is what a data dictionary does in a VDF program for it's ddo tree.
33531>>>
33531>>>// The original package is a contribution of another programmer whom I cannot
33531>>>// remember their name (sorry).  The alteration I have done is to make sure that any file
33531>>>// with a non-default filemode will be set back to it's previous setting.
33531>>>
33531>>>Object FileModeArray Is An Array
33533>>>    // 0 = File Number
33533>>>    // 1 = Non-Default FileMode Existing Before Change By ChangeAllFileModes Procedure
33533>>>End_Object
33534>>>
33534>>>Procedure Write_Attribute_Array Integer iFile Integer iFileMode
33535>>>    Integer iCounter hArray iExists
33536>>>    Move (FileModeArray(Self)) To hArray
33537>>>    For iCounter From 0 To 1000
33543>>>>
33543>>>        Get Array_Value Of hArray Item ((iCounter * 2) + 0) To iExists
33544>>>        If (Not(iExists) Or (iExists = iFile)) Begin
33546>>>            Set Array_Value Of hArray Item ((iCounter * 2) + 0) To iFile
33547>>>            Set Array_Value Of hArray Item ((iCounter * 2) + 1) To iFileMode
33548>>>        End
33548>>>>
33548>>>        If (Not(iExists) Or (iExists = iFile)) Break
33551>>>    Loop
33552>>>>
33552>>>End_Procedure
33553>>>
33553>>>Procedure Clear_FileModeArray
33554>>>    Send Delete_Data To (FileModeArray(Self))
33555>>>End_Procedure
33556>>>
33556>>>Function Is_NonStandardFileMode Integer iFile Returns Integer
33557>>>    Integer iCounter iExists iNonStandardFileMode hArray
33558>>>    Move (FileModeArray(Self)) To hArray
33559>>>    For iCounter From 0 To 1000
33565>>>>
33565>>>        Get Array_Value Of hArray Item ((iCounter * 2) + 0) To iExists
33566>>>        If (Not(iExists)) Function_Return 0 // Not Listed In Array
33569>>>        If (iExists = iFile) Begin
33571>>>            Get Array_Value Of hArray Item ((iCounter * 2) + 1) To iNonStandardFileMode
33572>>>            Function_Return iNonStandardFileMode
33573>>>        End
33573>>>>
33573>>>    Loop
33574>>>>
33574>>>    Function_Return
33575>>>End_Function
33576>>>
33576>>>Procedure ChangeAllFileModes Integer iMode
33577>>>    Integer iFile iExistingFileMode iNonStandardFileMode
33578>>>    If (iMode = DF_FileMode_ReadOnly) Send Clear_FileModeArray
33581>>>    Repeat
33581>>>>
33581>>>        // Get Each Opened File, One At A Time...
33581>>>        Get_Attribute DF_File_Next_Opened Of iFile To iFile
33584>>>        If (Not(iFile)) Break
33587>>>        If (iMode = DF_Filemode_ReadOnly) Begin  // Setting All Files To Readonly: Check Alias Stuff
33589>>>            Get_Attribute DF_File_Mode Of iFile To iExistingFileMode
33592>>>            If (iExistingFileMode <> DF_Filemode_Default) Send Write_Attribute_Array iFile iExistingFileMode
33595>>>        End
33595>>>>
33595>>>        If (iMode = DF_Filemode_Default) Begin  // Setting All Files Back To Default
33597>>>            Get Is_NonStandardFileMode iFile To iNonStandardFileMode
33598>>>        End
33598>>>>
33598>>>        If (iNonStandardFileMode) Set_Attribute DF_File_Mode Of iFile To iNonStandardFileMode
33603>>>        Else                      Set_Attribute DF_File_Mode Of iFile To iMode
33607>>>    Loop
33608>>>>
33608>>>End_Procedure
33609>>>
33609>>>// // Comment: Example Of Usage:
33609>>>//    Send ChangeAllFileModes DF_Filemode_ReadOnly  // See Stark.Pkg for This Desktop Procedure
33609>>>// // Comment: Set All Open Files To ReadOnly Except For... (Files Used In Transaction Block)
33609>>>//    Set_Attribute DF_File_Mode Of MyFile1.File_Number To DF_Filemode_Default
33609>>>//    Set_Attribute DF_File_Mode Of MyFile2.File_Number  To DF_Filemode_Default
33609>>>//    Indicate Err False
33609>>>//    Begin_Transaction
33609>>>//
33609>>>//        Clear MyFile1
33609>>>//        Move 1 To MyFile1.Key
33609>>>//        Find EQ MyFile1 By Index.1
33609>>>//        Relate MyFile1
33609>>>//        Add MyFile2.Amount To MyFile1.Amount
33609>>>//        Saverecord MyFile1
33609>>>//        Saverecord MyFile2
33609>>>//        If (Condition) Error 300 "Error Message Here" // Saves Rolled Back
33609>>>//
33609>>>//    End_Transaction
33609>>>//    If (Err) Begin
33609>>>//        Send Info_Box "Errors Were Encountered: No Files Were Altered By This Process (All Changes Rolled Back)"
33609>>>//    End
33609>>>//    Send ChangeAllFileModes DF_Filemode_Default  // Set FileModes Back From Readonly To Normal
33609>Use GridUtil.Utl
INCLUDING FILE: GRIDUTIL.UTL
33609>>>// Use GridUtil.utl // Grid and List utilities
33609>>>
33609>>>//> This package provides a number of functions working on objects of the
33609>>>//> Grid class (VDF) and List class (character mode DF). On the other hand
33609>>>//> it does not work with dbGrid (VDF) class or Table classes (character
33609>>>//> mode DF).
33609>>>//>
33609>>>//> Rather than having these function inplemented in a subclass of the
33609>>>//> Grid- or List classes I have made global functions and procedures
33609>>>//> that all takes the objects ID as the first parameter.
33609>>>//>
33609>>>//> To sort the contents of a grid by the contents of column column# use:
33609>>>//>
33609>>>//>    procedure Grid_SortByColumn global integer oGrd# integer column#
33609>>>//>
33609>>>//> The set the entry_state of all items in a grid in one go use:
33609>>>//>
33609>>>//>    procedure Grid_SetEntryState global integer obj# integer st#
33609>>>//>
33609>>>//> To figure out the number of the first item in the current row use:
33609>>>//>
33609>>>//>    function Grid_BaseItem global integer obj# returns integer
33609>>>//>
33609>>>//> To figure out the current column use:
33609>>>//>
33609>>>//>    function Grid_CurrentColumn global integer obj# returns integer
33609>>>//>
33609>>>//> And finally, to figure out the number of columns use:
33609>>>//>
33609>>>//>    function Grid_Columns global integer obj# returns integer
33609>>>//>
33609>>>
33609>>>Use Base.utl     // Item_Property command, Various macros (FOR_EX...), cArray, cSet and cStack classes
INCLUDING FILE: BASE.UTL
33609>>>>>// Use Base.utl     // Item_Property command, Various macros (FOR_EX...), cArray, cSet and cStack classes
33609>>>>>
33609>>>>>// This purpose of this package is to relieve me of having to remember which
33609>>>>>// package exactly holds a particular command or class.
33609>>>>>
33609>>>>>Use Array.utl    // Item_Property command
INCLUDING FILE: ARRAY.UTL
33609>>>>>>>// Use Array.utl    // Item_Property command
33609>>>>>>>
33609>>>>>>>// This package defines three commands ITEM_PROPERTY_LIST, ITEM_PROPERTY
33609>>>>>>>// and END_ITEM_PROPERTY_LIST. They should be used like this:
33609>>>>>>>//
33609>>>>>>>//          object oTest is an Array
33609>>>>>>>//            item_property_list
33609>>>>>>>//              item_property string  pItem_Label
33609>>>>>>>//              item_property integer pItem_Type
33609>>>>>>>//              item_property string  pItem_Default
33609>>>>>>>//            end_item_property_list // IF IN CLASS REPEAT CLASS NAME HERE!
33609>>>>>>>//          end_object
33609>>>>>>>//
33609>>>>>>>// You will now be able to write code like:
33609>>>>>>>//
33609>>>>>>>//          set pItem_Label   item 2 to "Amazing"
33609>>>>>>>//          get pItem_Default item 0 to sVar
33609>>>>>>>//
33609>>>>>>>// Note that you do not need to sub-class the array in order to fo this.
33609>>>>>>>// The ITEM_PROPERTY command structure simply defines a number of messages
33609>>>>>>>// that lets you set the values of the array using your own names.
33609>>>>>>>//
33609>>>>>>>// In a normal array you may get the number of items by using the Item_Count
33609>>>>>>>// function. Of course you may still do that, but you would more likely
33609>>>>>>>// want to retrieve the number of 'rows' currently in the array. For this
33609>>>>>>>// purpose the END_ITEM_PROPERTY_LIST command defines a function called
33609>>>>>>>// Row_Count.
33609>>>>>>>//
33609>>>>>>>// In an empty array the Row_Count function returns 0 (surprise). Having
33609>>>>>>>// set just one of the values of the 1'st row (row number 0) the Row_Count
33609>>>>>>>// function will return 1.
33609>>>>>>>//
33609>>>>>>>// If you want to define item_properties as part of a class definition
33609>>>>>>>// you should NOT define them inside procedure construct_object as you
33609>>>>>>>// would with normal properties. Instead it looks like this:
33609>>>>>>>//
33609>>>>>>>//          class cTest is an Array
33609>>>>>>>//            item_property_list
33609>>>>>>>//              item_property string  pItem_Label
33609>>>>>>>//              item_property integer pItem_Type
33609>>>>>>>//              item_property string  pItem_Default
33609>>>>>>>//            end_item_property_list cTest // NOTE: Class name as parameter!
33609>>>>>>>//          end_class
33609>>>>>>>
33609>>>>>>>use ui
33609>>>>>>>
33609>>>>>>>Enumeration_List // Symbols used internally by the item_property command
33609>>>>>>>  define EA$INTEGER
33609>>>>>>>  define EA$STRING
33609>>>>>>>  define EA$REAL
33609>>>>>>>  define EA$NUMBER
33609>>>>>>>  define EA$DATE
33609>>>>>>>End_Enumeration_List
33609>>>>>>>
33609>>>>>>>
33609>>>>>>>
33609>>>>>>>
33609>>>>>>>
33609>>>>>>>
33609>>>>>>>
33609>>>>>>>
33609>>>>>>>
33609>>>>>>>
33609>>>>>>>procedure Clone_Array global integer source# integer target#
33610>>>>>>>  local integer itm# max#
33611>>>>>>>  move (item_count(source#)) to max#
33612>>>>>>>  send delete_data to target#
33613>>>>>>>  for itm# from 0 to (max#-1)
33619>>>>>>>>
33619>>>>>>>    set value of target# item itm# to (value(source#,itm#))
33620>>>>>>>  loop
33621>>>>>>>>
33621>>>>>>>end_procedure
33622>>>>>Use Macros.utl   // Various macros (FOR_EX...)
33622>>>>>Use Set.utl      // cArray, cSet and cStack classes
INCLUDING FILE: SET.UTL
33622>>>>>>>// Use Set.utl      // cArray, cSet and cStack classes
33622>>>>>>>
33622>>>>>>>use ui
33622>>>>>>>Use DestObj.pkg  // DAW - Defines request_destroy_object
33622>>>>>>>
33622>>>>>>>class cArray is an Array
33623>>>>>>>  procedure construct_object integer img#
33624>>>>>>>    forward send construct_object img#
33626>>>>>>>    set delegation_mode to delegate_to_parent
33627>>>>>>>  end_procedure
33628>>>>>>>end_class // cArray
33629>>>>>>>
33629>>>>>>>class cArray2d is a cArray
33630>>>>>>>  function iObjectID.i integer x# returns integer
33631>>>>>>>    local integer obj#
33632>>>>>>>    get value item x# to obj#
33633>>>>>>>    ifnot obj# begin
33635>>>>>>>      object oArray2d is a cArray no_image
33637>>>>>>>        move current_object to obj#
33638>>>>>>>      end_object
33639>>>>>>>      set value item x# to obj#
33640>>>>>>>    end
33640>>>>>>>>
33640>>>>>>>    function_return obj#
33641>>>>>>>  end_function
33642>>>>>>>  procedure set Value.ii integer x# integer y# string value#
33643>>>>>>>    local integer obj#
33644>>>>>>>    get iObjectID.i x# to obj#
33645>>>>>>>    set value of obj# item y# to value#
33646>>>>>>>  end_procedure
33647>>>>>>>  function Value.ii integer x# integer y# returns string
33648>>>>>>>    local integer obj#
33649>>>>>>>    get value item x# to obj#
33650>>>>>>>    if obj# function_return (value(obj#,y#))
33653>>>>>>>    function_return 0
33654>>>>>>>  end_function
33655>>>>>>>  procedure reset
33656>>>>>>>    local integer itm# max# obj#
33657>>>>>>>    get item_count to max#
33658>>>>>>>    for itm# from 0 to (max#-1)
33664>>>>>>>>
33664>>>>>>>      get value item itm# to obj#
33665>>>>>>>      if obj# send request_destroy_object to obj#
33668>>>>>>>    loop
33669>>>>>>>>
33669>>>>>>>    send delete_data
33670>>>>>>>  end_procedure
33671>>>>>>>end_class // cArray2d
33672>>>>>>>
33672>>>>>>>class cArray3d is a cArray2d
33673>>>>>>>  function iObjectID.ii integer x# integer y# returns integer
33674>>>>>>>    local integer obj#
33675>>>>>>>    get Value.ii x# y# to obj#
33676>>>>>>>    ifnot obj# begin
33678>>>>>>>      object oArray3d is a cArray no_image
33680>>>>>>>        move current_object to obj#
33681>>>>>>>      end_object
33682>>>>>>>      set Value.ii x# y# to obj#
33683>>>>>>>    end
33683>>>>>>>>
33683>>>>>>>    function_return obj#
33684>>>>>>>  end_function
33685>>>>>>>  procedure set Value.iii integer x# integer y# integer z# string value#
33686>>>>>>>    local integer obj#
33687>>>>>>>    get iObjectID.ii x# y# to obj#
33688>>>>>>>    set value of obj# item z# to value#
33689>>>>>>>  end_procedure
33690>>>>>>>  function Value.iii integer x# integer y# integer z# returns string
33691>>>>>>>    local integer obj#
33692>>>>>>>    get value item x# to obj#
33693>>>>>>>    if obj# begin
33695>>>>>>>      get value of obj# item y# to obj#
33696>>>>>>>      if obj# function_return (value(obj#,z#))
33699>>>>>>>    end
33699>>>>>>>>
33699>>>>>>>    function_return 0
33700>>>>>>>  end_function
33701>>>>>>>  procedure reset
33702>>>>>>>    local integer xmax# ymax# x# y# yobj# zobj#
33703>>>>>>>    get item_count to xmax#
33704>>>>>>>    for x# from 0 to (xmax#-1)
33710>>>>>>>>
33710>>>>>>>      get value item x# to yobj#
33711>>>>>>>      if yobj# begin
33713>>>>>>>        get item_count of yobj# to ymax#
33714>>>>>>>        for y# from 0 to (ymax#-1)
33720>>>>>>>>
33720>>>>>>>          get value of yobj# item y# to zobj#
33721>>>>>>>          if zobj# send request_destroy_object to zobj#
33724>>>>>>>        loop
33725>>>>>>>>
33725>>>>>>>      end
33725>>>>>>>>
33725>>>>>>>    loop
33726>>>>>>>>
33726>>>>>>>    forward send reset
33728>>>>>>>  end_procedure
33729>>>>>>>end_class // cArray3d
33730>>>>>>>
33730>>>>>>>class cSet is an cArray
33731>>>>>>>  function element_find string sVar returns integer
33732>>>>>>>    local integer max# itm#
33733>>>>>>>    get item_count to max#
33734>>>>>>>    move 0 to itm#
33735>>>>>>>    while itm# lt max#
33739>>>>>>>      if sVar eq (value(current_object,itm#)) function_return itm# // Dirty exit
33742>>>>>>>      increment itm#
33743>>>>>>>    end
33744>>>>>>>>
33744>>>>>>>    function_return -1
33745>>>>>>>  end_function
33746>>>>>>>
33746>>>>>>>  procedure element_add string sVar
33747>>>>>>>    if (element_find(current_object,sVar)=-1) set value item (item_count(current_object)) to sVar
33750>>>>>>>  end_procedure
33751>>>>>>>
33751>>>>>>>  procedure element_remove string sVar
33752>>>>>>>    local integer itm#
33753>>>>>>>    get element_find sVar to itm#
33754>>>>>>>    if itm# ge 0 send delete_item itm#
33757>>>>>>>  end_procedure
33758>>>>>>>
33758>>>>>>>  function iAddOrFind_Element string sVar returns integer
33759>>>>>>>    local integer rval#
33760>>>>>>>    get element_find sVar to rval#
33761>>>>>>>    if rval# eq -1 begin
33763>>>>>>>      get item_count to rval#
33764>>>>>>>      set value item rval# to sVar
33765>>>>>>>    end
33765>>>>>>>>
33765>>>>>>>    function_return rval#
33766>>>>>>>  end_function
33767>>>>>>>
33767>>>>>>>//// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
33767>>>>>>>//// Original procedures (optimized) are mentioned for compatibility:
33767>>>>>>>//
33767>>>>>>>//function find_element string sVar returns integer
33767>>>>>>>//  local integer max# itm#
33767>>>>>>>//  get item_count to max#
33767>>>>>>>//  move 0 to itm#
33767>>>>>>>//  while itm# lt max#
33767>>>>>>>//    if sVar eq (value(current_object,itm#)) function_return itm# // Dirty exit
33767>>>>>>>//    increment itm#
33767>>>>>>>//  end
33767>>>>>>>//  function_return -1
33767>>>>>>>//end_function
33767>>>>>>>//
33767>>>>>>>//procedure Add_Element string sVar returns integer
33767>>>>>>>//  local integer rval#
33767>>>>>>>//  get find_element sVar to rval#
33767>>>>>>>//  if rval# lt 0 get item_count to rval#
33767>>>>>>>//  set array_value item rval# to sVar
33767>>>>>>>//  procedure_return rval#
33767>>>>>>>//end_procedure
33767>>>>>>>//
33767>>>>>>>//procedure Remove_Element string sVar
33767>>>>>>>//  local integer itm#
33767>>>>>>>//  get Find_Element item sVar to itm#
33767>>>>>>>//  if itm# gt -1 send delete_item itm#
33767>>>>>>>//end_procedure
33767>>>>>>>//// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
33767>>>>>>>end_class
33768>>>>>>>
33768>>>>>>>class cStack is an cArray
33769>>>>>>>  function Stack_Empty returns integer
33770>>>>>>>    function_return (item_count(current_object)=0)
33771>>>>>>>  end_function
33772>>>>>>>  // *** Integer interface **************************************
33772>>>>>>>  procedure Push.i integer value#
33773>>>>>>>    set value item (item_count(current_object)) to value#
33774>>>>>>>  end_procedure
33775>>>>>>>  function iPop returns integer
33776>>>>>>>    local integer rval# itm#
33777>>>>>>>    move (item_count(current_object)-1) to itm#
33778>>>>>>>    get value item itm# to rval#
33779>>>>>>>    send delete_item itm#
33780>>>>>>>    function_return rval#
33781>>>>>>>  end_function
33782>>>>>>>  function iCopy returns integer
33783>>>>>>>    function_return (value(current_object,item_count(current_object)-1))
33784>>>>>>>  end_function
33785>>>>>>>  // *** String interface ***************************************
33785>>>>>>>  procedure Push.s string value#
33786>>>>>>>    set value item (item_count(current_object)) to value#
33787>>>>>>>  end_procedure
33788>>>>>>>  function sPop returns string
33789>>>>>>>    local integer itm#
33790>>>>>>>    local string rval#
33790>>>>>>>    move (item_count(current_object)-1) to itm#
33791>>>>>>>    get value item itm# to rval#
33792>>>>>>>    send delete_item itm#
33793>>>>>>>    function_return rval#
33794>>>>>>>  end_function
33795>>>>>>>  function sCopy returns string
33796>>>>>>>    function_return (value(current_object,item_count(current_object)-1))
33797>>>>>>>  end_function
33798>>>>>>>end_class
33799>>>>>
33799>>>Use Strings.utl  // String manipulation for VDF and 3.1
INCLUDING FILE: STRINGS.UTL
33799>>>>>// **********************************************************************
33799>>>>>// Use Strings.utl  // String manipulation for VDF and 3.1
33799>>>>>//
33799>>>>>// By Sture Andersen
33799>>>>>//
33799>>>>>// The file contains a number of global functions for manipulating
33799>>>>>// strings and converting numbers to strings. The package may be used
33799>>>>>// with DataFlex 3.1 and Visual DataFlex. This package is public domain.
33799>>>>>//
33799>>>>>//
33799>>>>>// Create: Fri  23-05-1997 - Merger of s_utl002, 006.
33799>>>>>// Update: Tue  25-08-1997 - Introduced fixes from Magnus Bergh
33799>>>>>//         Sun  14-12-1997 - Added the following functions:
33799>>>>>//                             ExtractWord           ExtractInteger
33799>>>>>//                             HowManyWords          HowManyIntegers
33799>>>>>//                             ExtractItemNeg        IsIntegerPresent
33799>>>>>//         Tue  31-03-1998 - Added the following functions:
33799>>>>>//                             Text_RemoveTrailingCr Text_CompressSubstCr
33799>>>>>//                             Text_RTrim            Text_Format.sii
33799>>>>>//                             Text_Trim             Text_FormattedLine.i
33799>>>>>//                             Text_Compress
33799>>>>>//         Fri  06-11-1998 - Added function InsertThousandsSep
33799>>>>>//         Sun  14-02-1999 - Added function Byte_ToHex
33799>>>>>//         Wed  27-04-1999 - Added function CurrentDecimalSeparator
33799>>>>>//
33799>>>>>// ***********************************************************************
33799>>>>>
33799>>>>>// Returns the string of length len# inside which src# is right justified:
33799>>>>>Function RightShift global string src# integer len# returns string
33800>>>>>  trim src# to src#
33801>>>>>>
33801>>>>>  if (length(src#)) lt len# insert (left(pad("",len#),len#-length(src#))) in src# at 1
33805>>>>>  function_return (left(src#,len#))
33806>>>>>End_Function
33807>>>>>
33807>>>>>// Returns the string of length len# inside which src# is centered:
33807>>>>>Function CenterString global string src# integer len# returns string
33808>>>>>  trim src# to src#
33809>>>>>>
33809>>>>>  if (length(src#)) lt len# insert (left(pad("",len#),len#-length(src#)/2)) in src# at 1
33813>>>>>  function_return (left(src#,len#))
33814>>>>>End_Function
33815>>>>>
33815>>>>>// Returns all characters to the right of position pos# (including the character at
33815>>>>>// posistion pos#)
33815>>>>>Function RightFromPos global string str# integer pos# returns string
33816>>>>>  function_return (right(str#,length(str#)-pos#+1))
33817>>>>>End_Function
33818>>>>>
33818>>>>>// Number converting functions:
33818>>>>>
33818>>>>>integer NumToStringConversionMode#
33818>>>>>
33818>>>>>move NUMTOSTR_THOUSANDS_SEPARATOR_OFF to NumToStringConversionMode#
33819>>>>>
33819>>>>>procedure set pNumToStringConversionMode integer value#
33820>>>>>  move value# to NumToStringConversionMode#
33821>>>>>end_procedure
33822>>>>>
33822>>>>>function InsertThousandsSep global string str# returns string
33823>>>>>  local integer pos# tmp#
33824>>>>>  local string sep#
33824>>>>>  trim str# to str#
33825>>>>>>
33825>>>>>  get_attribute DF_DECIMAL_SEPARATOR to pos#
33828>>>>>  character pos# to sep#
33829>>>>>>
33829>>>>>  move (pos(sep#,str#)) to pos#
33830>>>>>  ifnot pos# move (length(str#)+1) to pos#
33833>>>>>  get_attribute DF_THOUSANDS_SEPARATOR to tmp#
33836>>>>>  character tmp# to sep# // End overload
33837>>>>>>
33837>>>>>  while pos# gt 4
33841>>>>>    move (pos#-3) to pos#
33842>>>>>    insert sep# in str# at pos#
33844>>>>>  loop
33845>>>>>>
33845>>>>>  function_return str#
33846>>>>>end_function
33847>>>>>
33847>>>>>// Calling the function below will convert the number stored in src# to a
33847>>>>>// string containing dcp# decimals rounding excess decimals. Parameter dcp#
33847>>>>>// may be negative. The expression (NumToStr(1789,-3)) will evaluate to "2000".
33847>>>>>// The functions in this package all respects the value of global attribute
33847>>>>>// DF_DECIMAL_SEPARATOR.
33847>>>>>Function NumToStr global number src# integer dcp# returns string
33848>>>>>  local integer pos#
33849>>>>>  local string rval# radix#
33849>>>>>  if dcp# lt 0 function_return (NumToStr(src#*(10^dcp#),0)+left("00000000",-dcp#))
33852>>>>>  if src# ge 0 move (src#+(0.5/(10^dcp#))) to src#
33855>>>>>  else move (src#-(0.5/(10^dcp#))) to src#
33857>>>>>  get_attribute DF_DECIMAL_SEPARATOR to pos# // Overload
33860>>>>>  character pos# to radix# // End overload
33861>>>>>>
33861>>>>>  move src# to rval#
33862>>>>>  ifnot (pos(radix#,rval#)) append rval# radix#
33865>>>>>
33865>>>>>  append rval# "00000000"
33866>>>>>
33866>>>>>  move (pos(radix#,rval#)) to pos#
33867>>>>>  if dcp# eq 0 decrement pos#
33870>>>>>  move (left(rval#,pos#+dcp#)) to rval#
33871>>>>>  if NumToStringConversionMode# move (InsertThousandsSep(rval#)) to rval#
33874>>>>>  function_return rval#
33875>>>>>End_Function
33876>>>>>
33876>>>>>// This function is the same as NumToStr except that you have to specify
33876>>>>>// the length of the target string (len#). The number will be right
33876>>>>>// justified accordingly. Post-fix `R' means right justify:
33876>>>>>Function NumToStrR global number src# integer dcp# integer len# returns string
33877>>>>>  function_return (RightShift(NumToStr(src#,dcp#),len#))
33878>>>>>End_Function
33879>>>>>
33879>>>>>// This function is the same as NumToStrR except that you do not specify
33879>>>>>// the number of decimals:
33879>>>>>Function IntToStrR global number src# integer len# returns string
33880>>>>>  function_return (NumToStrR(src#,0,len#)) // Fixed, Magnus Bergh
33881>>>>>End_Function
33882>>>>>
33882>>>>>// Is the same as IntToStrR, except that leading blanks are substituted
33882>>>>>// for leading zeros (zf=zero fill):
33882>>>>>Function IntToStrRzf global number src# integer len# returns string
33883>>>>>  function_return (replaces(" ",NumToStrR(src#,0,len#),"0")) // Fixed, Magnus Bergh
33884>>>>>End_Function
33885>>>>>
33885>>>>>// Use this to obtain the number of the least significant "non zero
33885>>>>>// decimal in src#. 0.702 will return 3 while 100 will return -2:
33885>>>>>Function NumberOfDecs global number src# returns integer
33886>>>>>  local integer count#
33887>>>>>  local string tmp# radix#
33887>>>>>  if src# eq 0 function_return 0 // Special case
33890>>>>>  move src# to tmp# // This removes superflous decimals
33891>>>>>  get_attribute DF_DECIMAL_SEPARATOR to count# // Overload
33894>>>>>  character count# to radix# // End overload
33895>>>>>>
33895>>>>>  if radix# in src# function_return (length(tmp#)-pos(radix#,tmp#))
33898>>>>>  move 0 to count#
33899>>>>>  while (right(tmp#,1)="0")
33903>>>>>    move (left(tmp#,length(tmp#)-1)) to tmp#
33904>>>>>    decrement count#
33905>>>>>  end
33906>>>>>>
33906>>>>>  function_return count#
33907>>>>>End_Function
33908>>>>>
33908>>>>>function CurrentDecimalSeparator global returns string
33909>>>>>  local integer rval#
33910>>>>>  get_attribute DF_DECIMAL_SEPARATOR to rval#
33913>>>>>  function_return (character(rval#))
33914>>>>>end_function
33915>>>>>
33915>>>>>
33915>>>>>// StripFromLastOccurance takes two strings (src# and val#) as
33915>>>>>// arguments. src# is scanned backwards for occurrances of substring
33915>>>>>// val#. If found, the function will return a string equal to src#
33915>>>>>// truncated at the first character of the right most occurance of substring
33915>>>>>// val#.
33915>>>>>//
33915>>>>>// StripFromLastOccurance("To be or not to be...","be") = "To be or not to "
33915>>>>>// StripFromLastOccurance("Mary had a little lamb","white") = ""
33915>>>>>// StripFromLastOccurance("Mary had a little lamb","") = "Mary had a little lamb"
33915>>>>>//
33915>>>>>Function StripFromLastOccurance global string src# string val# returns string
33916>>>>>  local integer len# search_len#
33917>>>>>  local string tmp#
33917>>>>>  length val# to search_len#
33918>>>>>>
33918>>>>>  if search_len# eq 0 function_return src#
33921>>>>>  repeat
33921>>>>>>
33921>>>>>    length src# to len#
33922>>>>>>
33922>>>>>    if len# le search_len# function_return ""
33925>>>>>    move (right(src#,search_len#)) to tmp#
33926>>>>>    if tmp# eq val# function_return (left(src#,len#-search_len#))
33929>>>>>    move (left(src#,len#-1)) to src#
33930>>>>>  loop
33931>>>>>>
33931>>>>>End_Function
33932>>>>>
33932>>>>>Function GetFromLastOccurance global string src# string val# returns string
33933>>>>>  function_return (replace(StripFromLastOccurance(src#,val#),src#,""))
33934>>>>>End_Function
33935>>>>>
33935>>>>>// (ExtractWord("item1 item2"," ",0)) = ""
33935>>>>>// (ExtractWord("item1 item2"," ",1)) = "item1"
33935>>>>>// (ExtractWord("item1 item2"," ",2)) = "item2"
33935>>>>>// (ExtractWord("item1 item2"," ",3)) = ""
33935>>>>>// (ExtractWord(" item1 item2 "," ",x)) =
33935>>>>>//                       (ExtractWord("item1 item2"," ",x))
33935>>>>>//
33935>>>>>                         //        source     delimiters  item number
33935>>>>>Function ExtractWord global string src# string dlm# integer itm# returns string
33936>>>>>  local integer count# pos# in_item# len#
33937>>>>>  local string rval# atom#
33937>>>>>  move "" to rval#
33938>>>>>  move 0 to count#
33939>>>>>  move 0 to in_item#
33940>>>>>  move (length(src#)) to len#
33941>>>>>  for pos# from 1 to len#
33947>>>>>>
33947>>>>>    mid src# to atom# 1 pos#
33950>>>>>>
33950>>>>>    if in_item# begin
33952>>>>>      if atom# in dlm# move 0 to in_item#
33955>>>>>      else if count# eq itm# append rval# atom#
33959>>>>>    end
33959>>>>>>
33959>>>>>    else begin
33960>>>>>      ifnot atom# in dlm# begin
33962>>>>>        increment count#
33963>>>>>        move 1 to in_item#
33964>>>>>        if count# eq itm# move atom# to rval#
33967>>>>>      end
33967>>>>>>
33967>>>>>    end
33967>>>>>>
33967>>>>>  loop
33968>>>>>>
33968>>>>>  function_return rval#
33969>>>>>End_Function
33970>>>>>Function ExtractItem global string src# string dlm# integer itm# returns string
33971>>>>>  Function_Return (ExtractWord(src#,dlm#,itm#))
33972>>>>>End_Function
33973>>>>>                          //        source     delimiters
33973>>>>>Function HowManyWords global string src# string dlm# returns integer
33974>>>>>  local integer count# pos# in_item# len#
33975>>>>>  local string atom#
33975>>>>>  move 0 to count#
33976>>>>>  move 0 to in_item#
33977>>>>>  move (length(src#)) to len#
33978>>>>>  for pos# from 1 to len#
33984>>>>>>
33984>>>>>    mid src# to atom# 1 pos#
33987>>>>>>
33987>>>>>    if in_item# begin
33989>>>>>      if atom# in dlm# move 0 to in_item#
33992>>>>>    end
33992>>>>>>
33992>>>>>    else begin
33993>>>>>      ifnot atom# in dlm# begin
33995>>>>>        increment count#
33996>>>>>        move 1 to in_item#
33997>>>>>      end
33997>>>>>>
33997>>>>>    end
33997>>>>>>
33997>>>>>  loop
33998>>>>>>
33998>>>>>  function_return count#
33999>>>>>end_function
34000>>>>>Function HowManyItems global string src# string dlm# returns integer
34001>>>>>  function_return (HowManyWords(src#,dlm#))
34002>>>>>End_Function
34003>>>>>                            //        source     legal char  item number
34003>>>>>function ExtractItemNeg global string src# string lch# integer itm# returns string
34004>>>>>  local integer count# pos# in_item? len#
34005>>>>>  local string rval# atom#
34005>>>>>  move "" to rval#
34006>>>>>  move 0 to count#
34007>>>>>  move 0 to in_item?
34008>>>>>  move (length(src#)) to len#
34009>>>>>  for pos# from 1 to len#
34015>>>>>>
34015>>>>>    mid src# to atom# 1 pos#
34018>>>>>>
34018>>>>>    if in_item? begin
34020>>>>>      ifnot atom# in lch# move 0 to in_item?
34023>>>>>      else if count# eq itm# append rval# atom#
34027>>>>>    end
34027>>>>>>
34027>>>>>    else begin
34028>>>>>      if atom# in lch# begin
34030>>>>>        increment count#
34031>>>>>        move 1 to in_item?
34032>>>>>        if count# eq itm# move atom# to rval#
34035>>>>>      end
34035>>>>>>
34035>>>>>    end
34035>>>>>>
34035>>>>>  loop
34036>>>>>>
34036>>>>>  function_return rval#
34037>>>>>end_function
34038>>>>>
34038>>>>>// ExtractInteger("123 456 789",0) = 0
34038>>>>>// ExtractInteger("123 456 789",2) = 456
34038>>>>>// ExtractInteger("123 456 789",4) = 0
34038>>>>>
34038>>>>>function ExtractInteger global string str# integer itm# returns integer
34039>>>>>  function_return (integer(ExtractItemNeg(str#,"0123456789",itm#)))
34040>>>>>end_function
34041>>>>>
34041>>>>>function HowManyIntegers global string str# returns integer
34042>>>>>  local integer rval# pos# len# in_int?
34043>>>>>  move 0 to in_int? //in integer?
34044>>>>>  move 0 to rval#
34045>>>>>  move (length(str#)) to len#
34046>>>>>  for pos# from 1 to len#
34052>>>>>>
34052>>>>>    if (mid(str#,1,pos#)) in "0123456789" begin
34054>>>>>      ifnot in_int? begin
34056>>>>>        increment rval#
34057>>>>>        move 1 to in_int?
34058>>>>>      end
34058>>>>>>
34058>>>>>    end
34058>>>>>>
34058>>>>>    else if in_int? move 0 to in_int?
34062>>>>>  loop
34063>>>>>>
34063>>>>>  function_return rval#
34064>>>>>end_function
34065>>>>>
34065>>>>>function IsIntegerPresent global string str# integer int# returns integer
34066>>>>>  local integer max# itm#
34067>>>>>  if str# eq "" function_return 0
34070>>>>>  move (HowManyIntegers(str#)) to max#
34071>>>>>  for itm# from 1 to max#
34077>>>>>>
34077>>>>>    if (ExtractInteger(str#,itm#)=int#) function_return 1
34080>>>>>  loop
34081>>>>>>
34081>>>>>  function_return 0
34082>>>>>end_function
34083>>>>>
34083>>>>>function AddIntegerToString global string str# integer int# returns string
34084>>>>>  function_return (trim(str#+" "+string(int#)))
34085>>>>>end_function
34086>>>>>
34086>>>>>// This function is used to compose a new string from an existing string. This
34086>>>>>// is similar to the way Windows 95 generates 8.3 file names.
34086>>>>>
34086>>>>>//    For example:    StringIncrementId("STURE",8) = "STURE ~1"
34086>>>>>//                    StringIncrementId("STURE ~1",8) = "STURE ~2"
34086>>>>>//                    StringIncrementId("STURE ~2",8) = "STURE ~3"
34086>>>>>//                    etc...
34086>>>>>function StringIncrementId global string id# integer len# returns string
34087>>>>>  local string char#
34088>>>>>  if (mid(id#,1,len#-1)) eq "~" begin
34090>>>>>    move (mid(id#,1,len#)) to char#
34091>>>>>    if (ascii(char#)) lt 93 function_return (overstrike(character(ascii(char#)+1),id#,len#))
34094>>>>>    else function_return ""
34096>>>>>  end
34096>>>>>>
34096>>>>>  function_return (overstrike("~1",id#,len#-1))
34097>>>>>end_function
34098>>>>>
34098>>>>>function StringUppercaseFirstLetters global string str# returns string
34099>>>>>  local integer len# pos# in_word#
34100>>>>>  local string rval# char#
34100>>>>>  move (lowercase(Str#)) to str#
34101>>>>>  move (length(str#)) to len#
34102>>>>>  move 0 to in_word#
34103>>>>>  for pos# from 1 to len#
34109>>>>>>
34109>>>>>    move (mid(str#,1,pos#)) to char#
34110>>>>>    if char# eq "" move 0 to in_word#
34113>>>>>    else begin
34114>>>>>      ifnot in_word# begin
34116>>>>>        uppercase char# to char#
34117>>>>>>
34117>>>>>        move 1 to in_word#
34118>>>>>      end
34118>>>>>>
34118>>>>>    end
34118>>>>>>
34118>>>>>    move (rval#+char#) to rval#
34119>>>>>  loop
34120>>>>>>
34120>>>>>  function_return rval#
34121>>>>>end_function
34122>>>>>
34122>>>>>function StringLeftBut global string str# integer but# returns string
34123>>>>>  function_return (left(str#,length(str#)-but#))
34124>>>>>end_function
34125>>>>>function StringRightBut global string str# integer but# returns string
34126>>>>>  function_return (right(str#,length(str#)-but#))
34127>>>>>end_function
34128>>>>>
34128>>>>>function StringConsistsOf global string src# string tpl# returns integer
34129>>>>>  local integer count# len#
34130>>>>>  trim src# to src#
34131>>>>>>
34131>>>>>  move (length(src#)) to len#
34132>>>>>  for count# from 1 to len#
34138>>>>>>
34138>>>>>    ifnot (mid(src#,1,count#)) in tpl# function_return 0
34141>>>>>  loop
34142>>>>>>
34142>>>>>  function_return 1
34143>>>>>end_function
34144>>>>>
34144>>>>>function RemoveDblBlanks global string str# returns string
34145>>>>>  local integer fin#
34146>>>>>  move 0 to fin#
34147>>>>>  repeat
34147>>>>>>
34147>>>>>    move (replaces("  ",str#," ")) to str#
34148>>>>>    ifnot "  " in str# move 1 to fin#
34151>>>>>  until fin#
34153>>>>>  function_return str#
34154>>>>>end_function
34155>>>>>
34155>>>>>function Byte_ToHex global integer byte# returns string
34156>>>>>  function_return (mid("0123456789ABCDEF",1,byte#/16+1)+mid("0123456789ABCDEF",1,byte# iand 15+1))
34157>>>>>end_function
34158>>>>>
34158>>>>>function Text_RemoveTrailingCr global string str# returns string
34159>>>>>  local integer fin# char#
34160>>>>>  move 0 to fin#
34161>>>>>  repeat
34161>>>>>>
34161>>>>>    if str# eq "" function_return ""
34164>>>>>    if (right(str#,1)=character(10) or right(str#,1)=" " or right(str#,1)=character(13)) move (left(str#,(length(str#)-1))) to str#
34167>>>>>    else move 1 to fin#
34169>>>>>  until fin#
34171>>>>>  function_return str#
34172>>>>>end_function
34173>>>>>
34173>>>>>function Text_RTrim global string str# returns string
34174>>>>>  move (rtrim(replaces(character(255),str#," "))) to str#
34175>>>>>  function_return (Text_RemoveTrailingCr(str#))
34176>>>>>end_function
34177>>>>>
34177>>>>>function Text_Trim global string str# returns string
34178>>>>>  move (trim(replaces(character(255),str#," "))) to str#
34179>>>>>  function_return (Text_RemoveTrailingCr(str#))
34180>>>>>end_function
34181>>>>>
34181>>>>>function Text_Compress global string str# returns string
34182>>>>>  move (replaces(character(10),str#," ")) to str#
34183>>>>>  trim str# to str#
34184>>>>>>
34184>>>>>  move (RemoveDblBlanks(str#)) to str#
34185>>>>>  function_return str#
34186>>>>>end_function
34187>>>>>
34187>>>>>function Text_CompressSubstCr global string str# string new_line# returns string
34188>>>>>  function_return (RemoveDblBlanks(trim(replaces(character(10),Text_RemoveTrailingCr(str#),new_line#))))
34189>>>>>end_function
34190>>>>>
34190>>>>>class cText_Formatter is an array
34191>>>>>  procedure construct_object integer img#
34192>>>>>    forward send construct_object img#
34194>>>>>    property integer pRmargin         public 40
34195>>>>>    property integer pCompress_state  public 0
34196>>>>>    property integer pTrim_state      public 1 // 0=no trim, 1=trim, 2=rtrim
34197>>>>>    property integer pSubst_below_32_state  public 0
34198>>>>>  end_procedure
34199>>>>>
34199>>>>>  procedure add_item.s string str#
34200>>>>>    local integer char#
34201>>>>>    if (pSubst_below_32_state(current_object)) begin
34203>>>>>      for char# from 0 to 31
34209>>>>>>
34209>>>>>        move (replaces(character(char#),str#," ")) to str#
34210>>>>>      loop
34211>>>>>>
34211>>>>>    end
34211>>>>>>
34211>>>>>    set array_value item (item_count(current_object)) to str#
34212>>>>>  end_procedure
34213>>>>>
34213>>>>>  function split_word string str# integer len# returns string
34214>>>>>    local integer pos#
34215>>>>>    local string rval#
34215>>>>>    move (pos("-",str#)) to pos#
34216>>>>>    if (pos# and pos#<=len#) move (replace("-",str#," ")) to rval#
34219>>>>>    else begin
34220>>>>>      move (left(str#,len#)) to rval#
34221>>>>>      move (rval#+" "+replace(rval#,str#,"")) to rval#
34222>>>>>    end
34222>>>>>>
34222>>>>>    function_return rval# // The space in the return value indicates
34223>>>>>  end_function            // where to split the word
34224>>>>>
34224>>>>>  procedure format.s string str#
34225>>>>>    local integer Trim_state# done# pRmargin# word_done# pos# max# len#
34226>>>>>    local string word# line# lf# left# char#
34226>>>>>
34226>>>>>    //pre-format:
34226>>>>>    get pTrim_state to Trim_state#
34227>>>>>    if Trim_state# eq 1 move (Text_Trim(str#)) to str#
34230>>>>>    else if Trim_state# eq 2 move (Text_RTrim(str#)) to str#
34234>>>>>    if (pCompress_state(current_object)) move (Text_Compress(str#)) to str#
34237>>>>>
34237>>>>>    move (character(10)) to lf#
34238>>>>>    get pRmargin to pRmargin#
34239>>>>>    if pRmargin# gt 1 begin // Otherwise nothing makes sense!
34241>>>>>      move 0 to done#
34242>>>>>      move "" to line#
34243>>>>>      move 1 to pos#
34244>>>>>      move (length(str#)) to max#
34245>>>>>      repeat
34245>>>>>>
34245>>>>>
34245>>>>>        move "" to word#
34246>>>>>        move 0 to word_done#
34247>>>>>        repeat
34247>>>>>>
34247>>>>>          if pos# gt max# move 1 to word_done#
34250>>>>>          else begin
34251>>>>>            mid str# to char# 1 pos#
34254>>>>>>
34254>>>>>            if char# eq lf# begin // Line feed
34256>>>>>              if word# eq "" begin
34258>>>>>                move lf# to word#
34259>>>>>                increment pos#
34260>>>>>              end
34260>>>>>>
34260>>>>>              move 1 to word_done#
34261>>>>>            end
34261>>>>>>
34261>>>>>            else begin
34262>>>>>              if char# eq "" begin
34264>>>>>                if word# eq "" increment pos#
34267>>>>>                else move 1 to word_done#
34269>>>>>              end
34269>>>>>>
34269>>>>>              else begin
34270>>>>>                move (word#+char#) to word#
34271>>>>>                increment pos#
34272>>>>>              end
34272>>>>>>
34272>>>>>            end
34272>>>>>>
34272>>>>>          end
34272>>>>>>
34272>>>>>        until word_done#
34274>>>>>
34274>>>>>        if word# eq "" move 1 to done# // We're done!
34277>>>>>        else begin
34278>>>>>          if word# eq lf# begin // If hard return:
34280>>>>>            send add_item.s line#
34281>>>>>            move "" to line#
34282>>>>>          end
34282>>>>>>
34282>>>>>          else begin //
34283>>>>>            if (length(line#)+length(word#)+1) gt pRmargin# begin // Soft new line
34285>>>>>              if line# ne "" begin
34287>>>>>                send add_item.s line# // Could be that word is longer that pRmargin
34288>>>>>                move "" to line#
34289>>>>>              end
34289>>>>>>
34289>>>>>              if (length(word#)) gt pRmargin# begin // Word IS longer that line!
34291>>>>>                repeat
34291>>>>>>
34291>>>>>                  if line# eq "" move (pRmargin#-1) to len#
34294>>>>>                  else move (pRmargin#-length(line#)-2) to len#
34296>>>>>                  move (split_word(current_object,word#,len#)) to word#
34297>>>>>                  move (ExtractItem(word#," ",1)) to left#
34298>>>>>                  move (ExtractItem(word#," ",2)) to word#
34299>>>>>                  if word# eq "" move left# to line#
34302>>>>>                  else send add_item.s (left#+"-")
34304>>>>>                until word# eq ""
34306>>>>>              end
34306>>>>>>
34306>>>>>              else move word# to line#
34308>>>>>            end
34308>>>>>>
34308>>>>>            else begin
34309>>>>>              if line# ne "" move (line#+" "+word#) to line# // add word to line
34312>>>>>              else move word# to line#
34314>>>>>            end
34314>>>>>>
34314>>>>>          end
34314>>>>>>
34314>>>>>        end
34314>>>>>>
34314>>>>>      until done#
34316>>>>>      if line# ne "" send add_item.s line#
34319>>>>>    end
34319>>>>>>
34319>>>>>  end_procedure
34320>>>>>end_class
34321>>>>>
34321>>>>>object oText_Formatter is a cText_Formatter no_image
34323>>>>>  set pSubst_below_32_state to true
34324>>>>>end_object
34325>>>>>
34325>>>>>function Text_Format.sii global string str# integer width# integer reset# returns integer
34326>>>>>  local integer obj#
34327>>>>>  move (oText_Formatter(current_object)) to obj#
34328>>>>>  if reset# send delete_data to obj#
34331>>>>>  set pRmargin of obj# to width#
34332>>>>>  send format.s to obj# str#
34333>>>>>  function_return (item_count(obj#))
34334>>>>>end_function
34335>>>>>
34335>>>>>function Text_FormattedLine.i global integer line# returns string
34336>>>>>  function_return (string_value(oText_Formatter(current_object),line#))
34337>>>>>end_function
34338>>>
34338>>>//desktop_section
34338>>>  object oGridMoveSelectedListItems is an cArray no_image
34340>>>  end_object
34341>>>//end_desktop_section
34341>>>
34341>>>//> Procedure Grid_CopySelectedListItems is meant for List objects or grid's
34341>>>//> with only one column
34341>>>procedure Grid_CopySelectedListItems global integer source_grid# integer target_grid# integer all_items# integer delete_from_source#
34342>>>  local integer max# itm# select# obj# delete_itm#
34343>>>  local string fn#
34343>>>  move (oGridMoveSelectedListItems(current_object)) to obj#
34344>>>  get item_count of source_grid# to max#
34345>>>  for itm# from 0 to (max#-1) // Copy selected items
34351>>>>
34351>>>    ifnot all_items# get select_state of source_grid# item itm# to select#
34354>>>    if (select# or all_items#) begin
34356>>>      get value of source_grid# item itm# to fn#
34357>>>      send add_item to target_grid# msg_none fn#
34358>>>      set value of obj# item (item_count(obj#)) to itm#
34359>>>    end
34359>>>>
34359>>>  loop
34360>>>>
34360>>>  if all_items# send delete_data to source_grid#
34363>>>  else begin
34364>>>    get item_count of obj# to max#
34365>>>    for_ex itm# from (max#-1) down_to 0 // Remove selected items
34372>>>      get value of obj# item itm# to delete_itm#
34373>>>      send delete_item to source_grid# delete_itm#
34374>>>    loop
34375>>>>
34375>>>  end
34375>>>>
34375>>>  send delete_data to obj#
34376>>>  send sort_items to source_grid#
34377>>>  send sort_items to target_grid#
34378>>>  set dynamic_update_state of source_grid# to true
34379>>>  set dynamic_update_state of target_grid# to true
34380>>>end_procedure
34381>>>
34381>>>//> Function Grid_Columns takes the object ID of a Grid or List
34381>>>//> object and returns the number of columns in that object.
34381>>>function Grid_Columns global integer obj# returns integer
34382>>>  local integer lw#
34383>>>  get matrix_size of obj# to lw#
34384>>>  function_return (low(lw#))
34385>>>end_function
34386>>>
34386>>>function Grid_CurrentColumn global integer obj# returns integer
34387>>>  local integer columns# ci# base#
34388>>>  get Grid_Columns obj# to columns#
34389>>>  get current_item of obj# to ci#
34390>>>  move ((ci#/columns#)*columns#) to base#
34391>>>  function_return (ci#-base#)
34392>>>end_function
34393>>>
34393>>>function Grid_BaseItem global integer obj# returns integer
34394>>>  local integer columns# ci#
34395>>>//#IFDEF IS$WINDOWS
34395>>>  get Grid_Columns obj# to columns#
34396>>>  get current_item of obj# to ci#
34397>>>  function_return ((ci#/columns#)*columns#)
34398>>>//#ELSE
34398>>>//#ENDIF
34398>>>end_function
34399>>>
34399>>>function Grid_ItemBaseItem global integer obj# integer ci# returns integer
34400>>>  local integer columns#
34401>>>  get Grid_Columns obj# to columns#
34402>>>  function_return ((ci#/columns#)*columns#)
34403>>>end_function
34404>>>
34404>>>//> Set Entry_State for all items in a Grid
34404>>>procedure Grid_SetEntryState global integer obj# integer st#
34405>>>  local integer itm# max#
34406>>>  get item_count of obj# to max#
34407>>>  for itm# from 0 to (max#-1)
34413>>>>
34413>>>    set entry_state of obj# item itm# to st#
34414>>>  loop
34415>>>>
34415>>>end_procedure
34416>>>
34416>>>//> What is the number of the base item of row row#
34416>>>function Grid_RowBaseItem global integer obj# integer row# returns integer
34417>>>  local integer columns#
34418>>>  get Grid_Columns obj# to columns#
34419>>>  function_return (row#*columns#)
34420>>>end_function
34421>>>
34421>>>//> Return the number of the row that includes the current_item
34421>>>function Grid_CurrentRow global integer obj# returns integer
34422>>>  local integer ci#
34423>>>  get current_item of obj# to ci#
34424>>>  function_return (ci#/Grid_Columns(obj#))
34425>>>end_function
34426>>>
34426>>>//> Return the number of rows currently in the Grid
34426>>>function Grid_RowCount global integer obj# returns integer
34427>>>  local integer columns#
34428>>>  get Grid_Columns obj# to columns#
34429>>>  function_return (item_count(obj#)/columns#)
34430>>>end_function
34431>>>
34431>>>procedure Grid_SwapRows global integer obj# integer row1# integer row2#
34432>>>  local integer base1# base2# itm# max#
34433>>>  local string str#
34433>>>  get Grid_RowBaseItem obj# row1# to base1#
34434>>>  get Grid_RowBaseItem obj# row2# to base2#
34435>>>  get Grid_Columns obj# to max#
34436>>>  for itm# from 0 to (max#-1)
34442>>>>
34442>>>    // value
34442>>>    get value of obj# item (base1#+itm#) to str#
34443>>>    set value of obj# item (base1#+itm#) to (value(obj#,base2#+itm#))
34444>>>    set value of obj# item (base2#+itm#) to str#
34445>>>    // entry_state
34445>>>    get entry_state of obj# item (base1#+itm#) to str#
34446>>>    set entry_state of obj# item (base1#+itm#) to (entry_state(obj#,base2#+itm#))
34447>>>    set entry_state of obj# item (base2#+itm#) to str#
34448>>>      // color
34448>>>      get itemcolor of obj# item (base1#+itm#) to str#
34449>>>      set itemcolor of obj# item (base1#+itm#) to (itemcolor(obj#,base2#+itm#))
34450>>>      set itemcolor of obj# item (base2#+itm#) to str#
34451>>>    // checkbox_item_state
34451>>>    get checkbox_item_state of obj# item (base1#+itm#) to str#
34452>>>    set checkbox_item_state of obj# item (base1#+itm#) to (checkbox_item_state(obj#,base2#+itm#))
34453>>>    set checkbox_item_state of obj# item (base2#+itm#) to str#
34454>>>    // aux_value
34454>>>    get aux_value of obj# item (base1#+itm#) to str#
34455>>>    set aux_value of obj# item (base1#+itm#) to (aux_value(obj#,base2#+itm#))
34456>>>    set aux_value of obj# item (base2#+itm#) to str#
34457>>>    // select_state
34457>>>    get select_state of obj# item (base1#+itm#) to str#
34458>>>    set select_state of obj# item (base1#+itm#) to (select_state(obj#,base2#+itm#))
34459>>>    set select_state of obj# item (base2#+itm#) to str#
34460>>>  loop
34461>>>>
34461>>>end_procedure
34462>>>
34462>>>
34462>>>// Use like this (from within a Grid object):
34462>>>//
34462>>>//   procedure MoveItemUp
34462>>>//     send Grid_SwapCurrentRowUp self
34462>>>//   end_procedure
34462>>>//   procedure MoveItemDown
34462>>>//     send Grid_SwapCurrentRowDown self
34462>>>//   end_procedure
34462>>>//   on_key key_ctrl+key_up_arrow   send MoveItemUp
34462>>>//   on_key key_ctrl+key_down_arrow send MoveItemDown
34462>>>//
34462>>>procedure Grid_SwapCurrentRowUp global integer obj#
34463>>>  local integer cr# ci#
34464>>>  get Grid_CurrentRow obj# to cr#
34465>>>  if cr# gt 0 begin
34467>>>    get Current_Item of obj# to ci#
34468>>>    send Grid_SwapRows obj# cr# (cr#-1)
34469>>>    set Current_Item of obj# to (ci#-Grid_Columns(obj#))
34470>>>  end
34470>>>>
34470>>>end_procedure
34471>>>procedure Grid_SwapCurrentRowDown global integer obj#
34472>>>  local integer cr# ci#
34473>>>  get Grid_CurrentRow obj# to cr#
34474>>>  if cr# lt (Grid_RowCount(obj#)-1) begin
34476>>>    get Current_Item of obj# to ci#
34477>>>    send Grid_SwapRows obj# cr# (cr#+1)
34478>>>    set Current_Item of obj# to (ci#+Grid_Columns(obj#))
34479>>>  end
34479>>>>
34479>>>end_procedure
34480>>>
34480>>>//desktop_section
34480>>>   Use FieldInf     // Global field info objects and abstract field types
INCLUDING FILE: FIELDINF.PKG
34480>>>>>//**********************************************************************
34480>>>>>// Use FieldInf     // Global field info objects
34480>>>>>//
34480>>>>>// By Sture Andersen
34480>>>>>//
34480>>>>>// Create:  Wed  28-01-1997
34480>>>>>// Update:  Tue  11-02-1997 - Abstract field thing added
34480>>>>>//          Thu  20-02-1997 - Register_abstract_field_label may now be
34480>>>>>//                            be used with only one argument (does nothing)
34480>>>>>//          Thu  04-03-1997 - ascii_window and date_window are now defined
34480>>>>>//                            if not already (for use with CM)
34480>>>>>//          Tue  22-04-1997 - File_Display_Name_Array added
34480>>>>>//          Tue  29-04-1997 - Changed REGISTER_FIELD_LABEL command
34480>>>>>//          Wed  04-02-1998 - Functions gl_generic_form_margin and
34480>>>>>//                            gl_generic_form_datatype added
34480>>>>>//          Fri  29-01-1999 - DataDictionary_Class property moved to here
34480>>>>>//                            from dynamo.utl.
34480>>>>>//          Wed  17-02-1999 - Class cVirtualFields added.
34480>>>>>//          Mon  15-03-1999 - DataDictionary classes are now used when
34480>>>>>//                            determining field labels
34480>>>>>//
34480>>>>>// Purpose: To provide a global mechanism for registering field labels.
34480>>>>>//          If used with APS, db-controls will automatically obtain their
34480>>>>>//          labels from here, unless they are set manually or they are
34480>>>>>//          specifically told not to.
34480>>>>>//
34480>>>>>//          The package also let's you define abstract field types for
34480>>>>>//          use with non-db controls or for overriding the definition of
34480>>>>>//          DBMS fields. A classical example of the latter is that while
34480>>>>>//          your data field is defined to have 4 decimal points you
34480>>>>>//          really want the field to display with only 3.
34480>>>>>//
34480>>>>>//          You set these global informations using the four commands
34480>>>>>//          listed here:
34480>>>>>//
34480>>>>>//      1   REGISTER_FIELD_LABEL dffile.field <field label> ;
34480>>>>>//                                   [<grid label> [<status help>]]
34480>>>>>//
34480>>>>>//      2   REGISTER_ABSTRACT_FIELD_TYPE <un-typed abstract_id> ;
34480>>>>>//                                       <length> <data_type>
34480>>>>>//
34480>>>>>//      3   MODIFY_FIELD_TYPE dffile.field <abstract_id>
34480>>>>>//
34480>>>>>//      4   REGISTER_FILE_ALIAS <master_dffile> <shadow_dffile>
34480>>>>>//
34480>>>>>//          As you can see it is possible to register status help lines.
34480>>>>>//          This was implemented since it felt to natural to do so. APS
34480>>>>>//          will make use of such registrations only if used with the
34480>>>>>//          aps.DataDictionary and only if status help has not been
34480>>>>>//          registered the standard DD way.
34480>>>>>//
34480>>>>>//
34480>>>>>// Note:    This package makes permanent use of compile-time variable J$.
34480>>>>>//          If this is in conflict with your application source it is
34480>>>>>//          easily changed since it is only referenced from within this
34480>>>>>//          file.
34480>>>>>//
34480>>>>>//**********************************************************************
34480>>>>>
34480>>>>>Use ui
34480>>>>>Use Seq_Chnl     // Defines global sequential device management operations (DAC)
34480>>>>>Use Array.utl    // Item_Property command
34480>>>>>Use Macros.utl   // Various macros (DESKTOP_SECTION)
34480>>>>>
34480>>>>>class cFieldInfoStuff is an array
34481>>>>>  function array_id.i integer file# returns integer
34482>>>>>    local integer rval#
34483>>>>>    get value item file# to rval#
34484>>>>>    ifnot rval# begin
34486>>>>>      object fldinf.array is an array
34488>>>>>        move current_object to rval#
34489>>>>>      end_object
34490>>>>>      set value item file# to rval#
34491>>>>>    end
34491>>>>>>
34491>>>>>    function_return rval#
34492>>>>>  end_function
34493>>>>>  procedure set string_value.ii integer file# integer field# string str#
34494>>>>>    set value of (array_id.i(current_object,file#)) item field# to str#
34495>>>>>  end_procedure
34496>>>>>  function string_value.ii integer file# integer field# returns string
34497>>>>>    local integer arr#
34498>>>>>    get value item file# to arr#
34499>>>>>    if arr# function_return (value(arr#,field#))
34502>>>>>    function_return ""
34503>>>>>  end_function
34504>>>>>  procedure set integer_value.ii integer file# integer field# integer int#
34505>>>>>    set value of (array_id.i(current_object,file#)) item field# to int#
34506>>>>>  end_procedure
34507>>>>>  function integer_value.ii integer file# integer field# returns integer
34508>>>>>    local integer arr#
34509>>>>>    get value item file# to arr#
34510>>>>>    if arr# function_return (value(arr#,field#))
34513>>>>>    function_return 0
34514>>>>>  end_function
34515>>>>>
34515>>>>>  //> The purpose of the make_alias procedure is to redirect references
34515>>>>>  //> to file number <alias#> refer to file number <master#> instead.
34515>>>>>  procedure make_alias integer master# integer alias#
34516>>>>>    local integer master_arr#
34517>>>>>    get array_id.i master# to master_arr#
34518>>>>>    set value item alias# to master_arr#
34519>>>>>  end_procedure
34520>>>>>end_class
34521>>>>>
34521>>>>>integer field_labels_array#  grid_labels_array# status_help_array#
34521>>>>>integer form_datatype_array# form_margin_array# abstract_array#
34521>>>>>
34521>>>>>object field_labels_array is a cFieldInfoStuff
34523>>>>>  move current_object to field_labels_array#
34524>>>>>end_object
34525>>>>>object grid_labels_array is a cFieldInfoStuff
34527>>>>>  move current_object to grid_labels_array#
34528>>>>>end_object
34529>>>>>object status_help_array is a cFieldInfoStuff
34531>>>>>  move current_object to status_help_array#
34532>>>>>end_object
34533>>>>>object form_datatype_array is a cFieldInfoStuff
34535>>>>>  move current_object to form_datatype_array#
34536>>>>>end_object
34537>>>>>object form_margin_array is a cFieldInfoStuff
34539>>>>>  move current_object to form_margin_array#
34540>>>>>end_object
34541>>>>>object abtract_array is a cFieldInfoStuff
34543>>>>>  // If a DBMS field (file,field) has an entry in this array it means
34543>>>>>  // that its corresponding form_datatype and form_margin should be
34543>>>>>  // looked up in the other arrays rather than using its original values.
34543>>>>>  move current_object to abstract_array#
34544>>>>>end_object
34545>>>>>object capslocked_array is a cFieldInfoStuff
34547>>>>>//  move current_object to abstract_array#
34547>>>>>end_object
34548>>>>>
34548>>>>>// Prefix "gl_" means "global"
34548>>>>>function gl_field_label for desktop integer file# integer field# returns string
34549>>>>>  local string rval#
34550>>>>>  move (string_value.ii(field_labels_array#,file#,field#)) to rval#
34551>>>>>  if rval# eq "" begin
34553>>>>>    get_attribute df_field_name of file# field# to rval#
34556>>>>>    move (replaces("_",rval#," ")) to rval#
34557>>>>>    move (lowercase(rval#)) to rval#
34558>>>>>    move (overstrike(uppercase(left(rval#,1)),rval#,1)) to rval#
34559>>>>>    set string_value.ii of field_labels_array# file# field# to rval#
34560>>>>>  end
34560>>>>>>
34560>>>>>  function_return rval#
34561>>>>>end_function
34562>>>>>function gl_grid_label for desktop integer file# integer field# returns string
34563>>>>>  local string rval#
34564>>>>>  move (string_value.ii(grid_labels_array#,file#,field#)) to rval#
34565>>>>>  if rval# eq "" begin
34567>>>>>    get_attribute df_field_name of file# field# to rval#
34570>>>>>    move (replaces("_",rval#," ")) to rval#
34571>>>>>    move (lowercase(rval#)) to rval#
34572>>>>>    move (overstrike(uppercase(left(rval#,1)),rval#,1)) to rval#
34573>>>>>    set string_value.ii of grid_labels_array# file# field# to rval#
34574>>>>>  end
34574>>>>>>
34574>>>>>  function_return rval#
34575>>>>>end_function
34576>>>>>function gl_status_help for desktop integer file# integer field# returns string
34577>>>>>  function_return (string_value.ii(status_help_array#,file#,field#))
34578>>>>>end_function
34579>>>>>function gl_datatype for desktop integer file# integer field# returns integer
34580>>>>>  function_return (integer_value.ii(form_datatype_array#,file#,field#))
34581>>>>>end_function
34582>>>>>function gl_margin for desktop integer file# integer field# returns integer
34583>>>>>  function_return (integer_value.ii(form_margin_array#,file#,field#))
34584>>>>>end_function
34585>>>>>function gl_abstract for desktop integer file# integer field# returns integer
34586>>>>>  function_return (integer_value.ii(abstract_array#,file#,field#))
34587>>>>>end_function
34588>>>>>
34588>>>>>
34588>>>>>// REGISTER_FIELD_LABEL dffile.field <field label> ;
34588>>>>>//                              [<grid label> [<status help>]]
34588>>>>>
34588>>>>>
34588>>>>>
34588>>>>>//  REGISTER_ABSTRACT_FIELD_TYPE <un-typed name> ;
34588>>>>>//                                            <margin> <data_type>
34588>>>>>
34588>>>>>
34588>>>>>
34588>>>>>//  REGISTER_ABSTRACT_FIELD_LABEL <previously un-typed name> ;
34588>>>>>//                             <field label> [<grid label> [<status help>]]
34588>>>>>//
34588>>>>>//  Registrations done with the REGISTER_ABSTRACT_FIELD_LABEL are not
34588>>>>>//  currently used by APS
34588>>>>>
34588>>>>>
34588>>>>>
34588>>>>>//  MODIFY_FIELD_TYPE dffile.field <abstract_id>
34588>>>>>
34588>>>>>
34588>>>>>//  REGISTER_FILE_ALIAS <master_dffile> <shadow_dffile>
34588>>>>>
34588>>>>>
34588>>>>>
34588>>>>>  function gl_generic_form_datatype global integer file# integer field# returns integer
34589>>>>>    local integer type# rval#
34590>>>>>    get_attribute DF_FIELD_TYPE of file# field# to type#
34593>>>>>    if type# eq DF_ASCII function_return ascii_window
34596>>>>>    if type# eq DF_DATE  function_return date_window
34599>>>>>    if type# eq DF_BCD begin
34601>>>>>      get_attribute DF_FIELD_PRECISION of file# field# to rval#
34604>>>>>      function_return rval#
34605>>>>>    end
34605>>>>>>
34605>>>>>    function_return ascii_window // DF_OVERLAP DF_TEXT DF_BINARY
34606>>>>>  end_function
34607>>>>>
34607>>>>>  function gl_generic_form_margin global integer file# integer field# returns integer
34608>>>>>    local integer datatype# len#
34609>>>>>    move (gl_generic_form_datatype(file#,field#)) to datatype#
34610>>>>>    if datatype# eq date_window function_return 10
34613>>>>>    get_attribute DF_FIELD_LENGTH of file# field# to len#
34616>>>>>    if datatype# eq ascii_window function_return len#
34619>>>>>    function_return (len#+1) // Room for comma
34620>>>>>  end_function
34621>>>>>
34621>>>>>  function gl_effective_form_datatype global integer file# integer field# returns integer
34622>>>>>    local integer abstract#
34623>>>>>    get gl_abstract file# field# to abstract#
34624>>>>>    if abstract# function_return (gl_datatype(current_object,0,abstract#))
34627>>>>>    function_return (gl_generic_form_datatype(file#,field#))
34628>>>>>  end_function
34629>>>>>  function gl_effective_form_margin global integer file# integer field# returns integer
34630>>>>>    local integer rval#
34631>>>>>    get gl_margin file# field# to rval#
34632>>>>>    if rval# function_return rval#
34635>>>>>    function_return (gl_generic_form_margin(file#,field#))
34636>>>>>  end_function
34637>>>>>
34637>>>>>register_abstract_field_type aft_ascii2       2 ascii_window
34639>>>>>register_abstract_field_type aft_ascii3       3 ascii_window
34641>>>>>register_abstract_field_type aft_ascii4       4 ascii_window
34643>>>>>register_abstract_field_type aft_ascii5       5 ascii_window
34645>>>>>register_abstract_field_type aft_ascii6       6 ascii_window
34647>>>>>register_abstract_field_type aft_ascii10     10 ascii_window
34649>>>>>register_abstract_field_type aft_ascii15     15 ascii_window
34651>>>>>register_abstract_field_type aft_ascii20     20 ascii_window
34653>>>>>register_abstract_field_type aft_ascii25     25 ascii_window
34655>>>>>register_abstract_field_type aft_ascii30     30 ascii_window
34657>>>>>register_abstract_field_type aft_ascii35     35 ascii_window
34659>>>>>register_abstract_field_type aft_ascii40     40 ascii_window
34661>>>>>register_abstract_field_type aft_ascii50     50 ascii_window
34663>>>>>register_abstract_field_type aft_ascii80     80 ascii_window
34665>>>>>register_abstract_field_type aft_numeric1.2   4 2 // Length 4, 2 decimal points
34667>>>>>register_abstract_field_type aft_numeric2.0   2 0 // Length 2, 0 decimal points
34669>>>>>register_abstract_field_type aft_numeric2.1   4 1 // Length 4, 1 decimal points
34671>>>>>register_abstract_field_type aft_numeric2.2   4 2 // Length 4, 1 decimal points
34673>>>>>register_abstract_field_type aft_numeric3.0   3 0 // Length 3, 0 decimal points
34675>>>>>register_abstract_field_type aft_numeric4.0   4 0 // Length 4, 0 decimal points
34677>>>>>register_abstract_field_type aft_numeric4.2   7 2 // Length 7, 2 decimal points
34679>>>>>register_abstract_field_type aft_numeric6.0   6 0 // Length 6, 0 decimal points
34681>>>>>register_abstract_field_type aft_numeric8.0   8 0 // Length 8, 0 decimal points
34683>>>>>register_abstract_field_type aft_numeric10.0 10 0 // Length 10, 0 decimal points
34685>>>>>register_abstract_field_type aft_date        10 date_window
34687>>>>>register_abstract_field_type aft_boolean      1 0
34689>>>>>
34689>>>>>
34689>>>>>// An extra feature allows specifying a replacement to the user display name
34689>>>>>// of files (df_File_Display_Name). APS makes no use of such registrations.
34689>>>>>//
34689>>>>>//   REGISTER_FILE_DISPLAY_NAME dffile <string>
34689>>>>>
34689>>>>>desktop_section
34694>>>>> object File_Display_Name_Array is an array
34696>>>>> end_object
34697>>>>>end_desktop_section
34699>>>>>procedure set File_Display_Name global integer file# string name#
34700>>>>>  set value of (File_Display_Name_Array(current_object)) item file# to name#
34701>>>>>end_procedure
34702>>>>>function File_Display_Name global integer file# returns string
34703>>>>>  local string rval#
34704>>>>>  move (value(File_Display_Name_Array(current_object),file#)) to rval#
34705>>>>>  if rval# eq "" begin
34707>>>>>    get_attribute df_File_Display_Name of file# to rval#
34710>>>>>    set File_Display_Name file# to rval#
34711>>>>>  end
34711>>>>>>
34711>>>>>  function_return rval#
34712>>>>>end_function
34713>>>>>
34713>>>>>
34713>>>>>// In order for the aps_ObjectDynamo class to be able to use the
34713>>>>>// generic DD-classes a few lines is needed that will allow us to
34713>>>>>// register which classes to use when creating DDO's for the various
34713>>>>>// data files.
34713>>>>>//
34713>>>>>// Use like this:
34713>>>>>//
34713>>>>>//   set DataDictionary_Class OrderHdr.file_number to U_OrderHdr_DD
34713>>>>>//
34713>>>>>
34713>>>>>desktop_section
34718>>>>> object oDataDictionary_Class_Array is an array
34720>>>>> end_object
34721>>>>>end_desktop_section
34723>>>>>function DataDictionary_Class global integer file# returns integer
34724>>>>>  function_return (value(oDataDictionary_Class_Array(current_object),file#))
34725>>>>>end_function
34726>>>>>procedure set DataDictionary_Class global integer file# integer class#
34727>>>>>  set value of (oDataDictionary_Class_Array(current_object)) item file# to class#
34728>>>>>end_procedure
34729>>>>>
34729>>>>>desktop_section
34734>>>>> object oDataDictionary_Object_Array is an array
34736>>>>> end_object
34737>>>>>end_desktop_section
34739>>>>>function DataDictionary_Object global integer file# returns integer
34740>>>>>  function_return (value(oDataDictionary_Object_Array(current_object),file#))
34741>>>>>end_function
34742>>>>>procedure set DataDictionary_Object global integer file# integer obj#
34743>>>>>  set value of (oDataDictionary_Object_Array(current_object)) item file# to obj#
34744>>>>>end_procedure
34745>>>>>
34745>>>>>function iDD_Object global integer file# returns integer
34746>>>>>  local integer rval# class# current_object#
34747>>>>>  get DataDictionary_Object file# to rval#
34748>>>>>  ifnot rval# begin
34750>>>>>    get DataDictionary_Class file# to class#
34751>>>>>    if class# begin
34753>>>>>      name class# U_fieldinf_class             // Cannot be understoodÄÄÄÄÄ¿
34753>>>>>      move current_object to current_object#   // Push current_object       ³
34754>>>>>      move desktop to current_object           // Create at desktop         ³
34755>>>>>      object dynamo_object is a fieldinf_class // Create an object of classÄÙ
34757>>>>>        move current_object to rval#           // Get the object ID to rval#
34758>>>>>      end_object                               //
34759>>>>>      move current_object# to current_object   // Pop current_object
34760>>>>>      set DataDictionary_Object file# to rval# // Register the new object
34761>>>>>    end
34761>>>>>>
34761>>>>>  end
34761>>>>>>
34761>>>>>  function_return rval#
34762>>>>>end_function
34763>>>>>
34763>>>>>class cVirtualFields is an array
34764>>>>>  procedure construct_object integer img#
34765>>>>>    forward send construct_object img#
34767>>>>>    set delegation_mode to delegate_to_parent
34768>>>>>    property integer pMainFile              public 0
34769>>>>>    property integer private.pCurrentRecord public -1
34770>>>>>    property string  pUserName              public "Un-named"
34771>>>>>  end_procedure
34772>>>>>  item_property_list
34772>>>>>    item_property integer piFieldActive.i
34772>>>>>    item_property string  psFieldLabel.i
34772>>>>>    item_property string  psFieldLabel_Short.i
34772>>>>>    item_property integer piFieldType.i
34772>>>>>    item_property integer piFieldLength.i
34772>>>>>    item_property integer piFieldDecPoint.i
34772>>>>>    item_property integer piFieldCapslock.i
34772>>>>>    item_property integer piFieldLoadMessage.i
34772>>>>>    item_property integer piFieldLoadObject.i
34772>>>>>    item_property string  psFieldValue.i
34772>>>>>    item_property integer piFieldDirty.i
34772>>>>>  end_item_property_list cVirtualFields // When in class, class neame must be repeated here
34856>>>>>  procedure SetAllFieldsDirty integer state#
34857>>>>>    local integer max# field#
34858>>>>>    get row_count to max#
34859>>>>>    for field# from 0 to (max#-1)
34865>>>>>>
34865>>>>>      set piFieldDirty.i field# to state#
34866>>>>>    loop
34867>>>>>>
34867>>>>>  end_procedure
34868>>>>>  procedure set pCurrentRecord integer rec#
34869>>>>>    local integer field# prev_rec#
34870>>>>>    get private.pCurrentRecord to prev_rec#
34871>>>>>    if rec# ne prev_rec# send SetAllFieldsDirty dftrue
34874>>>>>    set private.pCurrentRecord to prev_rec#
34875>>>>>  end_procedure
34876>>>>>  function pCurrentRecord returns integer
34877>>>>>    function_return (private.pCurrentRecord(current_object))
34878>>>>>  end_function
34879>>>>>  procedure LoadFieldValue integer field#
34880>>>>>    local integer get# obj#
34881>>>>>    local string str#
34881>>>>>    get piFieldLoadMessage.i field# to get#
34882>>>>>    get piFieldLoadObject.i  field# to obj#
34883>>>>>    if obj# get get# of obj# to str#
34886>>>>>    else get get# to str#
34888>>>>>    set psFieldValue.i field# to str#
34889>>>>>    set piFieldDirty.i field# to dffalse
34890>>>>>  end_procedure
34891>>>>>  procedure CheckCurrentRecord
34892>>>>>    local integer file# rec#
34893>>>>>    get pMainFile to file#
34894>>>>>    if file# begin
34896>>>>>      get_field_value file# 0 to rec#
34899>>>>>      if rec# ne (private.pCurrentRecord(current_object)) set pCurrentRecord to rec#
34902>>>>>    end
34902>>>>>>
34902>>>>>  end_procedure
34903>>>>>  function sFieldValue.i integer field# returns string
34904>>>>>    send CheckCurrentRecord
34905>>>>>    if (piFieldDirty.i(current_object,field#)) send LoadFieldValue field#
34908>>>>>    function_return (psFieldValue.i(current_object,field#))
34909>>>>>  end_function
34910>>>>>  procedure define_field integer field# string Label# string Label_Short# integer Type# integer Length# integer DecPoint# integer LoadMessage# integer LoadObjectTmp#
34911>>>>>    local integer LoadObject#
34912>>>>>    if num_arguments gt 7 move LoadObjectTmp# to LoadObject#
34915>>>>>    else move 0 to LoadObject#
34917>>>>>    set psFieldLabel.i field# to Label#
34918>>>>>
34918>>>>>    if Label_Short# ne "" ;         set psFieldLabel_Short.i field# to Label_Short#
34921>>>>>    else set psFieldLabel_Short.i field# to Label#
34923>>>>>
34923>>>>>    set piFieldType.i        field# to Type#
34924>>>>>    set piFieldLength.i      field# to Length#
34925>>>>>    set piFieldDecPoint.i    field# to DecPoint#
34926>>>>>    set piFieldLoadMessage.i field# to LoadMessage#
34927>>>>>    set piFieldLoadObject.i  field# to LoadObject#
34928>>>>>    set piFieldDirty.i       field# to dftrue
34929>>>>>    set piFieldActive.i      field# to dftrue
34930>>>>>    set piFieldCapslock.i    field# to dffalse
34931>>>>>  end_procedure
34932>>>>>end_class
34933>>>>>
34933>>>>>integer oFieldInf_VitualFields#
34933>>>>>object oFieldInf_VitualFields is an array
34935>>>>>  move current_object to oFieldInf_VitualFields#
34936>>>>>end_object
34937>>>>>
34937>>>>>function FieldInf_VirtualFields_Object global integer file# returns integer
34938>>>>>  function_return (value(oFieldInf_VitualFields#,file#))
34939>>>>>end_function
34940>>>>>procedure set FieldInf_VirtualFields_Object global integer file# integer value#
34941>>>>>  set value of (oFieldInf_VitualFields#) item file# to value#
34942>>>>>end_procedure
34943>>>>>
34943>>>>>function FieldInf_FieldType global integer file# integer field# returns integer
34944>>>>>  local integer fieldtype#
34945>>>>>  if field# lt 256 get_attribute DF_FIELD_TYPE of file# field# to fieldtype#
34950>>>>>  else move (piFieldType.i(FieldInf_VirtualFields_Object(file#),field#-256)) to fieldtype#
34952>>>>>  function_return fieldtype#
34953>>>>>end_function
34954>>>>>function FieldInf_FieldValue global integer file# integer field# returns string
34955>>>>>  local integer fi# fn#
34956>>>>>  local string rval#
34956>>>>>  move fieldindex to fi#
34957>>>>>  move fieldnumber to fn#
34958>>>>>  if field# lt 256 get_field_value file# field# to rval#
34963>>>>>  else move (sFieldValue.i(FieldInf_VirtualFields_Object(file#),field#-256)) to rval#
34965>>>>>  move fi#  to fieldindex
34966>>>>>  move fn# to fieldnumber
34967>>>>>  function_return rval#
34968>>>>>end_function
34969>>>>>function FieldInf_DecPoints global integer file# integer field# returns string
34970>>>>>  local integer rval#
34971>>>>>//  if field# lt 256 get_attribute DF_FIELD_PRECISION of file# field# to rval#
34971>>>>>  if field# lt 256 get gl_effective_form_datatype file# field# to rval#
34974>>>>>  else move (piFieldDecPoint.i(FieldInf_VirtualFields_Object(file#),field#-256)) to rval#
34976>>>>>  function_return rval#
34977>>>>>end_function
34978>>>>>function FieldInf_FieldLabel_Long global integer file# integer field# returns string
34979>>>>>  local integer dd#
34980>>>>>  local string rval#
34980>>>>>  move (string_value.ii(field_labels_array#,file#,field#)) to rval#
34981>>>>>  if field# lt 256 begin
34983>>>>>    if rval# eq "" begin // No global label was assigned
34985>>>>>        get iDD_Object file# to dd#
34986>>>>>        if dd# get Field_Label_Long of dd# field# to rval#
34989>>>>>        if rval# eq "" get gl_field_label file# field# to rval#
34992>>>>>    end
34992>>>>>>
34992>>>>>  end
34992>>>>>>
34992>>>>>  else move (psFieldLabel.i(FieldInf_VirtualFields_Object(file#),field#-256)) to rval#
34994>>>>>  function_return rval#
34995>>>>>end_function
34996>>>>>function FieldInf_FieldLabel_Short global integer file# integer field# returns string
34997>>>>>  local integer dd#
34998>>>>>  local string rval#
34998>>>>>  if field# lt 256 begin
35000>>>>>    move (string_value.ii(grid_labels_array#,file#,field#)) to rval#
35001>>>>>    if rval# eq "" begin // No global label was assigned
35003>>>>>        get iDD_Object file# to dd#
35004>>>>>        if dd# get Field_Label_Short of dd# field# to rval#
35007>>>>>        if rval# eq "" get gl_grid_label file# field# to rval#
35010>>>>>    end
35010>>>>>>
35010>>>>>  end
35010>>>>>>
35010>>>>>  else move (psFieldLabel_Short.i(FieldInf_VirtualFields_Object(file#),field#-256)) to rval#
35012>>>>>  function_return rval#
35013>>>>>end_function
35014>>>   object oGridPrepare is a cArray
35016>>>     property integer piNextPrevious public 1
35018>>>     item_property_list
35018>>>       item_property string  psHeaderLabel.i
35018>>>       item_property integer piAbstractOrFile.i
35018>>>       item_property integer piField.i
35018>>>     end_item_property_list
35063>>>     procedure add_column string label# integer abstract# integer field#
35065>>>       local integer row#
35066>>>       get row_count to row#
35067>>>       set psHeaderLabel.i row# to label#
35068>>>       set piAbstractOrFile.i row# to abstract#
35069>>>       set piField.i row# to field#
35070>>>     end_procedure
35071>>>     procedure reset
35073>>>       send delete_data
35074>>>       set piNextPrevious to 1
35075>>>     end_procedure
35076>>>     procedure apply_settings integer obj# integer DoColor#
35078>>>       local integer row# max#
35079>>>       get row_count to max#
35080>>>       set line_width of obj# to max# 0
35081>>>       for row# from 0 to (max#-1)
35087>>>>
35087>>>         set header_label of obj# row# to (psHeaderLabel.i(current_object,row#))
35088>>>         if (piField.i(current_object,row#)) eq -1 ;           set form_margin of obj# row# to (integer_value.ii(form_margin_array#,0,piAbstractOrFile.i(current_object,row#)))
35091>>>         else set form_margin of obj# row# to (gl_effective_form_margin(piAbstractOrFile.i(current_object,row#),piField.i(current_object,row#)))
35093>>>       loop
35094>>>>
35094>>>       set select_mode of obj# to no_select
35095>>>       if DoColor# begin
35097>>>         set highlight_row_state of obj# to true
35098>>>         set highlight_row_color of obj# to (rgb(0,255,255))
35099>>>         set current_item_color of obj# to (rgb(0,255,255))
35100>>>       end
35100>>>>
35100>>>       if (piNextPrevious(current_object)) begin
35102>>>         move current_object to max# // Overload
35103>>>         move obj# to current_object
35104>>>         on_key knext_item send switch
35105>>>         on_key kprevious_item send switch_back
35106>>>         move max# to current_object
35107>>>       end
35107>>>>
35107>>>     end_procedure
35108>>>   end_object // oGridPrepare
35109>>>   procedure GridPrepare_Reset global
35110>>>     send reset to (oGridPrepare(current_object))
35111>>>   end_procedure
35112>>>   procedure GridPrepare_AddCheckBoxColumn global
35113>>>     send add_column to (oGridPrepare(current_object)) "" AFT_ASCII3 -1
35114>>>   end_procedure
35115>>>   procedure GridPrepare_AddColumn global string label# integer abstract#
35116>>>     send add_column to (oGridPrepare(current_object)) label# abstract# -1
35117>>>   end_procedure
35118>>>   procedure GridPrepare_AddColumnFileField global string label# integer file# integer field#
35119>>>     send add_column to (oGridPrepare(current_object)) label# file# field#
35120>>>   end_procedure
35121>>>   procedure GridPrepare_Apply global integer obj# integer DoColor#
35122>>>     local integer tmp#
35123>>>     if num_arguments gt 1 move DoColor# to tmp#
35126>>>     else move 1 to tmp#
35128>>>     send apply_settings to (oGridPrepare(current_object)) obj# tmp#
35129>>>     send GridPrepare_Reset
35130>>>   end_procedure
35131>>>  // Here is a temporary array used for storing different values while
35131>>>  // a grid is being sorted.
35131>>>  object oSortGrid_Data is a cArray no_image
35133>>>    property integer piCurrentGridID public 0 // Not used
35135>>>    property integer piCurrentRow    public 0
35137>>>    property integer piCurrentColumn public 0
35139>>>    object oSortedData is a cArray no_image
35141>>>    end_object
35142>>>    object oAuxValues is a cArray no_image
35144>>>    end_object
35145>>>    object oEntryStates is a cArray no_image
35147>>>    end_object
35148>>>    object oSelectStates is a cArray no_image
35150>>>    end_object
35151>>>     object oItemColors is a cArray no_image
35153>>>     end_object
35154>>>    object oCheckboxItemStates is a cArray no_image
35156>>>    end_object
35157>>>    // Get data out of the grid to this structure
35157>>>    procedure reset
35159>>>      send delete_data
35160>>>      send delete_data to (oAuxValues(current_object))
35161>>>      send delete_data to (oSortedData(current_object))
35162>>>      send delete_data to (oEntryStates(current_object))
35163>>>      send delete_data to (oSelectStates(current_object))
35164>>>      send delete_data to (oCheckboxItemStates(current_object))
35165>>>    //send delete_data to (oMessages(current_object))
35165>>>      send delete_data to (oItemColors(current_object))
35166>>>      set piCurrentGridID to 0
35167>>>      set piCurrentRow to 0
35168>>>      set piCurrentColumn to 0
35169>>>    end_procedure
35170>>>    // Get data from grid
35170>>>    procedure load_grid_data integer oGrd#
35172>>>      local integer max# itm# AuxValues# EntryStates# ci# cc# columns#
35173>>>      local integer SelectStates# CheckboxItemStates# ItemColors#
35173>>>      move (oAuxValues(current_object)) to AuxValues#
35174>>>      move (oEntryStates(current_object)) to EntryStates#
35175>>>      move (oSelectStates(current_object)) to SelectStates#
35176>>>      move (oCheckboxItemStates(current_object)) to CheckboxItemStates#
35177>>>      move (oItemColors(current_object)) to ItemColors#
35178>>>      send delete_data
35179>>>      send delete_data to AuxValues#
35180>>>      send delete_data to EntryStates#
35181>>>      send delete_data to SelectStates#
35182>>>      send delete_data to CheckboxItemStates#
35183>>>      send delete_data to ItemColors#
35184>>>      set piCurrentGridID to oGrd#
35185>>>      get item_count of oGrd# to max#
35186>>>      for itm# from 0 to (max#-1)
35192>>>>
35192>>>        set value item itm# to (value(oGrd#,itm#))
35193>>>        set value of AuxValues# item itm# to (aux_value(oGrd#,itm#))
35194>>>        set value of EntryStates# item itm# to (entry_state(oGrd#,itm#))
35195>>>        set value of SelectStates# item itm# to (select_state(oGrd#,itm#))
35196>>>        set value of CheckboxItemStates# item itm# to (checkbox_item_state(oGrd#,itm#))
35197>>>        set value of ItemColors# item itm# to (ItemColor(oGrd#,itm#))
35198>>>      loop
35199>>>>
35199>>>      get current_item of oGrd# to ci#
35200>>>      get Grid_Columns oGrd# to columns#
35201>>>      set piCurrentRow    to (ci#/columns#)
35202>>>      set piCurrentColumn to (ci#-(columns#*piCurrentRow(current_object)))
35203>>>    end_procedure
35204>>>    register_function iSpecialSortValueOnColumn.i integer column# returns integer
35204>>>    register_function sSortValue.ii integer column# integer itm# returns string
35204>>>    procedure sort_data integer oGrd# integer column#
35206>>>      local integer sort_arr# row# max# columns# itm# st# custom#
35207>>>      local string value#
35207>>>      move (oSortedData(current_object)) to sort_arr#
35208>>>      send delete_data to sort_arr#
35209>>>      get Grid_Columns oGrd# to columns#
35210>>>      get item_count of oGrd# to max#
35211>>>      get delegation_mode of oGrd# to st#
35212>>>      set delegation_mode of oGrd# to NO_DELEGATE_OR_ERROR
35213>>>      get iSpecialSortValueOnColumn.i of oGrd# column# to custom#
35214>>>      set delegation_mode of oGrd# to st#
35215>>>      move (max#/columns#) to max# // Number of rows#
35216>>>      for row# from 0 to (max#-1)
35222>>>>
35222>>>        move (row#*columns#+column#) to itm#
35223>>>        if custom# get sSortValue.ii of oGrd# column# itm# to value#
35226>>>        else get value of oGrd# item itm# to value#
35228>>>        move (value#+IntToStrR(row#,6)) to value#
35229>>>        set value of sort_arr# item row# to value#
35230>>>      loop
35231>>>>
35231>>>      send sort_items to sort_arr# //ASCENDING
35232>>>    end_procedure
35233>>>    procedure fill_grid integer oGrd#
35235>>>      local integer sort_arr# row# max# itm# columns# itm_min# itm_max# cr#
35236>>>      local integer grid_row#
35236>>>      local integer EntryStates# AuxValues# grid_itm#
35236>>>      local integer SelectStates# CheckboxItemStates# ItemColors#
35236>>>      local string value#
35236>>>      move (oSortedData(current_object)) to sort_arr#
35237>>>      move (oAuxValues(current_object)) to AuxValues#
35238>>>      move (oEntryStates(current_object)) to EntryStates#
35239>>>      move (oSelectStates(current_object)) to SelectStates#
35240>>>      move (oCheckboxItemStates(current_object)) to CheckboxItemStates#
35241>>>      move (oItemColors(current_object)) to ItemColors#
35242>>>      send delete_data to oGrd#
35243>>>      get Grid_Columns oGrd# to columns#
35244>>>      get item_count of sort_arr# to max#
35245>>>      get piCurrentRow to cr#
35246>>>      move 0 to grid_itm#
35247>>>      for row# from 0 to (max#-1)
35253>>>>
35253>>>        move (right(value(sort_arr#,row#),6)) to grid_row#
35254>>>        if grid_row# eq cr# set piCurrentRow to row#
35257>>>        move (grid_row#*columns#) to itm_min#
35258>>>        move (itm_min#+columns#-1) to itm_max#
35259>>>        for itm# from itm_min# to itm_max#
35265>>>>
35265>>>          send add_item to oGrd# msg_none (value(current_object,itm#))
35266>>>          set checkbox_item_state of oGrd# item grid_itm# to (value(CheckboxItemStates#,itm#))
35267>>>          set select_state of oGrd# item grid_itm# to (value(SelectStates#,itm#))
35268>>>          set aux_value of oGrd# item grid_itm# to (value(AuxValues#,itm#))
35269>>>          set entry_state of oGrd# item grid_itm# to (value(EntryStates#,itm#))
35270>>>          set itemcolor of oGrd# item grid_itm# to (value(ItemColors#,itm#))
35271>>>          increment grid_itm#
35272>>>        loop
35273>>>>
35273>>>      loop
35274>>>>
35274>>>    end_procedure
35275>>>    procedure Sort_Grid integer oGrd# integer column#
35277>>>      local integer cr# cc# columns#
35278>>>       send cursor_wait to (cursor_control(current_object))
35279>>>      set dynamic_update_state of oGrd# to false
35280>>>      send reset
35281>>>      send load_grid_data oGrd#
35282>>>      send sort_data oGrd# column#
35283>>>      send fill_grid oGrd#
35284>>>      set dynamic_update_state of oGrd# to true
35285>>>      get piCurrentRow to cr#
35286>>>      get piCurrentColumn to cc#
35287>>>      get Grid_Columns oGrd# to columns#
35288>>>      set current_item of oGrd# to (columns#*cr#+cc#)
35289>>>      send reset
35290>>>       send cursor_ready to (cursor_control(current_object))
35291>>>    end_procedure
35292>>>  end_object // oSortGrid_Data
35293>>>//end_desktop_section
35293>>>
35293>>>procedure Grid_SortByColumn global integer oGrd# integer column#
35294>>>  send Sort_Grid to (oSortGrid_Data(current_object)) oGrd# column#
35295>>>end_procedure
35296>>>
35296>>>procedure Grid_AddCheckBoxItem global integer oGrd# integer iState
35297>>>  local integer iItm
35298>>>  get item_count of oGrd# to iItm
35299>>>  send add_item to oGrd# msg_none ""
35300>>>  set checkbox_item_state of oGrd# item iItm to DFTRUE
35301>>>  set select_state of oGrd# item iItm to iState
35302>>>end_procedure
35303>>>procedure Grid_RowMakeSelectable global integer oGrd#
35304>>>end_procedure
35305>>>procedure Grid_RowSelectAll global integer oGrd#
35306>>>  local integer iRow iMax
35307>>>  get Grid_RowCount oGrd# to iMax
35308>>>  decrement iMax
35309>>>  for iRow from 0 to iMax
35315>>>>
35315>>>    set select_state of oGrd# item (Grid_RowBaseItem(oGrd#,iRow)) to DFTRUE
35316>>>  loop
35317>>>>
35317>>>end_procedure
35318>>>procedure Grid_RowDeselectAll global integer oGrd#
35319>>>  local integer iRow iMax
35320>>>  get Grid_RowCount oGrd# to iMax
35321>>>  decrement iMax
35322>>>  for iRow from 0 to iMax
35328>>>>
35328>>>    set select_state of oGrd# item (Grid_RowBaseItem(oGrd#,iRow)) to DFFALSE
35329>>>  loop
35330>>>>
35330>>>end_procedure
35331>>>procedure Grid_RowSelectInvert global integer oGrd#
35332>>>  local integer iRow iMax iSelect iBase
35333>>>  get Grid_RowCount oGrd# to iMax
35334>>>  decrement iMax
35335>>>  for iRow from 0 to iMax
35341>>>>
35341>>>    move (Grid_RowBaseItem(oGrd#,iRow)) to iBase
35342>>>    get select_state of oGrd# item iBase to iSelect
35343>>>    set select_state of oGrd# item iBase to (not(iSelect))
35344>>>  loop
35345>>>>
35345>>>end_procedure
35346>>>procedure Grid_RowSelectCostum global integer oGrd# integer iGet
35347>>>  local integer iRow iMax iSelect iBase
35348>>>  get Grid_RowCount oGrd# to iMax
35349>>>  decrement iMax
35350>>>  for iRow from 0 to iMax
35356>>>>
35356>>>    move (Grid_RowBaseItem(oGrd#,iRow)) to iBase
35357>>>    get iGet of oGrd# iRow iBase to iSelect
35358>>>    set select_state of oGrd# item iBase to iSelect
35359>>>  loop
35360>>>>
35360>>>end_procedure
35361>>>procedure Grid_RowCallBackSelected global integer oGrd# integer iMsg
35362>>>  local integer iRow iMax iBase iSelect
35363>>>  get Grid_RowCount oGrd# to iMax
35364>>>  decrement iMax
35365>>>  for iRow from 0 to iMax
35371>>>>
35371>>>    move (Grid_RowBaseItem(oGrd#,iRow)) to iBase
35372>>>    get select_state of oGrd# item iBase to iSelect
35373>>>    if iSelect send iMsg to oGrd# iRow iBase
35376>>>  loop
35377>>>>
35377>>>end_procedure
35378>>>
35378>>>// procedure row_change integer iRowFrom integer iRowTo
35378>>>// end_procedure
35378>>>// procedure item_change integer iItm1 integer iItm2 returns integer
35378>>>//   local integer iRval iColumns
35378>>>//   get Grid_Columns current_object to iColumns
35378>>>//   forward get msg_item_change iItm1 iItm2 to iRval
35378>>>//   if (iItm1/iColumns) ne (iItm2/iColumns) send row_change (iItm1/iColumns) (iItm2/iColumns)
35378>>>//   procedure_return iRval
35378>>>// end_procedure
35378>>>
35378>>>// procedure select_toggling integer itm# integer i#
35378>>>//   local integer ci# iColumns
35378>>>//   get Grid_Columns current_object to iColumns
35378>>>//   get current_item to ci#
35378>>>//   move ((ci#/iColumns)*iColumns) to ci# // Redirect to first column
35378>>>//   forward send select_toggling ci# i#
35378>>>// end_procedure
35378>>>
35378>Use rptVw.Sub
INCLUDING FILE: RPTVW.SUB
35378>>>Use DFRptvw.pkg
35378>>>Use dbRptvw.pkg
INCLUDING FILE: DBRPTVW.PKG
35378>>>>>
35378>>>>>Use Windows
35378>>>>>Use DfPanel
35378>>>>>Use EnClient
35378>>>>>Use DFNav_mx
35378>>>>>Use dfConfrm
35378>>>>>Use dfRptVw
35378>>>>>Use DFGSINI
35378>>>>>
35378>>>>>Class dbReportAppClient_ is a ReportView STARTMAC ECstart
35379>>>>>    Import_Class_Protocol Entry_Client
35380>>>>>    //  Defeat the activating augmentation for auto-locate
35380>>>>>    Procedure Activating Returns Integer
35381>>>>>      local integer RVal
35382>>>>>      forward get MSG_activating to rVal
35384>>>>>      Procedure_Return rVal
35385>>>>>    End_Procedure
35386>>>>>End_Class // dbReportAppClient_
35387>>>>>
35387>>>>>Class dbReportAppView_ is a dbReportAppClient_
35388>>>>>  import_Class_protocol entry_view_Client
35389>>>>>End_Class // dbReportAppView_
35390>>>>>
35390>>>>>
35390>>>>>Class dbReportView is a dbReportAppView_
35391>>>>>
35391>>>>>     Procedure Construct_Object
35392>>>>>      Forward Send Construct_Object No_Image
35394>>>>>      Send Define_DFNavigation  // GUI navigate changes
35395>>>>>      // dialog views get activated as popup objects.
35395>>>>>      set Dso_Detach_Mode to Detach_Always
35396>>>>>
35396>>>>>      Set Verify_Data_Loss_Msg TO GET_No_Confirmation
35397>>>>>      Set Verify_Delete_Msg    TO GET_No_Confirmation
35398>>>>>      Set Verify_Save_Msg      TO GET_No_Confirmation
35399>>>>>      Set Verify_Exit_Msg      TO GET_No_confirmation
35400>>>>>      //
35400>>>>>      // This reportview-client will almost always be a modalpanel, therefore minimizing
35400>>>>>      // is out of the question...
35400>>>>>      Set Minimize_Icon To False
35401>>>>>      Set Maximize_Icon To False
35402>>>>>   End_Procedure // Construct_Object
35403>>>>>
35403>>>>>   Procedure Request_Delete
35404>>>>>   End_Procedure // request_delete
35405>>>>>
35405>>>>>   Procedure Request_Save
35406>>>>>   End_Procedure // request_save
35407>>>>>
35407>>>>>   Function Exit_Application_Check Returns Integer
35408>>>>>     Function_return 0
35409>>>>>   End_Function
35410>>>>>
35410>>>>>   Import_Class_Protocol DFNavigate_Mixin
35411>>>>>
35411>>>>>  //  Returns TRUE to indicate that this is a DEO. This is used by
35411>>>>>  //  delegation to figure out if you are within a DEO and should therefore
35411>>>>>  //  send a DEO message. DEO clients set this true
35411>>>>>  Function DEO_Object Returns integer
35412>>>>>    Function_Return 1
35413>>>>>  End_Function // DEO_Object
35414>>>>>
35414>>>>>  //
35414>>>>>  //  Activate message for views that:
35414>>>>>  //  1. restores the view if it is minimized
35414>>>>>  //  2. Maintains the current scope's focus.
35414>>>>>  //
35414>>>>>  Procedure Activate_current_scope
35415>>>>>    If ( View_mode(Current_Object)=VIEWMODE_ICONIZE ) ;       Set view_mode to viewmode_normal
35418>>>>>    Set Current_Scope to Current_Object
35419>>>>>  End_Procedure // Activate_current_scope
35420>>>>>
35420>>>>>  //  Pass full object name - return the relative name
35420>>>>>  //  e.g.,  Main.View.Obj1 --> Obj1
35420>>>>>  Function Local_Object_name string nm returns string
35421>>>>>     local integer ps
35422>>>>>     Repeat
35422>>>>>>
35422>>>>>       pos "." in nm to ps
35424>>>>>>
35424>>>>>       If ps eq 0 function_return nm
35427>>>>>       increment ps
35428>>>>>       Mid Nm to Nm 255 ps
35431>>>>>>
35431>>>>>     Loop
35432>>>>>>
35432>>>>>  end_function
35433>>>>>
35433>>>>>  //  Take string "#1,#2" and return integer hi #1 + #2
35433>>>>>  Function Parse_Complex string sVal returns integer
35434>>>>>     Local integer ps
35435>>>>>     Pos "," in sVal to ps
35437>>>>>>
35437>>>>>     if ps ;        Function_Return ( integer(left(sVal,ps-1))*65536 + ;                          integer(mid(sVal,255,ps+1)) )
35440>>>>>  End_Function // Parse_Complex
35441>>>>>
35441>>>>>  // Convert a complex integer to a string "hi,Low"
35441>>>>>  //
35441>>>>>  Function Complex_to_String integer i1 returns string
35442>>>>>     function_return ( string(hi(i1)) - "," - String(low(i1)) )
35443>>>>>  End_function
35444>>>>>
35444>>>>>
35444>>>>>  // *WvA: I don't want to save locations of a reportview noted in the registry.
35444>>>>>  // These printing dialogs are centered on the panel anyway, so it doesn't make any
35444>>>>>  // sense to clutter up the registry with this kind of nonsense.
35444>>>>>  ////
35444>>>>>  ////  Save View information to dfwin.ini file. Save as:
35444>>>>>  ////  View_ObjectName=LOC:Row,Col  e.g., Cust_Ent=LOC:10,20
35444>>>>>  ////     Leaving room for growth here.
35444>>>>>  ////
35444>>>>>  Procedure Save_Environment
35445>>>>>  //   Local String nm Vn st
35445>>>>>  //   Local Integer H
35445>>>>>  //
35445>>>>>  //   Get System_Profile_String "SaveEnvironment" to St
35445>>>>>  //   Move (Uppercase(trim(st))) to st
35445>>>>>  //   If (st="YES" or st="ON" or st="TRUE") Begin
35445>>>>>  //     // Note with the 3.05 version we will have problems if the view has
35445>>>>>  //     // been maximized and then iconized. We still don't know what the normal
35445>>>>>  //     // size/loc is when maximized. We will take a chance and assume that an
35445>>>>>  //     // iconized view is always non-zoomed (since views don't support the zoom
35445>>>>>  //     // button).
35445>>>>>  //     If (View_mode(Current_Object)<>VIEWMODE_ZOOM) Begin
35445>>>>>  //
35445>>>>>  //       Get Name to Vn // full name of object
35445>>>>>  //       Get Local_Object_Name Vn to Vn   // just get the local name
35445>>>>>  //       Get GUILocation to H             // complex location
35445>>>>>  //       Get Complex_to_String h to nm    // convert complex to "hi,low"
35445>>>>>  //       Set System_Profile_String VN to ("LOC:"+Nm)
35445>>>>>  //     End
35445>>>>>  //   End
35445>>>>>  //
35445>>>>>  End_Procedure
35446>>>>>  //
35446>>>>>  //// Augment to check for view string in .INI. Currently, if found
35446>>>>>  //// set the location
35446>>>>>  ////
35446>>>>>  Procedure Load_Environment
35447>>>>>  //   Local String nm Vn Lc
35447>>>>>  //   Local Integer H ps
35447>>>>>  //   // see above for reasoning on this
35447>>>>>  //   If (View_mode(Current_Object)=VIEWMODE_NORMAL) Begin
35447>>>>>  //     Get Name to Vn
35447>>>>>  //     Get Local_Object_Name Vn to Vn
35447>>>>>  //     Get System_Profile_String Vn to Nm
35447>>>>>  //     IF Nm ne '' Begin
35447>>>>>  //        Pos "LOC:" in Nm to Ps   // look for LOC:row,col
35447>>>>>  //        If Ps Begin
35447>>>>>  //           Mid Nm to Lc 255 (Ps+4)
35447>>>>>  //           Pos " " in Lc to ps
35447>>>>>  //           if Ps left lc to lc (ps-1)
35447>>>>>  //           Get Parse_Complex lc to H
35447>>>>>  //           Set GUILocation to (Hi(H)) (Low(H))
35447>>>>>  //           Send Adjust_Logicals
35447>>>>>  //        End
35447>>>>>  //     End
35447>>>>>  //   End
35447>>>>>  End_Procedure
35448>>>>>
35448>>>>>  Function View_Changed returns Integer
35449>>>>>     Local Integer Changed
35450>>>>>     Broadcast Get Data_Set_Should_Save to Changed // Ask for changes in Data-sets
35452>>>>>     Function_Return Changed
35453>>>>>  End_Function
35454>>>>>
35454>>>>>  Procedure Notify_Exit_Application
35455>>>>>    Send Save_Environment
35456>>>>>  End_procedure
35457>>>>>
35457>>>>>  Procedure End_Construct_Object
35458>>>>>     Send Load_Environment
35459>>>>>     //Send Define_SysMenu
35459>>>>>     Forward Send End_Construct_Object
35461>>>>>  End_Procedure // End_Construct_Object
35462>>>>>
35462>>>>>  Procedure Close_Client
35463>>>>>     Send Exit_Function
35464>>>>>  End_Procedure
35465>>>>>
35465>>>>>  Procedure Entering_Scope returns Integer
35466>>>>>     Local Integer rVal
35467>>>>>     Forward Get MSG_Entering_Scope to rVal
35469>>>>>     If not rVal send Show_View_Name (Label(Current_Object))
35472>>>>>  End_Procedure
35473>>>>>
35473>>>>>  Procedure Exiting_Scope integer whereto returns Integer
35474>>>>>     Local Integer rVal
35475>>>>>     Forward Get MSG_Exiting_Scope whereto to rVal
35477>>>>>     If not rVal Send Show_View_Name ''
35480>>>>>  End_Procedure
35481>>>>>
35481>>>>>  Procedure Show_view_Name string sHelp
35482>>>>>     Local Integer rVal Id
35483>>>>>     Get Statusbar_id to id
35484>>>>>     If Id Send Show_View_Name to Id sHelp
35487>>>>>  End_Procedure
35488>>>>>
35488>>>>>  Function Should_Save_Recursive returns integer
35489>>>>>    Function_return (View_Changed(Current_Object))
35490>>>>>  End_Function
35491>>>>>
35491>>>>>End_Class // dbReportView
35492>>>
35492>>>Class ReportViewSub is a ReportView
35493>>>
35493>>>    Procedure Construct_Object
35494>>>        Forward Send Construct_Object
35496>>>        Property Integer Server 0
35497>>>    End_Procedure // Construct_Object
35498>>>
35498>>>    Procedure Page Integer PageMode
35499>>>        Integer hWnd
35500>>>        Forward Send Page PageMode
35502>>>        Get Window_Handle to hWnd
35503>>>        If (hWnd) Begin
35505>>>            Send GreekSysMenu
35506>>>        End
35506>>>>
35506>>>    End_Procedure
35507>>>
35507>>>    Procedure Close_Panel
35508>>>        Local Integer liScope
35509>>>        Move (Prior_Scope(Desktop)) To liScope
35510>>>        Move (Scope_Focus(liScope)) To liScope
35511>>>        Forward Send Close_Panel
35513>>>        Send Activate To liScope
35514>>>    End_Procedure // Close_Panel
35515>>>
35515>>>End_Class
35516>>>
35516>>>Class dbReportViewSub is a dbReportView
35517>>>
35517>>>    Procedure Construct_Object
35518>>>        Forward Send Construct_Object
35520>>>        Property Integer Server 0
35521>>>    End_Procedure // Construct_Object
35522>>>
35522>>>    Procedure Page Integer PageMode
35523>>>        Integer hWnd
35524>>>        Forward Send Page PageMode
35526>>>        Get Window_Handle to hWnd
35527>>>        If (hWnd) Begin
35529>>>            Send GreekSysMenu
35530>>>        End
35530>>>>
35530>>>    End_Procedure
35531>>>
35531>>>    Procedure Close_Panel
35532>>>        Local Integer liScope
35533>>>        Move (Prior_Scope(Desktop)) To liScope
35534>>>        Move (Scope_Focus(liScope)) To liScope
35535>>>        Forward Send Close_Panel
35537>>>        Send Activate To liScope
35538>>>    End_Procedure // Close_Panel
35539>>>End_Class
35540>>>
35540>
35540>Use DD_Sec.Sub
INCLUDING FILE: DD_SEC.SUB
35540>>>
35540>>>Open Sysfile
35542>>>Open UserGrps
35544>>>Open Users
35546>>>Open Views
35548>>>Open GrpViews
35550>>>Open Arxeia
35552>>>Open GrpArx
35554>>>Open GrpArx0
35556>>>Open GrpView0
35558>>>
35558>>>Use DD.Sub
35558>>>
35558>>>Class Datadictionary_Sec  Is A DatadictionarySub
35559>>>
35559>>>
35559>>>    Procedure Construct_Object
35560>>>        Forward Send Construct_Object
35562>>>        Property Integer cpiUpdate              0
35563>>>        Property Integer cpiBackout             0
35564>>>        Property Integer cpiEditing             0
35565>>>        Property Integer cpiFileNumber          0
35566>>>        Property String  cpsFileName            ''
35567>>>        Property String  cpsLoginID             ''
35568>>>        Property Integer cpiCannot_Read         0
35569>>>        Property Integer cpiCannot_Create       0
35570>>>        Property Integer cpiCannot_Delete       0
35571>>>        Property Integer cpiCannot_Edit         0
35572>>>        Property Integer piFN                   0
35573>>>    End_Procedure
35574>>>
35574>>>//    Procedure Save_Main_File
35574>>>//        If (Operation_Origin<>Self) Begin
35574>>>//            If Indirect_File.Recnum Eq 0 Procedure_Return
35574>>>//        End
35574>>>//        Forward Send Save_Main_File
35574>>>//    End_Procedure
35574>>>
35574>>>
35574>>>
35574>>>    Function Validate_Save Returns Integer
35575>>>        Integer rVal
35576>>>        Forward Get Validate_Save to rVal
35578>>>        If (Not(rVal)) Begin
35580>>>            Get cpiCannot_Read to rVal
35581>>>            If (Not(rVal)) Begin
35583>>>                Set cpiEditing to ((cpiBackout(Self)=1) and (cpiUpdate(Self)=1))
35584>>>                If (cpiEditing(Self)=1) Get cpiCannot_Edit      to rVal
35587>>>                Else                    Get cpiCannot_Create    to rVal
35589>>>            End
35589>>>>
35589>>>            If (rVal) Send Operation_Not_Allowed rVal
35592>>>        End
35592>>>>
35592>>>        Function_Return rVal
35593>>>    End_Function
35594>>>
35594>>>    Function Validate_Delete Returns Integer
35595>>>        Integer rVal
35596>>>        Forward Get Validate_Delete to rVal
35598>>>        If (Not(rVal)) Begin
35600>>>            Get cpiCannot_Read to rVal
35601>>>            If (Not(rVal)) Get cpiCannot_Delete to rVal
35604>>>            If (rVal) Send Operation_Not_Allowed rVal
35607>>>        End
35607>>>>
35607>>>        Function_Return rVal
35608>>>    End_Function
35609>>>
35609>>>    Procedure End_Construct_Object
35610>>>        Integer liSrv rVal
35611>>>        String lsStr
35611>>>        Forward Send End_Construct_Object
35613>>>        Get Main_File                                   To liSrv
35614>>>        Set cpiFileNumber                               To liSrv
35615>>>        Get_Attribute DF_FILE_PHYSICAL_NAME Of liSrv    To lsStr
35618>>>        Set cpsFileName                                 To (Trim(Uppercase(lsStr)))
35619>>>        Set cpsLoginID                                  To (fsLoginUserID())
35620>>>        Send Find_User_Rights
35621>>>        Set piFN to lisrv
35622>>>    End_Procedure
35623>>>
35623>>>    Procedure Find_User_Rights
35624>>>        String lsArxeio lsLogin
35625>>>        Integer liUser liArxeio iGroup
35625>>>
35625>>>        Get cpiFileNumber   to liArxeio
35626>>>        Get cpsFileName     to lsArxeio
35627>>>        Get cpsLoginID      to lsLogin
35628>>>
35628>>>        Clear Users
35629>>>        Move lsLogin    to Users.Login_ID
35630>>>        Find eq Users by Index.1 // Users:Index.1:Users.Login_ID
35631>>>>
35631>>>        If (Found=1)  Begin
35633>>>            Move Users.User_ID  to liUser
35634>>>            Move Users.Grp_ID   to iGroup
35635>>>        End
35635>>>>
35635>>>        //Else Send Operation_Not_Allowed 9999
35635>>>
35635>>>        Clear Arxeia
35636>>>
35636>>>        Move liArxeio to Arxeia.Arxeio_ID
35637>>>        Find eq Arxeia by Index.1 // Arxeia:Index.1:Arxeia.Arxeio_ID
35638>>>>
35638>>>
35638>>>        If (Found=1) Begin
35640>>>            Move Arxeia.Arxeio_ID to liArxeio
35641>>>
35641>>>            Clear GrpArx
35642>>>            Move liUser     to GrpArx.User_ID
35643>>>            Move liArxeio   to GrpArx.Arxeio_ID
35644>>>            Find eq GrpArx by Index.1 // GrpArx:Index.1:GrpArx.User_ID+GrpArx.Arxeio_ID
35645>>>>
35645>>>            If (Found=1) Begin
35647>>>               If (GrpArx.Allow_Read  ='1') Set cpiCannot_Read   to 0
35650>>>               Else                         Set cpiCannot_Read   to 10003
35652>>>               If (GrpArx.Allow_Create='1') Set cpiCannot_Create to 0
35655>>>               Else                         Set cpiCannot_Create to 10000
35657>>>               If (GrpArx.Allow_Change='1') Set cpiCannot_Edit   to 0
35660>>>               Else                         Set cpiCannot_Edit   to 10001
35662>>>               If (GrpArx.Allow_Delete='1') Set cpiCannot_Delete to 0
35665>>>               Else                         Set cpiCannot_Delete to 10002
35667>>>            End
35667>>>>
35667>>>            Else Begin
35668>>>                Clear GrpArx0
35669>>>                Move iGroup   to GrpArx0.Group_ID
35670>>>                Move liArxeio to GrpArx0.Arxeio_ID
35671>>>                Find eq GrpArx0 by Index.1 // GrpArx0:Index.1:Group_ID+Arxeio_ID
35672>>>>
35672>>>                If (Found=1) Begin
35674>>>                    If (GrpArx0.Allow_Read  ='1')   Set cpiCannot_Read   to 0
35677>>>                    Else                            Set cpiCannot_Read   to 20003
35679>>>                    If (GrpArx0.Allow_Create='1')   Set cpiCannot_Create to 0
35682>>>                    Else                            Set cpiCannot_Create to 20000
35684>>>                    If (GrpArx0.Allow_Change='1')   Set cpiCannot_Edit   to 0
35687>>>                    Else                            Set cpiCannot_Edit   to 20001
35689>>>                    If (GrpArx0.Allow_Delete='1')   Set cpiCannot_Delete to 0
35692>>>                    Else                            Set cpiCannot_Delete to 20002
35694>>>                End
35694>>>>
35694>>>                Else Begin
35695>>>                    Set cpiCannot_Read   to 0
35696>>>                    Set cpiCannot_Edit   to 0
35697>>>                    Set cpiCannot_Create to 0
35698>>>                    Set cpiCannot_Delete to 0
35699>>>                End
35699>>>>
35699>>>            End
35699>>>>
35699>>>        End
35699>>>>
35699>>>        Else Begin
35700>>>            // €¤ ›œ¤ ™¨œŸœ  «¦ ˜¨®œ ¦ «¦«œ Ÿœà¨¦¬£œ ¦«  ¦ ®¨ž©«žª œ®œ  §¨¦©™˜©ž ©'˜¬«¦
35700>>>            Set cpiCannot_Read   to 0
35701>>>            Set cpiCannot_Edit   to 0
35702>>>            Set cpiCannot_Create to 0
35703>>>            Set cpiCannot_Delete to 0
35704>>>        End
35704>>>>
35704>>>    End_Procedure
35705>>>
35705>>>    Procedure Clear_main_file
35706>>>        Forward Send Clear_main_file
35708>>>        Set cpiBackout to 0
35709>>>        Set cpiUpdate  to 0
35710>>>    End_Procedure
35711>>>
35711>>>    Procedure Update
35712>>>        Forward Send Update
35714>>>        Set cpiUpdate to 1
35715>>>    End_Procedure
35716>>>
35716>>>    Procedure Backout
35717>>>        Forward Send Backout
35719>>>        Set cpiBackout to 1
35720>>>    End_Procedure
35721>>>
35721>>>    Procedure OnConstrain
35722>>>        Integer rVal liSrv
35723>>>        Forward Send OnConstrain
35725>>>        Get cpiFileNumber  To liSrv
35726>>>        Move liSrv         To Filenumber
35727>>>        Get cpiCannot_Read to rVal
35728>>>        If (rVal) Constrain Indirect_File.Recnum eq 0
35732>>>    End_Procedure
35733>>>
35733>>>    Procedure Operation_Not_Allowed  Integer iError_Num
35734>>>        String sLektiko
35735>>>        Move '' to sLektiko
35736>>>
35736>>>             If iError_Num eq 10000 Move "Unsufficient Rights For Creating Records in This File.\nFrom Users permissions. Check with your Administrator" to sLektiko
35739>>>        Else If iError_Num eq 10001 Move "Unsufficient Rights For Changing Data in This File.\nFrom Users permissions. Check with your Administrator"    to sLektiko
35743>>>        Else If iError_Num eq 10002 Move "Unsufficient Rights For Deleting Records in This File.\nFrom Users permissions. Check with your Administrator" to sLektiko
35747>>>        Else If iError_Num eq 10003 Move "Unsufficient Rights For Accessing Data From This File.\nFrom Users permissions. Check with your Administrator" to sLektiko
35751>>>        Else If iError_Num eq 20000 Move "Unsufficient Rights For Creating Records in This File.\nFrom Group permissions. Check with your Administrator" to sLektiko
35755>>>        Else If iError_Num eq 20001 Move "Unsufficient Rights For Changing Data in This File.\nFrom Group permissions. Check with your Administrator"    to sLektiko
35759>>>        Else If iError_Num eq 20002 Move "Unsufficient Rights For Deleting Records in This File.\nFrom Group permissions. Check with your Administrator" to sLektiko
35763>>>        Else If iError_Num eq 20003 Move "Unsufficient Rights For Accessing Data From This File.\nFrom Group permissions. Check with your Administrator" to sLektiko
35767>>>        Else If iError_Num eq  9999 Move "Unknown User in Users File"                                                                                    to sLektiko
35771>>>        Else If iError_Num eq 20101 Move "Only Users Belonging to the Initial Department \nThat Created This Record can Change its Data"                 to sLektiko
35775>>>        Else If iError_Num eq 20102 Move "Only Users Belonging to the Initial Department \nThat Created This Record can Delete It"                       to sLektiko
35779>>>        Append sLektiko '\nFile = ' (String(cpiFileNumber(Self))) ' - ' (CpsFileName(Self))
35783>>>
35783>>>             If iError_Num eq 10000 Error 10000 sLektiko
35786>>>        Else If iError_Num eq 10001 Error 10001 sLektiko
35790>>>        Else If iError_Num eq 10002 Error 10002 sLektiko
35794>>>        Else If iError_Num eq 10003 Error 10003 sLektiko
35798>>>        Else If iError_Num eq 20000 Error 20000 sLektiko
35802>>>        Else If iError_Num eq 20001 Error 20001 sLektiko
35806>>>        Else If iError_Num eq 20002 Error 20002 sLektiko
35810>>>        Else If iError_Num eq 20003 Error 20003 sLektiko
35814>>>        Else If iError_Num eq  9999 Error  9999 sLektiko
35818>>>        Else If iError_Num eq 20101 Error 20101 sLektiko
35822>>>        Else If iError_Num eq 20102 Error 20102 sLektiko
35826>>>
35826>>>        Else Forward Send Operation_Not_Allowed  iError_Num
35829>>>    End_Procedure   // Operation_Not_Allowed
35830>>>
35830>>>
35830>>>End_Class //Datadictionary_Sec
35831>
35831>Use SelectCY.sl
INCLUDING FILE: SELECTCY.SL
35831>>>//AB/ Project Select Company(DataPath) for Open Estate
35831>>>//AB/ Object prj is a Lookup_Project
35831>>>//AB/     Set ProjectName to "Select Company(DataPath) for Open Estate"
35831>>>//AB/     Set ProjectFileName to "Selectcy.sl"
35831>>>
35831>>>// Project Object Structure
35831>>>//   oSelectCY is a BasicPanelSub
35831>>>//     Workspc_DD is a DataDictionary
35831>>>//     oSelList is a dbListSub
35831>>>//     oOK_bn is a ButtonSub
35831>>>//     oCancel_bn is a ButtonSub
35831>>>//     oSearch_bn is a ButtonSub
35831>>>//     dbGrpSelected is a dbGroupSub
35831>>>//       Workspc_Titlos is a dbFormSub
35831>>>//     cbfrmYear is a ComboFormSub
35831>>>
35831>>>// Register all objects
35831>>>Register_Object cbfrmYear
35831>>>Register_Object dbGrpSelected
35831>>>Register_Object oCancel_bn
35831>>>Register_Object oOK_bn
35831>>>Register_Object oSearch_bn
35831>>>Register_Object oSelectCY
35831>>>Register_Object oSelList
35831>>>Register_Object Workspc_DD
35831>>>Register_Object Workspc_Titlos
35831>>>
35831>>>
35831>>>//AB-IgnoreStart
35831>>>
35831>>>Use Panel.Sub
35831>>>Use DFAllEnt.pkg
35831>>>Use dbList.Sub
35831>>>Use Button.Sub
35831>>>Use dbGroup.Sub
35831>>>Use dbForm.Sub
35831>>>Use Cmbfrm.Sub
35831>>>
35831>>>
35831>>>Use WORKSPC.DD
INCLUDING FILE: WORKSPC.DD
35831>>>>>//DDB-FileStart
35831>>>>>//DDB-HeaderStart
35831>>>>>
35831>>>>>// File Name : WORKSPC.DD
35831>>>>>// Class Name: Workspc_DataDictionary
35831>>>>>// Revision  : 9
35831>>>>>// Version   : 2
35831>>>>>
35831>>>>>Use  Windows           // Basic Definitions
35831>>>>>Use  DataDict          // DataDictionary Class Definition
35831>>>>>Use  DDvalTbl          // Validation Table Class Definitions
35831>>>>>
35831>>>>>Open Workspc
INCLUDING FILE: WORKSPC.FD
35833>>>>>
35833>>>>>//DDB-HeaderEnd
35833>>>>>
35833>>>>>Class Workspc_DataDictionary  is a DataDictionary
35834>>>>>                        
35834>>>>>
35834>>>>>
35834>>>>>    // Define_Fields:
35834>>>>>    // This procedure is used to set up all data-dictionary rules.
35834>>>>>
35834>>>>>    Procedure Define_Fields
35835>>>>>        Forward Send Define_Fields
35837>>>>>        //DDB-Generated-Code-Location
35837>>>>>        //DDB-DefineFieldStart
35837>>>>>
35837>>>>>        Set Main_File            To Workspc.File_Number
35838>>>>>        Set Cascade_Delete_State To FALSE
35839>>>>>
35839>>>>>
35839>>>>>        // Field-based properties.......................
35839>>>>>
35839>>>>>        // Workspc.Id
35839>>>>>        Set Field_Options          Field Workspc.Id To DD_AUTOFIND    DD_REQUIRED   
35840>>>>>
35840>>>>>        // Workspc.Titlos
35840>>>>>        Set Field_Options          Field Workspc.Titlos To DD_REQUIRED   
35841>>>>>
35841>>>>>        // Workspc.Appsrcextrapath
35841>>>>>        Set Field_Options          Field Workspc.Appsrcextrapath To DD_REQUIRED   
35842>>>>>
35842>>>>>        // Workspc.Dataextrapath
35842>>>>>        Set Field_Options          Field Workspc.Dataextrapath To DD_REQUIRED   
35843>>>>>
35843>>>>>        // Workspc.Working
35843>>>>>
35843>>>>>        // Workspc.Filelist_Name
35843>>>>>
35843>>>>>        // Workspc.Year
35843>>>>>
35843>>>>>        //DDB-DefineFieldEnd
35843>>>>>    End_Procedure    // Define_Fields
35844>>>>>
35844>>>>>    // Field_Defaults:
35844>>>>>    // This procedure is used to establish default field values.
35844>>>>>
35844>>>>>    Procedure Field_Defaults
35845>>>>>        Forward Send Field_Defaults
35847>>>>>        //DDB-Generated-Code-Location
35847>>>>>        //DDB-FieldDefaultStart
35847>>>>>        //DDB-FieldDefaultEnd
35847>>>>>    End_Procedure    // Field_Defaults
35848>>>>>End_Class    // Workspc_DataDictionary
35849>>>>>//DDB-FileEnd
35849>>>
35849>>>//AB-IgnoreEnd
35849>>>
35849>>>Object oSelectCY is a BasicPanelSub
35851>>>
35851>>>    //AB-StoreTopStart
35851>>>    Property String psConstrainVal "1"
35853>>>    Property String psPreSelectedWorkSpcID ""
35855>>>    Property String piConstrainYear 0
35857>>>
35857>>>    Procedure FindCurrentCompany Integer aiMode
35859>>>//        String lsCurAppSrcPath
35859>>>
35859>>>//        Get CurrentAppSrcPath of ghoWorkSpace to lsCurAppSrcPath
35859>>>//        Move (UpperCase(lsCurAppSrcPath)) to lsCurAppSrcPath
35859>>>//        Clear Workspc
35859>>>//        Move lsCurAppSrcPath to Workspc.AppSrcExtraPath
35859>>>//        Find eq Workspc by Index.3
35859>>>//        [Found] Begin
35859>>>//            If ((aiMode) and ;
35859>>>//                (((piConstrainYear(Self) = Workspc.Year) and ;
35859>>>//                (piConstrainYear(Self)<>0)))) Send Find to Workspc_DD eq 5
35859>>>//            Else Set Value of (Workspc_Titlos(dbGrpSelected(Self))) to Workspc.Titlos
35859>>>//            Set psPreSelectedWorkSpcID to Workspc.ID
35859>>>//        End
35859>>>    End_Procedure // FindCurrentCompany
35860>>>
35860>>>    //AB-StoreTopEnd
35860>>>
35860>>>    Set Label to "„§ ¢¦šã „«˜ ¨å˜ª/•¨ã©žª"
35861>>>    Set Size to 207 297
35862>>>    Set Location to 30 149
35863>>>
35863>>>    //AB-DDOStart
35863>>>
35863>>>    Object Workspc_DD is a Workspc_DataDictionary
35865>>>
35865>>>        //AB-StoreStart
35865>>>
35865>>>        Set_Attribute DF_FILE_MODE of Workspc.File_Number to DF_FILEMODE_READONLY
35868>>>
35868>>>        Set Ordering to 5
35869>>>
35869>>>//        Procedure OnConstrain
35869>>>//            String lsConstrainVal
35869>>>//            Integer liConstrainYear
35869>>>
35869>>>//            Get psConstrainVal  to lsConstrainVal
35869>>>//            Get piConstrainYear to liConstrainYear
35869>>>//            If (liConstrainYear <> 0) Constrain Workspc.Year eq liConstrainYear
35869>>>//        End_Procedure // OnConstrain
35869>>>
35869>>>
35869>>>        //AB-StoreEnd
35869>>>
35869>>>    End_Object    // Workspc_DD
35870>>>
35870>>>
35870>>>    //AB-DDOEnd
35870>>>
35870>>>    Object oSelList is a dbListSub
35872>>>        Set Main_File to Workspc.File_Number
35873>>>        Set Server to (Workspc_DD(self))
35874>>>        Set Ordering to 5
35875>>>        Set Size to 136 280
35876>>>        Set Location to 36 7
35877>>>        Set Color to 15263976
35878>>>        Set CurrentRowColor to clNavy
35879>>>        Set CurrentCellColor to clNavy
35880>>>        Set Auto_Index_State to FALSE
35881>>>        Set Auto_Column_State to FALSE
35882>>>        Set Auto_Export_State to FALSE
35883>>>        Set Default_Request_Lookup to FALSE
35884>>>        Set Find_Search_State to FALSE
35885>>>        Set Header_Column_Sorted_State to TRUE
35886>>>        Set Highlight_Row_State to FALSE
35887>>>        Set Move_Value_Out_State to FALSE
35888>>>        Set Popup_Search_State to TRUE
35889>>>        Set Select_Mode to Auto_Select
35890>>>
35890>>>        Begin_Row
35893>>>            Entry_Item Workspc.Titlos
35894>>>        End_Row
35899>>>
35899>>>        Set Form_Width    item 0 to 271
35900>>>        Set Header_Label  item 0 to "„«˜ ¨å˜"
35901>>>
35901>>>
35901>>>        //AB-StoreStart
35901>>>
35901>>>        Procedure Beginning_Of_Data
35903>>>            Forward Send Beginning_Of_Data
35905>>>            Send Up
35906>>>        End_Procedure // Beginning_Of_Data
35907>>>
35907>>>        Procedure End_Of_Data
35909>>>            Forward Send End_Of_Data
35911>>>            Send Down
35912>>>        End_Procedure // End_Of_Data
35913>>>
35913>>>        Send DoRegSize Self smBottomRight
35914>>>
35914>>>
35914>>>
35914>>>
35914>>>
35914>>>
35914>>>
35914>>>
35914>>>
35914>>>
35914>>>
35914>>>        //AB-StoreEnd
35914>>>
35914>>>    End_Object    // oSelList
35915>>>
35915>>>    Object oOK_bn is a ButtonSub
35917>>>        Set Label to "&„§ ¢¦šã"
35918>>>        Set Default_State to TRUE
35919>>>        Set Location to 174 128
35920>>>
35920>>>        //AB-StoreStart
35920>>>        Procedure OnClick
35922>>>            Delegate Send ResetAllPaths
35924>>>        End_Procedure
35925>>>
35925>>>        Send DoRegAlign self amBottomRight
35926>>>
35926>>>
35926>>>
35926>>>
35926>>>
35926>>>
35926>>>
35926>>>
35926>>>
35926>>>
35926>>>
35926>>>        //AB-StoreEnd
35926>>>
35926>>>    End_Object    // oOK_bn
35927>>>
35927>>>    Object oCancel_bn is a ButtonSub
35929>>>        Set Label to "„&¥¦›¦ª"
35930>>>        Set Location to 174 183
35931>>>
35931>>>        //AB-StoreStart
35931>>>        Procedure OnClick
35933>>>            Send Exit_Application
35934>>>        End_Procedure
35935>>>
35935>>>        Send DoRegAlign self amBottomRight
35936>>>
35936>>>
35936>>>
35936>>>        //AB-StoreEnd
35936>>>
35936>>>    End_Object    // oCancel_bn
35937>>>
35937>>>    Object oSearch_bn is a ButtonSub
35939>>>        Set Label to "€&¤˜ã«ž©ž..."
35940>>>        Set Location to 174 238
35941>>>        Set Focus_Mode to Pointer_Only
35942>>>
35942>>>        //AB-StoreStart
35942>>>        Procedure OnClick
35944>>>            Send Search To (oSelList(current_object))
35945>>>        End_Procedure
35946>>>
35946>>>        Send DoRegAlign self amBottomRight
35947>>>
35947>>>        //AB-StoreEnd
35947>>>
35947>>>    End_Object    // oSearch_bn
35948>>>
35948>>>    Object dbGrpSelected is a dbGroupSub
35950>>>        Set Label to "„§ ¢œš£â¤ž œ«˜ ¨å˜/®¨ã©ž:"
35951>>>        Set Size to 28 280
35952>>>        Set Location to 2 7
35953>>>        Object Workspc_Titlos is a dbFormSub
35955>>>            Set Size to 13 266
35956>>>            Set Location to 11 7
35957>>>            Set Color to clBtnFace
35958>>>            Set Label_Col_Offset to 2
35959>>>            Set Label_Justification_Mode to jMode_Right
35960>>>            Set Enabled_State to FALSE
35961>>>            Set Item_Shadow_State Item 0 to TRUE
35962>>>            Set Shadow_State Item 0 to TRUE
35963>>>        End_Object    // Workspc_Titlos
35964>>>
35964>>>
35964>>>        //AB-StoreStart
35964>>>
35964>>>        Send DoRegAlign self amTopLeft
35965>>>        Send DoRegSize  Self smTopRight
35966>>>
35966>>>
35966>>>        //AB-StoreEnd
35966>>>
35966>>>    End_Object    // dbGrpSelected
35967>>>
35967>>>    Object cbfrmYear is a ComboFormSub
35969>>>        Set Label to "•¨ã©ž:"
35970>>>        Set Size to 14 50
35971>>>        Set Location to 173 35
35972>>>        Set Label_Col_Offset to 2
35973>>>        Set Label_Justification_Mode to jMode_Right
35974>>>        Set Entry_State to FALSE
35975>>>        Set Combo_Sort_State to FALSE
35976>>>
35976>>>        //AB-StoreStart
35976>>>
35976>>>        Procedure ChangeYear
35978>>>            String lsYear
35979>>>            Integer liPos
35979>>>
35979>>>//            Get Value Item 0 to lsYear
35979>>>//            Get combo_item_matching lsYear to liPos
35979>>>//            If (liPos = 0) Set piConstrainYear to 0
35979>>>//            Else Set piConstrainYear to (Integer(lsYear))
35979>>>//            Send Rebuild_Constraints to Workspc_DD
35979>>>//            Send Beginning_Of_Data to oSellist
35979>>>//            Send Up to oSellist
35979>>>//            Delegate Send FindCurrentCompany 1
35979>>>//            Send Activate to oSellist
35979>>>        End_Procedure //ChangeYear
35980>>>
35980>>>        Set Entry_State Item 0 to False
35981>>>
35981>>>        Procedure Combo_Fill_List
35983>>>            Integer liYear liNow
35984>>>            Date ldToday
35984>>>            String lsYear
35984>>>
35984>>>            Sysdate4 ldToday
35985>>>            Move (TheYearSegment(ldToday)) to liNow
35986>>>            If (liNow < 2000) Move 2000 to liNow
35989>>>
35989>>>            Send Combo_Add_item "Ž¢œª"
35990>>>
35990>>>            For liYear From 2000 to liNow
35996>>>>
35996>>>                Send Combo_Add_item liYear
35997>>>            Loop
35998>>>>
35998>>>
35998>>>            Set Default_Combo_Item to (combo_item_count(Self)-1)
35999>>>            Set Value Item 0 to liNow
36000>>>            Send ChangeYear
36001>>>        End_procedure // Combo_Fill_List
36002>>>
36002>>>
36002>>>        Procedure Combo_Item_Changed
36004>>>            Forward Send Combo_Item_Changed
36006>>>            Send ChangeYear
36007>>>        End_Procedure // Combo_Item_Changed
36008>>>
36008>>>        Send DoRegAlign self amBottomLeft
36009>>>
36009>>>        //AB-StoreEnd
36009>>>
36009>>>    End_Object    // cbfrmYear
36010>>>
36010>>>
36010>>>    //AB-StoreStart
36010>>>
36010>>>    Function ifSelect_Company Returns Integer
36012>>>        Integer liRecord_id
36013>>>
36013>>>        Send FindCurrentCompany 0
36014>>>        send popup_modal
36015>>>        Function_return liRecord_Id
36016>>>    End_Function // ifSelect_Xrhsh
36017>>>
36017>>>    Procedure ResetAllPaths
36019>>>        String lsAppSrcPath lsDataPath lsCurWorkSpace lsLastChar lsFilelistName
36020>>>        String lsModuleName lsID
36020>>>        If (Current_Record(Workspc_DD(Self))) Begin
36022>>>            Get WorkSpaceName of ghoWorkSpace to lsCurWorkSpace
36023>>>            Get ModuleName    of ghoWorkSpace to lsModuleName
36024>>>            Get Field_Current_Value of Workspc_DD Field Workspc.ID to lsID
36025>>>            If (psPreSelectedWorkSpcID(Self) = lsID) Break
36028>>>            Get Field_Current_Value of Workspc_DD Field Workspc.AppSrcExtraPath to lsAppSrcPath
36029>>>            Get Field_Current_Value of Workspc_DD Field Workspc.DataExtraPath   to lsDataPath
36030>>>            Get Field_Current_Value of Workspc_DD Field Workspc.Filelist_Name   to lsFileListName
36031>>>            set_profile_string ("WorkSpaces\"+lsCurWorkSpace) "AppSrcPath"      to lsDataPath
36034>>>            set_profile_string ("WorkSpaces\"+lsCurWorkSpace) "DataPath"        to lsDataPath
36037>>>//            If (lsFileListName = "") Move "filelist.cfg" to lsFileListName
36037>>>//            If (lsFileListPath <> "") Begin
36037>>>//                Move (Right(lsFileListPath,1)) to lsLastChar
36037>>>//                If ((lsLastChar = "\") or (lsLastChar = "/")) ;
36037>>>//                        set_profile_string ("WorkSpaces\"+lsCurWorkSpace) "FileListPath" to (lsFileListPath + lsFileListName)
36037>>>//                Else Begin
36037>>>//                    If (lsFileListPath contains "/") Move "/" to lsLastChar
36037>>>//                    Else Move "\" to lsLastChar
36037>>>//                    set_profile_string ("WorkSpaces\"+lsCurWorkSpace) "FileListPath" to (lsFileListPath + lsLastChar + lsFileListName)
36037>>>//                End
36037>>>//            End
36037>>>            Send DoSetWorkSpace to ghoWorkSpace lsCurWorkSpace lsModuleName
36038>>>        End
36038>>>>
36038>>>        Else //Send Stop_Box "ƒœ¤ œ§ ¢â®Ÿž¡œ á¢¢ž œ«˜ ¨å˜. ‡˜ §˜¨˜£œå¤œ  ž å› ˜!" "¢ž¨¦­¦¨å˜"
36039>>>        Send Stop_Modal_ui
36040>>>    End_Procedure // ResetDataPath
36041>>>
36041>>>    //***************** Predefined Procedures and Functions Section **************
36041>>>
36041>>>    Procedure OnResize
36043>>>        Integer liGroupSize liGroupXsize liGroupYSize
36044>>>        Integer liListSize liListXsize liListYSize
36044>>>
36044>>>        Forward Send OnResize
36046>>>
36046>>>        Get Size of dbGrpSelected to liGroupSize
36047>>>        Move (Low(liGroupSize)) to liGroupXSize // col
36048>>>        Move (Hi(liGroupSize))  to liGroupYSize // row
36049>>>
36049>>>        Get Size of oSellist to liListSize
36050>>>        Move (Low(liListSize)) to liListXSize // col
36051>>>        Move (Hi(liListSize))  to liListYSize // row
36052>>>
36052>>>        Set Size of (Workspc_Titlos(dbGrpSelected(Self))) to 13 (liGroupXSize - (280 - 266))
36053>>>        Set Form_Width of oSellist Item 1 to (liListXSize - (280 - 271))
36054>>>    End_Procedure // OnResize
36055>>>
36055>>>    Set Locate_Mode to Center_On_Screen
36056>>>    Set Maximize_Icon to False
36057>>>
36057>>>    On_Key kCancel       Send KeyAction To (oCancel_bn(current_object))
36058>>>    On_Key Key_Alt+Key_E Send KeyAction To (oOk_bn(current_object))
36059>>>    On_Key Key_Alt+Key_J Send KeyAction To (oCancel_bn(current_object))
36060>>>    On_Key Key_Alt+Key_N Send KeyAction To (oSearch_bn(current_object))
36061>>>
36061>>>    //AB-StoreEnd
36061>>>
36061>>>End_Object    // oSelectCY
36062>>>
36062>>>
36062>>>//AB-StoreStart
36062>>>
36062>>>Procedure DoReOpenFiles
36063>>>End_Procedure // DoReOpenFiles
36064>>>
36064>>>Procedure Select_Company for baseclass
36065>>>    Integer liFileSize liSelectCYId rVal
36066>>>
36066>>>    Get_Attribute DF_FILE_RECORDS_USED of Workspc.File_Number to liFileSize
36069>>>    Move oSelectCY to liSelectCYId
36070>>>    If (lifileSize) Begin
36072>>>        Get ifSelect_Company of liSelectCYId to rVal
36073>>>    End
36073>>>>
36073>>>End_Procedure // Select_Company
36074>>>
36074>>>Procedure DoChange_Company for baseclass
36075>>>    Integer rVal liModalId
36076>>>
36076>>>    Get Message_Box "‡â¢œ«œ ˜¢¢˜šã œ«˜ ¨å˜ª;" "„§ ™œ™˜åà©ž" MB_YESNO (MB_ICONQUESTION IOR MB_DEFBUTTON1) to rVal
36077>>>    If (rVal = MBR_Yes) If (Close_All_Views(Self,True)=0) Begin
36081>>>        Move oSelectCY to liModalId
36082>>>        Send Select_Company
36083>>>        Send DoReOpenFiles
36084>>>    End
36084>>>>
36084>>>End_Procedure // DoChange_Company
36085>>>
36085>>>//On_Key Key_Ctrl+Key_Enter Send DoChange_Company
36085>>>
36085>>>
36085>>>//AB-StoreEnd
36085>>>
36085>>>//AB/ End_Object    // prj
36085>Send Activate_WorkSpc to Desktop
36086>
36086>
36086>////------------------------------
36086>//Use Flexole
36086>//Use DPDlg    // Full Path Directory Picker
36086>//Use RasxDll  // Ras Package
36086>//Use Xfind    // Recursive Directory FILE FINDER
36086>//Use dvFtp    // FTP Package
36086>//Use DVDIALER // Vdf6 Dialer
36086>//Use mbForm
36086>//Use mbMessage
36086>
36086>//AB-StoreTopEnd
36086>
36086>
36086>Object Main is a PanelSub
36088>    Set Label To "RegChange"
36089>
36089>    DFCreate_Menu Main_Menu
INCLUDING FILE: FILE_PM.INC
36092>>Object oMyWinPrint is an DF_PRINTER
36094>>
36094>>    Procedure DFPrint
36096>>        Local Integer iRetVal
36097>>
36097>>        Get DFGetPrintDialogFlags To iRetVal
36098>>
36098>>        If iRetVal Begin
36100>>            Send DFPrintDoc
36101>>            Send DFClearDoc
36102>>        End
36102>>>
36102>>    End_Procedure
36103>>    Move Current_Object to WinPrintId
36104>>End_Object
36105>>
36105>>
36105>>DFCreate_Menu "&File" File_Menu is a DEOPopupMenu
36109>>    On_Item "&Clear/Add\aF5" send Request_Clear
36110>>        Set Status_Help To 'Clear current record / Add a new record'
36111>>
36111>>    On_Item "Clear &all\aCtrl+F5" send Request_Clear_All
36112>>        Set Status_Help To 'Clear all data from view'
36113>>
36113>>    On_Item "&Delete\aShift+F2" send Request_Delete
36114>>        Set Status_Help To 'Delete the current record'
36115>>
36115>>    On_Item "&Find\aF9" send Find_GE
36116>>        Set Status_Help To 'Find a record'
36117>>
36117>>    On_Item "&Next\aF8" send Find_Next
36118>>        Set Status_Help To 'Find the Next record'
36119>>
36119>>    On_Item "&Previous\aF7" send Find_Previous
36120>>        Set Status_Help To 'Find the Previous record'
36121>>
36121>>    On_Item "Superfind\aShift+F9" send Superfind
36122>>        Set Status_Help To 'Superfind a record'
36123>>
36123>>    On_Item "Superfind next\aShift+F8" send Superfind_Next
36124>>        Set Status_Help To 'Superfind the Next record'
36125>>
36125>>    On_Item "Superfind previous\aShift+F7" send Superfind_Previous
36126>>        Set Status_Help To 'Superfind the Previous record'
36127>>
36127>>    On_Item "Find fi&rst\aCtrl+Home" send Beginning_Of_Data
36128>>        Set Status_Help To 'Find the First record'
36129>>
36129>>    On_Item "Find &last\aCtrl+End" send End_Of_Data
36130>>        Set Status_Help To 'Find the Last record'
36131>>
36131>>    On_Item "&Save\aF2" send Request_Save
36132>>        Set Status_Help To 'Save the current record'
36133>>
36133>>
36133>>    On_Item "" send NONE
36134>>
36134>>    on_item   "Printer Settings   "  send DFPrintSetup       to (oWinPrint(Self))
36135>>    Set Status_Help To ""
36136>>    on_item   "Print              "  send DFPrint            to (oMyWinPrint(Self))
36137>>    Set Status_Help To ""
36138>>
36138>>    On_Item "" send NONE
36139>>
36139>>    On_Item "Properties" send DoShowProperties to Self
36140>>    Set Status_Help To 'Setup Program Properties'
36141>>
36141>>    On_Item "" send NONE
36142>>
36142>>    On_Item "E&xit\aAlt+F4" send Exit_Application to desktop
36143>>        Set Status_Help To "Stop Program's execution"
36144>>
36144>>    Procedure DoShowProperties
36146>>       // If (Close_All_Views(Self,True)=0) Send Activate_View to (piPropertiesObjectId(self))
36146>>    End_Procedure
36147>>
36147>>    On_Key Key_Alt+Key_I Send DoShowProperties
36148>>
36148>>    //
36148>>    Procedure OnInitMenu
36150>>        Local integer Obj# IsDeo Changed NoIndex File# Field# Srvr Itm
36151>>        Local integer IsDeoControl lId liClId
36151>>        Get Focus to Obj#
36152>>        Get is_Function Get_DEO_Object Obj# TRUE to IsDeo
36153>>        If IsDeo Get Server of obj# to Srvr          // invoking data-set
36156>>        If (isDeo AND Srvr) Begin
36158>>            // returns T if object in question is a DEO control object (i.e.
36158>>            // understands the data_file, data_field messages).
36158>>            Get is_Function Get_DEO_Control_Object Obj# False to IsDeoControl
36159>>            Get Should_Save of Obj# to changed  // changed file?
36160>>            If IsDEOControl Begin
36162>>                Get data_file of Obj# to file#
36163>>                Get data_field of Obj# to field#
36164>>                Move ( File#=0 OR ;                    (Field_Main_Index(Srvr,File#,Field#)=-1) ;                    ) to NoIndex             // has a find index?
36165>>            End
36165>>>
36165>>            Else ;                Move 1 to NoIndex
36167>>            Set Shadow_state item  0  to False                     // Clear
36168>>            Set Shadow_state item  1  to False                     // Clear All
36169>>            Set Shadow_state item  2  to (Current_record(Srvr)=0)  // Delete
36170>>            Set Shadow_state item  3  to NoIndex                   // Find
36171>>            Set Shadow_state item  4  to NoIndex                   // Find Next
36172>>            Set Shadow_state item  5  to NoIndex                   // Find Previous
36173>>            Set Shadow_state item  6  to NoIndex                   // Superfind
36174>>            Set Shadow_state item  7  to NoIndex                   // Superfind Next
36175>>            Set Shadow_state item  8  to NoIndex                   // Superfind Previous
36176>>            Set Shadow_state item  9  to NoIndex                   // Find First
36177>>            Set Shadow_state item 10  to NoIndex                   // Find Last
36178>>            Set Shadow_state item 11  to (Should_Save(Srvr)=0)     // Save
36179>>            Set Shadow_state item 12  to NoIndex                   // Printer
36180>>            Set Shadow_state item 13  to NoIndex                   // Print
36181>>//            Set Shadow_state item 14  to NoIndex                   // Properties
36181>>//            Set Shadow_state item 15  to (Should_Save(Srvr)=0)     // Exodos
36181>>        End
36181>>>
36181>>        Else Begin
36182>>            for itm from 0 to 13
36188>>>
36188>>                set shadow_State item itm to TRUE
36189>>            Loop
36190>>>
36190>>        End
36190>>>
36190>> //       Set Shadow_State Item 14 to (piPropertiesObjectId(Self)=0)
36190>>    End_Procedure
36191>>
36191>>    Register_Procedure Activate_oPrnSetup
36191>>
36191>>End_Pull_Down
36193>>Set Status_Help to "Find, Save, Delete, Clear information or quit this application."
36194>
36194>        DFCreate_Menu "&View" ViewPopupMenu is a ViewPopupMenu
36198>            On_Item "&View to Maintain WorkSpc\aCtrl+1" Send Activate_Workspc
36199>        End_Pull_down
36201>        Set Status_Help To "Available Views"
36202>        
INCLUDING FILE: NAVI_PM.INC
36202>>Use DFDEOMnu
36202>>
36202>>DFCreate_Menu "&Navigation" NAVIGATE_Menu is a DEOPopupMenu
36206>>    On_Item "&Next Area\aF6"            send Switch_Next_Area
36207>>        Set Status_Help To  'Move to Next Area'
36208>>
36208>>    On_Item "&Previous Area\aShift+F6"  send Switch_Prior_Area
36209>>        Set Status_Help To  'Move to Previous Area'
36210>>
36210>>    On_Item "N&ext View\aAlt+F6"        send Switch_Next_View
36211>>        Set Status_Help To  'Move to Next View'
36212>>
36212>>    On_Item "P&revious View\aCtrl+F6"   send Switch_Prior_View
36213>>        Set Status_Help To  'Move to Previous View'
36214>>
36214>>    On_Item ""                          send none
36215>>
36215>>    On_Item "&List\aF4"               send Prompt
36216>>        Set Status_Help To  'Show Selection Lists'
36217>>
36217>>    On_Item "&Zoom\aAlt+F9"             send Zoom
36218>>        Set Status_Help To  'Show Zoom'
36219>>
36219>>    Procedure OnInitMenu
36221>>        Local integer Obj# IsDeo Itm prmpt zm isDeoControl
36222>>        Get Focus to Obj#
36223>>        Get is_Function Get_DEO_Object Obj# TRUE to IsDeo
36224>>        If IsDeo Begin
36226>>            Get is_Function Get_DEO_Control_Object Obj# False to IsDeoControl
36227>>            If IsDeoControl Begin
36229>>                Get Prompt_Object of Obj# to Prmpt
36230>>                Get Zoom_Object of Obj# to zm
36231>>            End
36231>>>
36231>>            Set Shadow_state item 0  to False
36232>>            Set Shadow_state item 1  to False
36233>>            Set Shadow_state item 2  to False
36234>>            Set Shadow_state item 3  to False
36235>>            Set Shadow_state item 5  to (Prmpt=0)
36236>>            Set Shadow_state item 6  to (Zm=0)
36237>>        End
36237>>>
36237>>        Else Begin
36238>>            for itm from 0 to 6
36244>>>
36244>>                set shadow_State item itm to TRUE
36245>>            Loop
36246>>>
36246>>        End
36246>>>
36246>>    End_Procedure
36247>>
36247>>End_Pull_Down
36249>>Set Status_Help to "Navigation in different areas of the screen"
36250>>
INCLUDING FILE: WIN_PM.INC
36250>>DFCreate_Menu "&Window" Window_Menu
36254>>    Set select_mode to Multi_Select
36255>>    // normal number of items in pulldown (w/ no active views)
36255>>    property integer std_item_count public 0
36257>>
36257>>    DFCreate_Menu "&Preferences" Display_Options_Menu
36261>>        Set select_mode to Multi_Select
36262>>        On_Item "&ToolBar"        Send Toggle_Toolbar             To Self
36263>>        On_Item "&StatusBar"      Send Toggle_Statusbar           To Self
36264>>        On_Item "&Arrange Icons"  Send Toggle_Auto_Arrange_Icons  To Self
36265>>
36265>>        //  When ever the menu [pulldown] is initialized, check/set
36265>>        //  the state of its items.
36265>>        //
36265>>        Procedure OnInitMenu
36267>>            local integer bState
36268>>
36268>>            Get ToolBar_State to bState
36269>>            Set Select_State Item 0 to bState
36270>>            if  bState   Set Status_Help Item 0 To '' //'Hide the ToolBar'
36273>>            Else         Set Status_Help Item 0 to '' //'Show the ToolBar'
36275>>
36275>>            Get Statusbar_State to bState
36276>>            Set Select_State Item 1 to bState
36277>>            if  bState  Set Status_Help Item 1 To ''// 'Hide the StatusBar'
36280>>            Else        Set Status_Help Item 1 to ''// 'Show the StatusBar'
36282>>
36282>>            Get Auto_Arrange_Icons_State to bState
36283>>            Set Select_State Item 2 to bState
36284>>            if  bState  Set Status_Help Item 2 To '' //'Hide AutoArrange Icons'
36287>>            Else        Set Status_Help Item 2 to '' //'Show AutoArrange Icons'
36289>>
36289>>        End_procedure
36290>>
36290>>
36290>>    End_Pull_Down
36292>>    Set Status_Help                                           To '' //"Enable Toolbar, StatusBar, and AutoArrange Icons options"
36293>>
36293>>    On_Item ""
36294>>
36294>>    On_Item "&Cascade" send Cascade_Windows                   To Self
36295>>        Set Status_Help                                       To ''
36296>>
36296>>    On_Item "Tile &Horizontally" send Tile_Windows_Horizontal To Self
36297>>        Set Status_Help                                       To ''
36298>>
36298>>    On_Item "Tile &Vertically" send Tile_Windows_Vertical     To Self
36299>>        Set Status_Help                                       To ''
36300>>
36300>>    On_Item ""
36301>>
36301>>    On_Item "Minimize all" send Minimize_all_Windows          To Current_Object
36302>>        Set Status_Help                                       To ''
36303>>
36303>>    On_Item "&Restore all" send Restore_all_Windows           To Current_Object
36304>>        Set Status_Help                                       To ''
36305>>
36305>>    On_Item ""
36306>>
36306>>    On_Item "&Arrange Icons" send Arrange_Icons               To Current_Object
36307>>        Set Status_Help                                       To ''
36308>>
36308>>    // set this to the number of items in the menu with no views.
36308>>    Set Std_item_count to (item_count(current_object))
36309>>
36309>>    // add all active views to the end of the menu
36309>>    Procedure OnInitMenu
36311>>        local integer iStdCnt iNumCnt hVw hCl iCount
36312>>        Local string sLbl
36312>>        //*** Remove all old view items
36312>>        Get Item_count     to iNumCnt
36313>>        get Std_item_count to iStdCnt
36314>>        For iCount from 1  to (iNumCnt - iStdCnt)
36320>>>
36320>>            Send Delete_item iStdCnt
36321>>        Loop
36322>>>
36322>>
36322>>        Move iStdcnt to iNumCnt
36323>>        get Client_id to hCl // object id of client area
36324>>        If hCl Begin
36326>>           Get Next_Mdi_Dialog of hcl TRUE to hVw // find first view
36327>>           While hVw
36331>>              if (Active_state(hVw)) Begin
36333>>                 if iNumCnt eq iStdCnt Begin // if first view, add separator
36335>>                    send add_item 0 ''
36336>>                    increment iNumCnt
36337>>                 end
36337>>>
36337>>                 Get Label of hVw to sLbl // caption bar (name) of view
36338>>                 // note that all views understand the message activate_view.
36338>>                 send add_item msg_activate_view sLbl // set message, value and destination
36339>>                 set aux_value item iNumcnt to hVw
36340>>                 // if this is the focus view, mark it.
36340>>                 If (current_scope(desktop)=hVw and View_mode(hVw)<>VIEWMODE_ICONIZE) ;                     set select_state item iNumCnt to True
36343>>                 // create status help
36343>>                 Set Status_help item iNumCnt to ("Make this view (" - trim(sLbl) - ") the active window.")
36344>>                 increment iNumCnt
36345>>              end
36345>>>
36345>>              Get Next_Mdi_Dialog of hcl FALSE to hVw // find next
36346>>           End
36347>>>
36347>>        End
36347>>>
36347>>    End_Procedure // OnInitMenu
36348>>
36348>>End_Pull_Down
36350>>Set Status_Help to ''
INCLUDING FILE: HELPA_PM.INC
36351>>
36351>>
36351>>DFCreate_Menu "&Help" Help_Menu
36355>>    on_item "&Help Topic" send Help_on_topic
36356>>        Set Status_Help To "Search for help on a particular subject."
36357>>        on_item "" send NONE
36358>>    on_item "&Context Help"          send Extended_Help
36359>>        Set Status_Help To "Show Context sensitive help."
36360>>
36360>>    on_item "&Files Help"            send File_Help
36361>>        Set Status_Help To "Show Files help."
36362>>
36362>>    on_item "&Keys Help"             send Keys_Help
36363>>        Set Status_Help To "Show Keys help."
36364>>
36364>>    on_item "" send NONE
36365>>
36365>>    on_item "&How to Use Help"       send Help_For_Help
36366>>        Set Status_Help To "How to Use Help"
36367>>
36367>>    on_item "" send NONE
36368>>
36368>>    On_Item "&Tips of the Day" send Activate_TipOfDay
36369>>        Set Status_Help To "Tips of the Day"
36370>>
36370>>    on_item "" send NONE
36371>>
36371>>    On_item "About" Send Activate_About
36372>>        Set Status_Help To "System Information"
36373>>end_pull_down
36375>>Set Status_Help to "Access to the program's help subsystem"
36376>>
36376>>Register_Procedure Activate_TipOfDay
36376>>
36376>>
36376>    End_Menu
36378>
36378>    Use DFStdBtn.pkg //  Tool-Bar object.
INCLUDING FILE: DFSTDBTN.PKG
36378>>>// 07/23/96 JJT - New Class names
36378>>>// 10/03/97 KCR - removed leading separator
36378>>>
36378>>>Use DFMainBt  // dfMain_ButtonBar
INCLUDING FILE: DFMAINBT.PKG
36378>>>>>//-------------------------------------------------------------------------
36378>>>>>// DFMainBt.pkg - DfMain_ButtonBar class
36378>>>>>//
36378>>>>>//
36378>>>>>// 07/23/96 JJT - New Class names
36378>>>>>//-------------------------------------------------------------------------
36378>>>>>
36378>>>>>Use DfPanel // dfapp_buttonbar
36378>>>>>
36378>>>>>Class ToolBar is a AppToolBar
36379>>>>>
36379>>>>>    Function Is_Function Integer MsgId Integer ObjId Integer DelegateFg Returns Integer
36380>>>>>      Local integer rval MainObj#
36381>>>>>      Get Main_Panel_id to MainObj#
36382>>>>>      If (ObjId>Desktop AND MainObj#) ;         Get Is_Function of MainObj# MsgId ObjId DelegateFg to rVal
36385>>>>>      Function_Return rVal
36386>>>>>    End_Function
36387>>>>>
36387>>>>>    Procedure Redirect_Button_Message integer Itm
36388>>>>>         Local integer Msg# Aux# rval Understood
36389>>>>>         If (Shadow_State(Current_Object,itm)) Procedure_Return
36392>>>>>         Get Message   item itm  to Msg#
36393>>>>>         Get Aux_Value item itm  to Aux#
36394>>>>>         If Msg# Begin
36396>>>>>           If Aux# eq 0 Begin
36398>>>>>              Get Focus to Aux#
36399>>>>>              Get Is_Function Get_DEO_Object Aux# TRUE to Understood
36400>>>>>              If Not Understood Move 0 to Aux#
36403>>>>>           End
36403>>>>>>
36403>>>>>           If Aux# Get Msg# of Aux# to rval
36406>>>>>           Procedure_return rval
36407>>>>>         end
36407>>>>>>
36407>>>>>    End_Procedure // Redirect_Message
36408>>>>>
36408>>>>>End_Class
36409>>>>>
36409>>>>>
36409>>>
36409>>>//  Button bar object.
36409>>>
36409>>>Object Tool_Bar is a ToolBar
36411>>>
36411>>>    Send ImageList_Add 'bgn.bmp'   // 0
36412>>>    Send ImageList_Add 'end.bmp'   // 1
36413>>>    Send ImageList_Add 'next.bmp'  // 2
36414>>>    Send ImageList_Add 'prev.bmp'  // 3
36415>>>    Send ImageList_Add 'clr.bmp'   // 4
36416>>>    Send ImageList_Add 'clra.bmp'  // 5
36417>>>
36417>>>    send Add_button (ico_user+0) msg_beginning_of_data
36418>>>    Send Add_ToolTip "Beginning of file"
36419>>>    Set  Status_Help To 'Find the First record (Ctrl+Home)'
36420>>>
36420>>>    send Add_button (ico_user+3) msg_find_previous
36421>>>    Send Add_ToolTip "Find Previous"
36422>>>    Set  Status_Help To 'Find the Previous record (F7)'
36423>>>
36423>>>    send Add_button (ico_user+2) msg_find_next
36424>>>    Send Add_ToolTip "Find Next"
36425>>>    Set  Status_Help To 'Find the Next record (F8)'
36426>>>
36426>>>    send Add_button (ico_user+1) msg_end_of_data
36427>>>    Send Add_ToolTip "End of File"
36428>>>    Set  Status_Help To 'Find the Last record (Ctrl+End)'
36429>>>
36429>>>    Send Add_space
36430>>>
36430>>>    send Add_button ico_std_find msg_prompt
36431>>>    Send Add_ToolTip "Prompt"
36432>>>    Set  Status_Help To 'Show available selections (F4)'
36433>>>
36433>>>    send Add_button (ico_user+4) msg_request_clear
36434>>>    Send Add_ToolTip "Clear"
36435>>>    Set  Status_Help To 'Clear current record / Add a new record (F5)'
36436>>>
36436>>>    send Add_button (ico_user+5) msg_request_clear_all
36437>>>    Send Add_ToolTip "Clear All"
36438>>>    Set  Status_Help To 'Clear all data from view (Ctrl+F5)'
36439>>>
36439>>>    send Add_space
36440>>>
36440>>>    send Add_button ico_std_filesave msg_request_save
36441>>>    Send Add_ToolTip "Save"
36442>>>    Set  Status_Help To 'Save the current record (F2)'
36443>>>
36443>>>    send Add_button ico_std_delete msg_request_delete
36444>>>    Send Add_ToolTip "Delete"
36445>>>    Set  Status_Help To 'Delete the current record (Shift+F2)'
36446>>>
36446>>>    send Add_space
36447>>>
36447>>>    send Add_button ico_std_cut msg_cut
36448>>>    Send Add_ToolTip "Cut"
36449>>>    Set  Status_Help to "Cuts the selection and puts it on the Clipboard"
36450>>>
36450>>>    send Add_button ico_std_copy msg_copy
36451>>>    Send Add_ToolTip "Copy"
36452>>>    Set  Status_Help to "Copies the selection and puts it on the Clipboard"
36453>>>
36453>>>    send Add_button ico_std_paste msg_paste
36454>>>    Send Add_ToolTip "Paste"
36455>>>    Set  Status_Help to "Inserts Clipboard contents"
36456>>>
36456>>>End_Object
36457>>>
36457>    
36457>    Object Client_Area is a AppClientAreaSub
36459>
36459>        //AB-ClientStoreTopStart
36459>        String  Plhktro_BIP  Plhktro_Esc  Plhktro_N11  Plhktro_N00  Plhktro_FS  Plhktro_AAA  Plhktro_DSI
36459>        String  Plhktro_SO   Plhktro_DC4     //expanded for 1 line
36459>        String  Plhktro_SI   Plhktro_DC2     //condesed
36459>        String  Plhktro_PAV              //underline
36459>        String  Plhktro_EEE  Plhktro_FFF     //emphasized
36459>        String  Plhktro_GGG  Plhktro_HHH     //double strike
36459>        String  Plhktro_WWW              //expanded
36459>        string  Plhktro_Q Plhktro_160
36459>        Integer giviewid
36459>        String  gsviewname
36459>        
36459>        Use DD_Sec.Sub
36459>        use dbviews.sub
INCLUDING FILE: DBVIEWS.SUB
36459>>>
36459>>>Class DbviewSubs Is A DbviewSub
36460>>>
36460>>>    Procedure Construct_Object
36461>>>        Integer iPos iCount
36462>>>        Forward Send Construct_Object
36464>>>
36464>>>        Property String     psMyViewName    Public ''
36465>>>        Property Integer    piMyViewID      Public  0
36466>>>
36466>>>        Get Name            to gsViewName
36467>>>        Get Object_ID       to giViewID
36468>>>
36468>>>        Move 0 to iPos
36469>>>        For iCount From 1 to (Length(gsViewName))
36475>>>>
36475>>>            If (Mid(gsViewName,1,iCount)='.') Move iCount to iPos
36478>>>        Loop
36479>>>>
36479>>>        Move (Right(gsViewName,(Length(gsViewName)-iPos))) to gsViewName
36480>>>        Move (Trim(gsViewName)) to gsViewName
36481>>>
36481>>>        Set psMyViewName    to (Trim(gsViewName))
36482>>>        Set piMyViewID      to giViewID
36483>>>
36483>>>    End_Procedure
36484>>>
36484>>>    Procedure End_Construct_Object
36485>>>        Integer iFileNumber iFieldNumber iUser iColor iLimit iBase iCurr iCol iDeo iPos
36486>>>        Integer iObj iPrototype iColumn iItem iInt iFieldStatus iCurCol iCount
36486>>>        String  sFileName sFieldName sUser sRecr sStr sDbFormName sViewLabel sDeo svn
36486>>>
36486>>>        Forward Send End_Construct_Object
36488>>>
36488>>>
36488>>>        Get psMyViewName        to gsViewName
36489>>>        Get piMyViewID          to giViewID
36490>>>        Get Label Of giViewID   to sViewLabel
36491>>>        Move (Trim(sViewLabel)) to sViewLabel
36492>>>
36492>>>        Clear Oth
36493>>>        Move gsViewName to Oth.View_Name
36494>>>        Find eq Oth By Index.2 // Oth:Index.2:View_Name
36495>>>>
36495>>>        If (Not(Found)) Begin
36497>>>            Move sViewLabel to Oth.View_Label
36498>>>            Move giViewID    to Oth.View_ID
36499>>>            Saverecord Oth
36500>>>        End
36500>>>>
36500>>>
36500>>>    End_Procedure //End_Construct_Object
36501>>>
36501>>>End_Class //dbviewSubs
36502>>>
36502>>>
36502>        use dbforms.sub
INCLUDING FILE: DBFORMS.SUB
36502>>>
36502>>>Class dbFormSubs Is a dbFormSub
36503>>>
36503>>>//    Register_Procedure Set psMyViewName
36503>>>//    Register_Function      psMyViewName Returns String
36503>>>//    Register_Procedure Set piMyViewID
36503>>>//    Register_Function      piMyViewID   Returns Integer
36503>>>
36503>>>    Procedure End_Construct_Object
36504>>>        Integer iFileNumber iFieldNumber iServer
36505>>>        Integer iPos icount iColor iFieldStatus iFileNumber2
36505>>>        String  sStr sDbFormName sViewLabel
36505>>>
36505>>>        Forward Send End_Construct_Object
36507>>>
36507>>>        //If (SysRec.Scr_Fld_Lock='1') Begin
36507>>>
36507>>>            Get Name            to sDbFormName
36508>>>            Get psMyViewName    to gsViewName
36509>>>            Get piMyViewID      to giViewID
36510>>>
36510>>>            Move 0 to iPos
36511>>>            For iCount From 1 to (Length(sDbFormName))
36517>>>>
36517>>>                If (Mid(sDbFormName,1,iCount)='.') Move iCount to iPos
36520>>>            Loop
36521>>>>
36521>>>            Move (Right(sDbFormName,(Length(sDbFormName)-iPos))) to sDbFormName
36522>>>            Move (Trim(sDbFormName)) to sDbFormName
36523>>>
36523>>>            Move (Trim(gsViewName)) to gsViewName
36524>>>
36524>>>            Clear Oth
36525>>>            Move gsViewName to Oth.View_Name
36526>>>            Find eq Oth By Index.2 // Oth:Index.2:View_Name
36527>>>>
36527>>>            Move Oth.View_Label to sViewLabel
36528>>>            Move (Trim(sViewLabel)) to sViewLabel
36529>>>
36529>>>            Clear ViewFlds
36530>>>            Move gsViewName     to ViewFlds.View_Name
36531>>>            Move sDbFormName    to ViewFlds.Scr_Field_Name
36532>>>            Find eq ViewFlds By Index.1 // ViewFlds:Index.1:View_Name+Scr_Field_Name
36533>>>>
36533>>>            If (Not(Found)) Begin
36535>>>                Reread Sysrec
INCLUDING FILE: SYSREC.FD
36539>>>                Move (SysRec.Viewflds_Rec0+1) to ViewFlds.ViewFlds_Rec0
36540>>>                Move (SysRec.Viewflds_Rec0+1) to SysRec.ViewFlds_Rec0
36541>>>                Saverecord SysRec
36542>>>                UnLock
36543>>>>
36543>>>                Move sViewLabel to ViewFlds.View_Label
36544>>>                Saverecord ViewFlds
36545>>>            End
36545>>>>
36545>>>            Else If ((Trim(ViewFlds.View_Label)='') And (sViewLabel<>'')) Begin
36548>>>                Reread ViewFlds
36552>>>                Move sViewLabel to ViewFlds.View_Label
36553>>>                Saverecord ViewFlds
36554>>>                Unlock
36555>>>>
36555>>>            End
36555>>>>
36555>>>            Move (fiScreenFieldStatus(gsViewName,sDbFormName))  to iFieldStatus
36556>>>
36556>>>
36556>>>        // iFieldStatus=0 ==> EVERYTHING IS ALLOWED
36556>>>        // iFieldStatus=1 ==> NO READ ALLOWED
36556>>>        // iFieldStatus=2 ==> NO EDIT BUT CAN COPY
36556>>>        // iFieldStatus=3 ==> NO EDIT AND NO COPY
36556>>>        If (Not(iFieldStatus)) Begin
36558>>>            ////// Field is NORMAL ////////
36558>>>        End
36558>>>>
36558>>>        Else Begin
36559>>>            If (iFieldStatus=1) Begin
36561>>>                ////// Field is NO DISPLAY ////////
36561>>>                Set Enabled_State   Item 0 to False
36562>>>                Set Entry_State     Item 0 to False
36563>>>                Get Color                  to iColor
36564>>>                Set TextColor              to iColor
36565>>>            End
36565>>>>
36565>>>            Else Begin
36566>>>                If (iFieldStatus=2) Begin
36568>>>                    ////// Field is NO EDIT  /////////
36568>>>                    Get Server                                      to iServer
36569>>>                    Get Data_File   Item 0                          to iFileNumber
36570>>>                    If (iServer) Get piFN of iServer                to iFileNumber2
36573>>>
36573>>>                    // €¤ ¦ server œå¤˜  › ˜­¦¨œ« ¡æª ˜§¦ «¦¤ ˜¨ Ÿ£¦ «¦¬ datafile «¦¬ §œ› ¦¬
36573>>>                    // «¦«œ «¦ §œ›å¦ œå¤˜  £§˜£§áª ¡˜  «¦ Noput ›œ¤ §˜ œ  ¦§¦«œ ¡æ™¦¬£œ «¦ Enter
36573>>>                    If (iFileNumber=iFileNumber2)   Set Item_Option Item 0  to Noput True
36576>>>                    Else                            Set Item_Option Item 0  to NoEnter True
36578>>>                End
36578>>>>
36578>>>                Else Begin
36579>>>                    If (iFieldStatus=3) Begin
36581>>>                        ////// Field is NO EDIT AND NO COPY     /////////
36581>>>                        Set Enabled_State   Item 0 to False
36582>>>                        Set Entry_State     Item 0 to False
36583>>>                        Set Shadow_State    Item 0 to True
36584>>>                    End
36584>>>>
36584>>>                End
36584>>>>
36584>>>            End
36584>>>>
36584>>>        End
36584>>>>
36584>>>     End_Procedure
36585>>>
36585>>>End_Class //DbformSubs
36586>>>
36586>        
36586>        Use Stbarpsc.pkg
INCLUDING FILE: STBARPSC.PKG
36586>>>Use DFStatBr.pkg
36586>>>
36586>>>Class BasicPanelStatusBarSub is a BasicStatusBar
36587>>>
36587>>>    Procedure Construct_Object
36588>>>        Forward Send Construct_Object
36590>>>        Property Integer Status_Help_Item Public 0
36591>>>        Property Integer Menu_Simple_State public TRUE
36592>>>        Property Integer Menu_status_State public False
36593>>>        Property Integer Old_Simple_State  public false
36594>>>        Property String  Old_Status_Value  public ''
36595>>>        Set Attach_Parent_State To TRUE
36596>>>        Delegate Set StatusBar_id To Self
36598>>>    End_Procedure
36599>>>
36599>>>    Procedure SET Status_Help_Value String sHelp
36600>>>        Local Integer iPart
36601>>>        Get Status_Help_Item To iPart
36602>>>        Set Value item iPart To sHelp
36603>>>    End_Procedure
36604>>>
36604>>>    Function Status_Help_Value Returns String
36605>>>        Local Integer iPart
36606>>>        Local String sHelp
36606>>>        Get Status_Help_Item To iPart
36607>>>        Get Value item iPart To sHelp
36608>>>        Function_Return sHelp
36609>>>    End_Procedure
36610>>>
36610>>>    Procedure Initialize_Menu
36611>>>       Local integer iState OldState
36612>>>       If Not (Menu_Status_state(Self)) Begin
36614>>>          Get Simple_State to OldState
36615>>>          Set Old_Simple_State to OldState
36616>>>          If OldState   Set Old_Status_Value to (Simple_Value(Self))
36619>>>          Else          Set Old_Status_Value to (Status_Help_Value(Self))
36621>>>          Set Simple_State to (Menu_Simple_State(Self))
36622>>>          Set Menu_Status_State to TRUE
36623>>>       End
36623>>>>
36623>>>    End_Procedure
36624>>>
36624>>>    Procedure Exit_Menu
36625>>>       Local Integer OldState
36626>>>       Local String OldVal
36626>>>       If (Menu_Status_state(Self)) Begin
36628>>>          Get Old_Simple_State to OldState
36629>>>          Set Simple_State     to OldState
36630>>>          Get old_status_Value to oldVal
36631>>>          If OldState ;             Set Simple_Value to OldVal
36634>>>          Else ;             Set Status_Help_Value to OldVal
36636>>>          Set Menu_Status_State to FALSE
36637>>>       End
36637>>>>
36637>>>    End_Procedure // Exit_Menu
36638>>>
36638>>>    Procedure Show_Status_Help String sHelp
36639>>>        Local Integer iState
36640>>>        Get Simple_State to iState
36641>>>        If NOT iState Set Status_Help_Value To sHelp
36644>>>        Else          Set Simple_Value      To sHelp
36646>>>    End_Procedure
36647>>>
36647>>>    Function Current_Status_Help Returns String
36648>>>        Local Integer iState
36649>>>        Local String sHelp
36649>>>        Get Simple_State to iState
36650>>>        If NOT iState Get Status_Help_Value To sHelp
36653>>>        Else          Get Simple_Value      To sHelp
36655>>>        Function_Return sHelp
36656>>>    End_Function
36657>>>
36657>>>
36657>>>End_Class
36658>        
36658>        //Use bpKost1.dg
36658>        
36658>        
36658>        Register_Object oStatusBarSub
36658>        
36658>        Open Syscurxr
36660>        Open SysFile
36662>        Open Sysrecc
INCLUDING FILE: SYSRECC.FD
36664>        Open Sysrecb
INCLUDING FILE: SYSRECB.FD
36666>        Open Sysrecw
INCLUDING FILE: SYSRECW.FD
36668>        
36668>        Procedure Reset_All_Files_Except_System
36670>            Local Integer File# Open# File_Number# liInt iMax iWait isSystem
36671>            Local String Physicalname# DisplayName# Logicalname# Rootname#
36671>            Move 0 To File#
36672>            Repeat
36672>              Get_Attribute Df_File_Next_Opened Of File# To File#
36675>              If (File#) Begin
36677>                Get_Attribute DF_FILE_IS_SYSTEM_FILE    Of File# To isSystem
36680>                If (NOT(isSystem)) Clear File#
36683>              End
36683>            Until File# Eq 0
36685>        End_Procedure
36686>        
INCLUDING FILE: FEM.PKG
36686>>///////////////////////////////////////////////
36686>>// Ginetai #Include sto Program //
36686>>///////////////////////////////////////////////
36686>>Use Idiotht.pkg
36686>>
36686>>Integer igC
36686>>String  sgC sgFull sgRootDir sgDevicePath
36686>>Move 0 to igC
36687>>
36687>>Move (fsReadRegistryFEMRootDir   ()) To sgRootDir
36688>>Move (fsReadRegistryFEMDevicePath()) To sgDevicePath
36689>>
36689>>// An den yparxoun ta settings sto registry (apo Setup Egkatastashs)
36689>>// Tote ta ftiaxnoume me ex orismou C:\FEM_ROOT\ & C:\FEM_ROOT\Device_File1.dat
36689>>// mesa apo tis 2 parakato functions (sto Idiotht.pkg)
36689>>If (Trim(sgRootDir)   ='') Get fiWriteRegistryFEMRootDir    to iGC
36692>>If (Trim(sgDevicePath)='') Get fiWriteRegistryFEMDevicePath to iGC
36695>>//
36695>>
36695>>// ** START ** Function ths forologikhs ektypotikhs mhxanhs
36695>>External_Function32 FSL_Command "FSL_Command" rapidsign.dll;                    String  sBaseDir    ;                    String  sCommand    ;                    String  sDevFile    ;                    String  sParam1     ;                    String  sParam2     ;                    Returns Integer
36696>>
36696>>External_Function32 FSL_SignDocument "FSL_SignDocument" rapidsign.dll;                    String  sDevFile    ;                    String  sParam      ;                    String  sResult     ;                    Returns Integer
36697>>// ** END ** Function ths forologikhs ektypotikhs mhxanhs
36697>>
36697>>
36697>>// ** START ** Gemisma global string me escape xarakthron gia afairesh tous apo to ascii ths forologikhs
36697>>Move '' to sgC
36698>>For igC From 1 to 254
36704>>>
36704>>    If ((igC<32) Or ((igC>175) And (igC<224)) Or (igC>240)) Begin
36706>>        Move (Append(sgC,Character(igC))) to sgC
36707>>    End
36707>>>
36707>>Loop
36708>>>
36708>>// ** END ** Gemisma escape xarakthron gia afairesh tous apo to ascii ths forologikhs
36708>>
36708>>
36708>>Function fiEtoimaseTaAscii Returns Integer
36710>>    Integer iFileExist iii iii2 isOK
36711>>    String  sLine sLine2 sLetter sLetter2
36711>>    // 1. Check if file was outputed (C:\##Parast.txt)
36711>>    Get Get_File_Exists 'C:\##Parast.txt' to iFileExist
36712>>    If (Not(iFileExist)) Function_Return 12556
36715>>
36715>>    // 2. Check if file is outputed but empty
36715>>    Direct_Input Channel 7 "C:\##Parast.txt"
36717>>    If (Seqeof) Begin
36719>>        Close_Input Channel 7
36721>>        Function_Return 12557
36722>>    End
36722>>>
36722>>
36722>>    // 3. Strip file from escape sequences
36722>>    Direct_Output Channel 9 "C:\##Parast0.txt"
36724>>    Repeat
36724>>>
36724>>        Readln Channel 7 sLine
36726>>        For iii From 1 to (Length(sgC))
36732>>>
36732>>            Move (Replaces((Mid(sgC,1,iii)),sLine,' ')) to sLine
36733>>        Loop
36734>>>
36734>>        Writeln Channel 9 sLine
36737>>    Until (Seqeof)
36739>>    Close_Input Channel 7
36741>>    Close_Output Channel 9
36743>>
36743>>    // 4. Check if new ascii without escape
36743>>    //    sequences is outputed (C:\##Parast0.txt)
36743>>    Get Get_File_Exists 'C:\##Parast0.txt' to iFileExist
36744>>    If (Not(iFileExist)) Function_Return 12558
36747>>
36747>>    // 5. Check if new file is outputed but empty
36747>>    Direct_Input Channel 7 "C:\##Parast0.txt"
36749>>    If (Seqeof) Begin
36751>>        Close_Input Channel 7
36753>>        Function_Return 12559
36754>>    End
36754>>>
36754>>
36754>>    // 6. Convert file to ELOT
36754>>    Direct_Output Channel 9 "C:\##Parast1.txt"
36756>>    Repeat
36756>>>
36756>>        Readln Channel 7        sLine
36758>>        Move (ToAnsi(sLine)) to sLine2
36759>>        Writeln Channel 9       sLine2
36762>>    Until (Seqeof)
36764>>    Close_Input  Channel 7
36766>>    Close_Output Channel 9
36768>>
36768>>    // 7. Check if converted ELOT ascii is outputed (C:\##Parast1.txt)
36768>>    Get Get_File_Exists 'C:\##Parast1.txt' to iFileExist
36769>>    If (Not(iFileExist)) Function_Return 12560
36772>>
36772>>    // 8. Check if converted ELOT ascii is NOT Empty
36772>>    Direct_Input Channel 7 "C:\##Parast1.txt"
36774>>    If (Seqeof) Begin
36776>>        Close_Output Channel 7
36778>>        Function_Return 12561
36779>>    End
36779>>>
36779>>    Close_Output Channel 7
36781>>
36781>>    Function_Return 1 // Everything OK
36782>>End_function
36783>>
36783>>Function fiPareYpografh Returns String
36785>>    Integer iFileExist iii iii2 isOK
36786>>    String  sLine sLine2 sLetter sLetter2
36786>>    Move 0 to isOK
36787>>
36787>>    Move (FSL_Command(sgRootDir,'SIGN',sgDevicePath ,'C:\##Parast1.txt','C:\##Signature.txt')) to isOK
36788>>    If (isOK<>0) Function_Return ''
36791>>
36791>>    Direct_Input Channel 7 'C:\##Signature.txt'
36793>>    If (Seqeof) Function_Return '12562'
36796>>    Readln Channel 7 sLine
36798>>    Move (Trim(sLine)) to sLine
36799>>    If (Length(sLine)<>77) Function_Return '12563'
36802>>
36802>>    EraseFile "C:\##Parast*.txt"
36803>>>
36803>>    EraseFile "C:\##Signature.txt"
36804>>>
36804>>
36804>>    Function_return (Trim(sLine))
36805>>End_function
36806>>
36806>>Function fiVgaleZ Returns Integer
36808>>    Integer isOK
36809>>    Move 0 to isOK
36810>>    Move (FSL_Command(sgRootDir,'Z',sgDevicePath ,'','')) to isOK
36811>>    Function_return isOK
36812>>    // 0= ok
36812>>End_function
36813>>
36813>>Function fiShowCTL Returns Integer
36815>>    Integer isOK
36816>>    Move 0 to isOK
36817>>    Move (FSL_Command(sgRootDir,'CTL',sgDevicePath ,'','')) to isOK
36818>>    Function_return isOK
36819>>    // 0= ok
36819>>End_function
36820>>
36820>>Use RptVwFem.Sub
INCLUDING FILE: RPTVWFEM.SUB
36820>>>>Use DFRptvw.pkg
36820>>>>Use dbRptvw.pkg
36820>>>>
36820>>>>Use RptVW.Sub
36820>>>>
36820>>>>Class ReportViewFEMSub is a ReportViewSub    
36821>>>>
36821>>>>    Procedure Construct_Object
36822>>>>        Forward Send Construct_Object
36824>>>>
36824>>>>        Property Integer    piIsReportCancelled     Public  0
36825>>>>        Property Integer    piAsciiOrPrinter        Public  0
36826>>>>    
36826>>>>    End_Procedure
36827>>>>    
36827>>>>
36827>>>>// ‡˜ â§¨œ§œ ž procedure ˜¬«ž
36827>>>>//
36827>>>>//    Procedure StartReport
36827>>>>//        send Gemise_Escape_Characters
36827>>>>//        String Whme_APO sRecr
36827>>>>//        integer wnees wclose
36827>>>>//        Local Integer iOutputDevice
36827>>>>//        Local String  FileName
36827>>>>//        local integer inew_state
36827>>>>//        Get Output_Device_Mode To iOutputDevice
36827>>>>//        get new_state to inew_state
36827>>>>//        set piprinter to 0
36827>>>>//        //?????????????????????????????????????????????
36827>>>>//        Get Output_Device_Mode To iOutputDevice
36827>>>>
36827>>>>//        If iOutputDevice EQ PRINT_TO_WINDOW Begin
36827>>>>//            Set piAsciiOrPrinter    to 0
36827>>>>//            Make_Temp_File "TXT" FileName
36827>>>>//            Move (".\" - FileName)  To FileName
36827>>>>//            Set Output_Device_Name  To FileName
36827>>>>//        End
36827>>>>//        Else Begin
36827>>>>
36827>>>>//            If (Sysfile.Use_Sql_Reports='1') Begin
36827>>>>//                If (piAsciiOrPrinter(Self)=0) Error 7000 'ƒœ¤ ©œ«á¨˜«œ «¦ piAsciiOrPrinter\n(ƒœ¤ §¨¦©› ¦¨å©«ž¡œ ˜¤ ˜­¦¨á ASCII ã „¡«¬§à«ã)'
36827>>>>//            End
36827>>>>
36827>>>>//            Get psRecr Of TIMOLOGIO_BasicReport to sRecr
36827>>>>//            Move (Trim(sRecr)) to sRecr
36827>>>>
36827>>>>//            If (sRecr='') Error 7003 'ƒœ¤ ¬§á¨®œ  Recr š ˜ «¦ §˜¨˜©«˜« ¡æ'
36827>>>>
36827>>>>//            Clear Particle
36827>>>>//            Move sRecr to Particle.Partl_Recr
36827>>>>//            Find Eq Particle by index.2
36827>>>>//            If (Not(Found)) Error 7001 'ƒœ¤ ™¨âŸž¡œ «¦ §˜¨˜©«˜« ¡æ'
36827>>>>
36827>>>>//            Clear Pseira
36827>>>>//            Move SyscurXr.Company_Code  to Pseira.Company_Code
36827>>>>//            Move SyscurXr.Branch_Code   to Pseira.Branch_Code
36827>>>>//            Move Particle.Ptyppar_Code  to Pseira.Ptyppar_Code
36827>>>>//            Move Particle.Pseira_Seira  to Pseira.Pseira_Seira
36827>>>>//            Find Eq Pseira By Index.1 // Pseira:Index.1:Company_Code+Branch_Code+Year_Year+Ptyppar_Code+Pseira_Seira
36827>>>>//            If (Not(Found)) Error 7002 'ƒœ¤ ™¨âŸž¡œ ž ©œ ¨á'
36827>>>>
36827>>>>//            If (piAsciiOrPrinter(Self)=1) Begin
36827>>>>//                // 1= Output ©œ Ascii
36827>>>>//                Set Output_Device_Name  To 'C:\##Parast.txt'
36827>>>>//            End
36827>>>>//            Else If (piAsciiOrPrinter(Self)=2) Begin
36827>>>>//                // 2= Output ©œ Printer
36827>>>>//                Set Output_Device_Name  To Pseira.Pseira_Printer
36827>>>>//            End
36827>>>>//            Else Error 7004 '’¦ Flag piAsciiOrPrinter ›œ¤ œå¤˜  ©à©«æ'
36827>>>>//        End
36827>>>>
36827>>>>//        Send Run_Report  //record
36827>>>>
36827>>>>//        If iOutputDevice EQ PRINT_TO_WINDOW Begin
36827>>>>//            RunProgram background "notepad" FileName
36827>>>>//            EraseFile FileName
36827>>>>//        End
36827>>>>
36827>>>>//    End_Procedure   // StartReport
36827>>>>
36827>>>>
36827>>>>End_Class
36828>>>>
36828>>>>Class dbReportViewFEMSub is a dbReportViewSub
36829>>>>    Procedure Construct_Object
36830>>>>        Forward Send Construct_Object
36832>>>>
36832>>>>        Property Integer    piIsReportCancelled     Public  0
36833>>>>        Property Integer    piAsciiOrPrinter        Public  0
36834>>>>    
36834>>>>    End_Procedure
36835>>>>End_Class
36836>>>>
36836>>Use BasrpFem.Sub
INCLUDING FILE: BASRPFEM.SUB
36836>>>>Use Dfrpt.pkg
36836>>>>
36836>>>>Use BasicRpt.Sub
INCLUDING FILE: BASICRPT.SUB
36836>>>>>>Use Dfrpt.pkg
36836>>>>>>
36836>>>>>>Class BasicReportSub is a BasicReport
36837>>>>>>
36837>>>>>>    Procedure Start_Log
36838>>>>>>        Send Log_Status ("Starting Report:"+Report_Title(Current_Object))
36839>>>>>>    End_Procedure // Start_Log
36840>>>>>>
36840>>>>>>    Procedure End_Log
36841>>>>>>        Send Log_Status ("Ending Report:  " + Report_Title(Current_Object))
36842>>>>>>    End_Procedure // End_Log
36843>>>>>>
36843>>>>>>    Procedure Error_Log_Status integer ErrNum integer Err_Line string ErrMsg
36844>>>>>>        Send Log_Status ("Error #"* String(ErrNum) + "." * ErrMsg)
36845>>>>>>    End_Procedure // Error_Log_Status
36846>>>>>>
36846>>>>>>    Procedure Update_Status_Page
36847>>>>>>        If (Page_End(Current_Object)) EQ 0 ;             Send Update_Status ("Record: " + String(Page_Count(Current_Object)))
36850>>>>>>        Else Send Update_Status ("Page: "   + String(Page_Count(Current_Object)))
36852>>>>>>    End_Procedure // Update_Status_Page
36853>>>>>>
36853>>>>>>    Procedure onError integer ErrNum integer Err_Line string ErrMsg
36854>>>>>>        If (Display_Error_State(Self)) Send End_Status
36857>>>>>>        Error 8888 '€¡ç¨à©ž „¡«ç§à©žª'
36858>>>>>>>
36858>>>>>>    End_procedure
36859>>>>>>
36859>>>>>>    Function Report_Interrupt Returns Integer
36860>>>>>>        Integer rVal
36861>>>>>>        String Mess
36861>>>>>>        If (Error_Check_State(Current_Object)) ;            Move "„£­˜¤å©«ž¡œ œ¤˜ ©­á¢£˜ ¡˜«˜ «ž¤ œ§œ¥œ¨š˜©å˜. Œ˜ › ˜¡¦§œå ž œ¡«ç§à©ž ?" to Mess
36864>>>>>>        Else   Move  "Œ˜ ˜¡¬¨é©à «ž¤ œ¡«ç§à©ž ?" to Mess
36866>>>>>>        Get YesNo_Box Mess "ƒ ˜¡¦§ã „§œ¥œ¨š˜©å˜ª" to rVal
36867>>>>>>        If (rVal=MBR_YES) Error 8888 '€¡ç¨à©ž „¡«ç§à©žª'
36870>>>>>>        Function_Return (Rval=MBR_YES)
36871>>>>>>    End_Function  // Report_Interrupt
36872>>>>>>
36872>>>>>>End_Class // BasicReportSub
36873>>>>>>
36873>>>>>>Class WinReportSub is a WinReport
36874>>>>>>
36874>>>>>>    Procedure Start_Log
36875>>>>>>        Send Log_Status ("Start Report:"+Report_Title(Current_Object))
36876>>>>>>    End_Procedure // Start_Log
36877>>>>>>
36877>>>>>>    Procedure End_Log
36878>>>>>>        Send Log_Status ("End Report:  " + Report_Title(Current_Object))
36879>>>>>>    End_Procedure // End_Log
36880>>>>>>
36880>>>>>>    Procedure Error_Log_Status integer ErrNum integer Err_Line string ErrMsg
36881>>>>>>        Send Log_Status ("Error #"* String(ErrNum) + "." * ErrMsg)
36882>>>>>>    End_Procedure // Error_Log_Status
36883>>>>>>
36883>>>>>>    Procedure Update_Status_Page
36884>>>>>>        If (Page_End(Current_Object)) EQ 0 ;            Send Update_Status ("Record: " + String(Page_Count(Current_Object)))
36887>>>>>>        Else Send Update_Status ("Page: " + String(Page_Count(Current_Object)))
36889>>>>>>    End_Procedure // Update_Status_Page
36890>>>>>>
36890>>>>>>    Procedure onError integer ErrNum integer Err_Line string ErrMsg
36891>>>>>>        If (Display_Error_State(Self)) Send End_Status
36894>>>>>>        Error 8888 '€¡ç¨à©ž „¡«ç§à©žª'
36895>>>>>>>
36895>>>>>>    End_procedure
36896>>>>>>
36896>>>>>>    Function Report_Interrupt Returns Integer
36897>>>>>>        Integer rVal
36898>>>>>>        String Mess
36898>>>>>>        If (Error_Check_State(Current_Object)) ;            Move "„£­˜¤å©«ž¡œ œ¤˜ ©­á¢£˜ ¡˜«˜ «ž¤ œ§œ¥œ¨š˜©å˜. Œ˜ › ˜¡¦§œå ž œ¡«ç§à©ž ?" to Mess
36901>>>>>>        Else   Move  "Œ˜ ˜¡¬¨é©à «ž¤ œ¡«ç§à©ž ?" to Mess
36903>>>>>>        Get YesNo_Box Mess "ƒ ˜¡¦§ã „§œ¥œ¨š˜©å˜ª" to rVal
36904>>>>>>        If (rVal=MBR_YES) Error 8888 '€¡ç¨à©ž „¡«ç§à©žª'
36907>>>>>>        Function_Return (Rval=MBR_YES)
36908>>>>>>    End_Function  // Report_Interrupt
36909>>>>>>
36909>>>>>>End_Class // WinReportSub
36910>>>>>>
36910>>>>
36910>>>>Class BasicReportFemSub is a BasicReportSub
36911>>>>
36911>>>>    Function Starting_Main_Report Returns Integer
36912>>>>        Integer   iRetVal iindexr14_1
36913>>>>        Forward Get Starting_Main_Report to iRetval
36915>>>>        If (Report_View_Id(Self)) Set piIsReportCancelled Of (Report_View_Id(Self)) to 0
36918>>>>        Function_Return iRetval
36919>>>>    End_Function
36920>>>>
36920>>>>    Procedure Ending_Report
36921>>>>        Integer isCancelled
36922>>>>        Get Cancelled_State         to isCancelled
36923>>>>        //If Already with error do not touch
36923>>>>        If (Report_View_Id(Self)) Begin
36925>>>>            If (piIsReportCancelled(Report_View_Id(Self))<>1) Begin
36927>>>>                Set piIsReportCancelled Of (Report_View_ID(Self)) to (isCancelled=1)
36928>>>>                Error 9999 '€¡ç¨à©ž „¡«ç§à©žª'
36929>>>>>
36929>>>>            End
36929>>>>>
36929>>>>            Else Error 7777 '‘­á¢£˜ ¡˜«á «ž¤ œ¡«ç§à©ž'
36931>>>>        End
36931>>>>>
36931>>>>        Forward Send Ending_Report
36933>>>>    End_Procedure
36934>>>>
36934>>>>    Procedure onError integer ErrNum integer Err_Line string ErrMsg
36935>>>>        If (Display_Error_State(Self)) Send End_Status
36938>>>>        Set piIsReportCancelled Of (Report_View_ID(Self)) to 1
36939>>>>        Error 8888 '€¡ç¨à©ž „¡«ç§à©žª'
36940>>>>>
36940>>>>    End_procedure
36941>>>>
36941>>>>    Function Report_Interrupt Returns Integer
36942>>>>        Integer rVal
36943>>>>        String Mess
36943>>>>        If (Error_Check_State(Current_Object)) ;            Move "„£­˜¤å©«ž¡œ œ¤˜ ©­á¢£˜ ¡˜«˜ «ž¤ œ§œ¥œ¨š˜©å˜. Œ˜ › ˜¡¦§œå ž œ¡«ç§à©ž ?" to Mess
36946>>>>        Else   Move  "Œ˜ ˜¡¬¨é©à «ž¤ œ¡«ç§à©ž ?" to Mess
36948>>>>        Get YesNo_Box Mess "ƒ ˜¡¦§ã „§œ¥œ¨š˜©å˜ª" to rVal
36949>>>>        If (rVal=MBR_YES) Error 8888 '€¡ç¨à©ž „¡«ç§à©žª'
36952>>>>        Function_Return (Rval=MBR_YES)
36953>>>>    End_Function  // Report_Interrupt
36954>>>>
36954>>>>
36954>>>>
36954>>>>End_Class
36955>>>>
36955>>>>Class WinReportFEMSub is a WinReportSUB
36956>>>>
36956>>>>    Function Starting_Main_Report Returns Integer
36957>>>>        Integer   iRetVal iindexr14_1
36958>>>>        Forward Get Starting_Main_Report to iRetval
36960>>>>        If (Report_View_Id(Self)) Set piIsReportCancelled Of (Report_View_Id(Self)) to 0
36963>>>>        Function_Return iRetval
36964>>>>    End_Function
36965>>>>
36965>>>>    Procedure Ending_Report
36966>>>>        Integer isCancelled
36967>>>>        Get Cancelled_State         to isCancelled
36968>>>>        //If Already with error do not touch
36968>>>>        If (Report_View_Id(Self)) Begin
36970>>>>            If (piIsReportCancelled(Report_View_Id(Self))<>1) Begin
36972>>>>                Set piIsReportCancelled Of (Report_View_ID(Self)) to (isCancelled=1)
36973>>>>                Error 9999 '€¡ç¨à©ž „¡«ç§à©žª'
36974>>>>>
36974>>>>            End
36974>>>>>
36974>>>>            Else Error 7777 '‘­á¢£˜ ¡˜«á «ž¤ œ¡«ç§à©ž'
36976>>>>        End
36976>>>>>
36976>>>>        Forward Send Ending_Report
36978>>>>    End_Procedure
36979>>>>
36979>>>>    Procedure onError integer ErrNum integer Err_Line string ErrMsg
36980>>>>        If (Display_Error_State(Self)) Send End_Status
36983>>>>        Set piIsReportCancelled Of (Report_View_ID(Self)) to 1
36984>>>>        Error 8888 '€¡ç¨à©ž „¡«ç§à©žª'
36985>>>>>
36985>>>>    End_procedure  
36986>>>>
36986>>>>    Function Report_Interrupt Returns Integer
36987>>>>        Integer rVal
36988>>>>        String Mess
36988>>>>        If (Error_Check_State(Current_Object)) ;            Move "„£­˜¤å©«ž¡œ œ¤˜ ©­á¢£˜ ¡˜«˜ «ž¤ œ§œ¥œ¨š˜©å˜. Œ˜ › ˜¡¦§œå ž œ¡«ç§à©ž ?" to Mess
36991>>>>        Else   Move  "Œ˜ ˜¡¬¨é©à «ž¤ œ¡«ç§à©ž ?" to Mess
36993>>>>        Get YesNo_Box Mess "ƒ ˜¡¦§ã „§œ¥œ¨š˜©å˜ª" to rVal
36994>>>>        If (rVal=MBR_YES) Error 8888 '€¡ç¨à©ž „¡«ç§à©žª'
36997>>>>        Function_Return (Rval=MBR_YES)
36998>>>>    End_Function  // Report_Interrupt
36999>>>>
36999>>>>End_Class
37000>>>>
37000>>
37000>        
37000>        //AB-ClientStoreTopEnd
37000>
37000>        //  Include all views
37000>        Use workspc.vw                                                                      
INCLUDING FILE: WORKSPC.VW
37000>>>//AB/ Project View to Maintain WorkSpc
37000>>>//AB/ Object prj is a View_Project
37000>>>//AB/     Set ProjectName to "View to Maintain WorkSpc"
37000>>>//AB/     Set ProjectFileName to "workspc.vw"
37000>>>
37000>>>// Project Object Structure
37000>>>//   Workspc is a dbViewSub
37000>>>//     Workspc_DD is a DataDictionary
37000>>>//     Workspc_ is a dbGridSub
37000>>>//     Workspc_Data_Path is a dbFormSub
37000>>>//     Workspc_Filelist_Path is a dbFormSub
37000>>>//     ButtonSub1 is a ButtonSub
37000>>>
37000>>>// Register all objects
37000>>>Register_Object ButtonSub1
37000>>>Register_Object Workspc
37000>>>Register_Object Workspc_
37000>>>Register_Object Workspc_Data_Path
37000>>>Register_Object Workspc_DD
37000>>>Register_Object Workspc_Filelist_Path
37000>>>
37000>>>
37000>>>//AB/ AppBuild VIEW
37000>>>
37000>>>//AB-IgnoreStart
37000>>>
37000>>>Use dbView.Sub
37000>>>Use DFAllEnt.pkg
37000>>>Use dbGrid.Sub
37000>>>Use dbForm.Sub
37000>>>Use Button.Sub
37000>>>
37000>>>Use WORKSPC.DD
37000>>>
37000>>>//AB-IgnoreEnd
37000>>>
37000>>>DEFERRED_VIEW Activate_Workspc FOR ;;Object Workspc is a dbViewSub
37019>>>    Set Border_Style to Border_Thick
37020>>>    Set Label to "ƒ ˜®œå¨ ©ž ˜¨®œå¦¬ WorkSpc"
37021>>>    Set Size to 239 522
37022>>>    Set Location to 5 5
37023>>>
37023>>>    //AB-DDOStart
37023>>>
37023>>>    Object Workspc_DD is a Workspc_DataDictionary
37025>>>    End_Object    // Workspc_DD
37026>>>
37026>>>    Set Main_DD to (Workspc_DD(self))
37027>>>    Set Server to (Workspc_DD(self))
37028>>>
37028>>>    //AB-DDOEnd
37028>>>
37028>>>    Object Workspc_ is a dbGridSub
37030>>>        Set Main_File to Workspc.File_Number
37031>>>        Set Size to 129 506
37032>>>        Set Location to 10 7
37033>>>        Set Wrap_State to TRUE
37034>>>
37034>>>        Begin_Row
37037>>>            Entry_Item Workspc.Recnum
37038>>>            Entry_Item Workspc.Id
37039>>>            Entry_Item Workspc.Titlos
37040>>>            Entry_Item Workspc.Appsrcextrapath
37041>>>            Entry_Item Workspc.Dataextrapath
37042>>>            Entry_Item Workspc.Working
37043>>>        End_Row
37048>>>
37048>>>        Set Form_Width    item 0 to 35
37049>>>        Set Header_Label  item 0 to "Rec"
37050>>>        
37050>>>        Set Form_Width    item 1 to 52
37051>>>        Set Header_Label  item 1 to "‰à› ¡æª"
37052>>>        
37052>>>        Set Form_Width    item 2 to 109
37053>>>        Set Header_Label  item 2 to "œ¨ š¨˜­ã"
37054>>>        
37054>>>        Set Form_Width    item 3 to 132
37055>>>        Set Header_Label  item 3 to "Appsrc Path + Extra"
37056>>>        
37056>>>        Set Form_Width    item 4 to 124
37057>>>        Set Header_Label  item 4 to "Data Path + Extra"
37058>>>        
37058>>>        Set Form_Width    item 5 to 49
37059>>>        Set Header_Label  item 5 to "’¨â®¦¬©œª"
37060>>>        Set Column_Checkbox_State  item 5 to True
37061>>>        
37061>>>
37061>>>        //AB-StoreStart
37061>>>                                                        
37061>>>        Send DoRegSize Self smBottomRight
37062>>>        
37062>>>        //AB-StoreEnd
37062>>>
37062>>>    End_Object    // Workspc_
37063>>>
37063>>>    Object Workspc_Data_Path is a dbFormSub
37065>>>        Entry_Item Workspc.Appsrcextrapath
37066>>>        Set Label to "AppSrcPath+Extra"
37067>>>        Set Size to 13 434
37068>>>        Set Location to 152 76
37069>>>        Set Color to clBtnFace
37070>>>        Set Label_Col_Offset to 2
37071>>>        Set Label_Justification_Mode to jMode_Right
37072>>>        Set Enabled_State to FALSE
37073>>>        Set Form_TypeFace Item 0 to "MS Sans Serif"
37074>>>        Set Item_Shadow_State Item 0 to TRUE
37075>>>        Set Shadow_State Item 0 to TRUE
37076>>>
37076>>>        //AB-StoreStart
37076>>>                                                        
37076>>>        Send DoRegAlign self amBottomRight
37077>>>        
37077>>>        //AB-StoreEnd
37077>>>
37077>>>    End_Object    // Workspc_Data_Path
37078>>>
37078>>>    Object Workspc_Filelist_Path is a dbFormSub
37080>>>        Entry_Item Workspc.Dataextrapath
37081>>>        Set Label to "DataPath+Extra"
37082>>>        Set Size to 13 434
37083>>>        Set Location to 169 76
37084>>>        Set Color to clBtnFace
37085>>>        Set Label_Col_Offset to 2
37086>>>        Set Label_Justification_Mode to jMode_Right
37087>>>        Set Enabled_State to FALSE
37088>>>        Set Form_TypeFace Item 0 to "MS Sans Serif"
37089>>>        Set Item_Shadow_State Item 0 to TRUE
37090>>>        Set Shadow_State Item 0 to TRUE
37091>>>
37091>>>        //AB-StoreStart
37091>>>                                                        
37091>>>        Send DoRegAlign self amBottomRight
37092>>>        
37092>>>        //AB-StoreEnd
37092>>>
37092>>>    End_Object    // Workspc_Filelist_Path
37093>>>
37093>>>    Object ButtonSub1 is a ButtonSub
37095>>>
37095>>>        //AB-StoreTopStart
37095>>>        
37095>>>        //AB-StoreTopEnd
37095>>>
37095>>>        Set Label to "€¢¢˜¥œ «¦ Registry"
37096>>>        Set Size to 20 170
37097>>>        Set Location to 193 173
37098>>>        Set Border_Style to Border_StaticEdge
37099>>>        Set Focus_Mode to Pointer_Only
37100>>>        Set Form_FontWeight Item 0 to 600
37101>>>        Set Form_TypeFace Item 0 to "MS Sans Serif"
37102>>>
37102>>>        //AB-StoreStart
37102>>>        
37102>>>        Procedure OnClick
37104>>>            String lsAppSrcPath lsDataPath lsCurWorkSpace lsLastChar lsFilelistName
37105>>>            String lsModuleName lsID
37105>>>            If (Current_Record(Workspc_DD(Self))) Begin
37107>>>                Get WorkSpaceName of ghoWorkSpace to lsCurWorkSpace
37108>>>                Get ModuleName    of ghoWorkSpace to lsModuleName
37109>>>                Get Field_Current_Value of Workspc_DD Field Workspc.ID to lsID
37110>>>                If (psPreSelectedWorkSpcID(Self) = lsID) Break
37113>>>                Get Field_Current_Value of Workspc_DD Field Workspc.AppSrcExtraPath to lsAppSrcPath
37114>>>                Get Field_Current_Value of Workspc_DD Field Workspc.DataExtraPath   to lsDataPath
37115>>>                set_profile_string ("WorkSpaces\"+lsCurWorkSpace) "AppSrcPath"      to lsAppSrcPath
37118>>>                set_profile_string ("WorkSpaces\"+lsCurWorkSpace) "DataPath"        to lsDataPath
37121>>>                Send DoSetWorkSpace to ghoWorkSpace lsCurWorkSpace lsModuleName
37122>>>            End
37122>>>>
37122>>>            //Send Stop_Modal_ui
37122>>>        End_Procedure // OnClick
37123>>>        
37123>>>        //AB-StoreEnd
37123>>>
37123>>>    End_Object    // ButtonSub1
37124>>>
37124>>>CD_End_Object    // Workspc
37126>>>>
37126>>>
37126>>>//AB/ End_Object    // prj
37126>
37126>        //AB-ClientStoreStart
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        
37126>        //AB-ClientStoreEnd
37126>
37126>
37126>    End_Object  // Client_Area
37127>    
37127>    On_Key Key_Ctrl+Key_1 Send Activate_Workspc To Client_Area
37128>    
37128>    Use DFStdSbr.pkg //  Status-Bar object.
INCLUDING FILE: DFSTDSBR.PKG
37128>>>// 07/23/96 JJT - New Class names
37128>>>// Very prototype global status bar
37128>>>//
37128>>>Use dfMainSt.pkg
INCLUDING FILE: DFMAINST.PKG
37128>>>>>// 07/23/96 JJT - New Class names
37128>>>>>Use dfAstbar.pkg
37128>>>>>
37128>>>>>Class StatusBar is a AppStatusBar
37129>>>>>
37129>>>>>    Procedure Construct_Object
37130>>>>>       Forward Send Construct_Object
37132>>>>>       //
37132>>>>>       Send Add_Item 350  ''     // micro-help
37133>>>>>       Send Add_Item  40  'View:'
37134>>>>>       Set Item_Display_Style To sbNORMAL
37135>>>>>       Send Add_Item 200  ''     // view name
37136>>>>>       Send Add_Item   0  ''     // spring 'normal' to end
37137>>>>>       Set Item_Display_Style To sbNORMAL
37138>>>>>    End_Procedure // Construct_Object
37139>>>>>
37139>>>>>    Procedure Show_View_Name String sName
37140>>>>>        Set Value item 2 to sName
37141>>>>>    End_Procedure
37142>>>>>
37142>>>>>End_Class
37143>>>
37143>>>If (Wait(Self)) Send Deactivate to (Wait(Self))
37146>>>
37146>>>Object oStatusBarSub  is a StatusBar
37148>>>    Use DFTimer // DfTimer Manager Must Have a WindowHandle
37148>>>    
37148>>>    Property Integer piStdPanes Public (PaneCount(Self))
37150>>>    
37150>>>    //Set Value     Item 1 to (ToANSI("„§ ¢¦šã:"))
37150>>>    Set PaneWidth item 1 to 50
37151>>>    
37151>>>    Send AddPane 55  ""        sbLOWERED
37152>>>    Send AddPane 70  ""        sbLOWERED
37153>>>    Send AddPane 55  ""        sbLOWERED
37154>>>    
37154>>>    Procedure pTimer
37156>>>        String lsDay lsHour lsHH lsMM lsSS
37157>>>        Integer liStdPanes lbState
37157>>>    
37157>>>        Get piStdPanes to liStdPanes
37158>>>        Sysdate lsDay lsHH lsMM lsSS
37162>>>        If (Length(lsHH)=1) Insert "0" In lsHH At 1
37166>>>        If (Length(lsMM)=1) Insert "0" In lsMM At 1
37170>>>        If (Length(lsSS)=1) Insert "0" In lsSS At 1
37174>>>        Move (lsHH+":"+lsMM+":"+lsSS) to lsHour
37175>>>        Get Simple_state to lbState
37176>>>        If  Not (lbState) Begin
37178>>>            Set Value Item liStdPanes     to lsHour
37179>>>            Set Value Item (liStdPanes+1) to lsDay
37180>>>        End
37180>>>>
37180>>>    
37180>>>    End_Procedure // pTimer
37181>>>    
37181>>>    
37181>>>    Object oTimerObj Is A DFTimer
37183>>>        Set Timeout to 1000
37184>>>        Set Timer_Active_State to TRUE
37185>>>        Set Timer_Object to (oStatusBarSub(Current_Object))
37186>>>        Set Timer_Message to pTimer
37187>>>    End_Object // oTimerOdj
37188>>>End_Object // oStatusBar
37189>>>
37189>>>
37189>
37189>    //AB-PanelStoreStart
37189>    Use StdAbout.pkg // Standard "About" package.
INCLUDING FILE: STDABOUT.PKG
37189>>>//************************************************************************
37189>>>// Confidential Trade Secret.
37189>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
37189>>>// as an unpublished work.  All rights reserved.
37189>>>// DataFlex is a registered trademark of Data Access Corporation.
37189>>>//
37189>>>//************************************************************************
37189>>>//************************************************************************
37189>>>//
37189>>>// $File name  : StdAbout.pkg
37189>>>// $File title : Standard about object package for VDF
37189>>>// Notice      :
37189>>>// $Author(s)  : John Tuohy
37189>>>//
37189>>>// $Rev History
37189>>>//
37189>>>// JT 06/27/97   File created
37189>>>//************************************************************************
37189>>>
37189>>>// This provides a quick and simple way to create an about package for a program.
37189>>>// You need to create a message inside you client area called Activate_About.
37189>>>// Within this message you should send the message DoAbout passing needed
37189>>>// string information.
37189>>>//
37189>>>//       Procedure Activate_About
37189>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
37189>>>//       End_Procedure
37189>>>//    where: sTitle =     Name of application. If none provided, uses caption
37189>>>//                        bar title
37189>>>//           sVersion   = Version Line. If none provided, will be blank
37189>>>//           sCopyRight = Copyright Line. If none provided, will be blank
37189>>>//           sAuthor    = Author name, blank if none provided
37189>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
37189>>>//                        is used.
37189>>>// It is expected that you will place this in your own object package. For
37189>>>// example an order about package may look like this:
37189>>>//
37189>>>//   // OrderAbout.pkg
37189>>>//   Use StdAbout.pkg
37189>>>//   Procedure Activate_About
37189>>>//      Local String sTitle sCopyright sVersion sAuthor
37189>>>//      Move "My Order Entry System" to sTitle
37189>>>//      Move "Version 2.1" to sVersion
37189>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
37189>>>//      Move "John Smith"  to sAuthor
37189>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
37189>>>//   end_procedure
37189>>>//   // end of file.
37189>>>
37189>>>Use DfAbout.pkg
INCLUDING FILE: DFABOUT.PKG
37189>>>>>//************************************************************************
37189>>>>>// Confidential Trade Secret.
37189>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
37189>>>>>// as an unpublished work.  All rights reserved.
37189>>>>>// DataFlex is a registered trademark of Data Access Corporation.
37189>>>>>//
37189>>>>>//************************************************************************
37189>>>>>//************************************************************************
37189>>>>>//
37189>>>>>// $File name  : DfAbout.pkg
37189>>>>>// $File title : About class support
37189>>>>>// Notice      :
37189>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
37189>>>>>//
37189>>>>>// $Rev History
37189>>>>>//
37189>>>>>// JJT 11/5/98    Added version information
37189>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
37189>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
37189>>>>>//                workspace package.
37189>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
37189>>>>>//                class can create this object.
37189>>>>>//                Cleaned up the interface (used correct classes and messages)
37189>>>>>//                Added workspace reporting support to sys-info.
37189>>>>>//                Turned off wrapping in the sys-info editor.
37189>>>>>// KR  ??/??/96   File created
37189>>>>>//************************************************************************
37189>>>>>Use windows.pkg
37189>>>>>Use DFbitmap.pkg
37189>>>>>
37189>>>>>External_Function32 WNetGetUser "WNetGetUserA" MPR.DLL ;    Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
37190>>>>>
37190>>>>>//****************************************************************************
37190>>>>>// $Module type: FUNCTION
37190>>>>>// $Module name: Network_User_Name
37190>>>>>// $Author     : AK/VOO/KCR
37190>>>>>// Created     : 24-09-96 @ 19:17
37190>>>>>//
37190>>>>>// Description
37190>>>>>//    This function reads the current username of windows and returns that
37190>>>>>//    name or an text unknown user
37190>>>>>//
37190>>>>>// $Rev History
37190>>>>>//    24-09-96  Module header created
37190>>>>>//****************************************************************************
37190>>>>>Function Network_User_Name Returns String
37192>>>>>    Local String sName sLength
37193>>>>>    Local Pointer lpName_Addr lpLength_Addr
37193>>>>>    Local Integer iRetval
37193>>>>>
37193>>>>>    Movestr (Repeat (Character (0), 255)) To sName
37194>>>>>>
37194>>>>>    GetAddress Of sName To lpName_Addr
37195>>>>>    Movestr (DwordToBytes (255)) To sLength
37196>>>>>>
37196>>>>>    GetAddress Of sLength To lpLength_Addr
37197>>>>>
37197>>>>>    Moveint (WNetGetUser (0, lpName_Addr, lpLength_Addr)) To iRetval
37198>>>>>>
37198>>>>>
37198>>>>>    If iRetval Eq 0 Function_Return (CString (sName))
37201>>>>>    Else Function_Return "User Unknown"
37203>>>>>End_Function // Network_User_Name
37204>>>>>
37204>>>>>Type MEMORYSTATUS
37204>>>>>   Field MEMORYSTATUS.dwLength         As Dword // sizeof(MEMORYSTATUS)
37204>>>>>   Field MEMORYSTATUS.dwMemoryLoad     As Dword // percent of memory in use
37204>>>>>   Field MEMORYSTATUS.dwTotalPhys      As Dword // bytes of physical memory
37204>>>>>   Field MEMORYSTATUS.dwAvailPhys      As Dword // free physical memory bytes
37204>>>>>   Field MEMORYSTATUS.dwTotalPageFile  As Dword // bytes of paging file
37204>>>>>   Field MEMORYSTATUS.dwAvailPageFile  As Dword // free bytes of paging file
37204>>>>>   Field MEMORYSTATUS.dwTotalVirtual   As Dword // user bytes of address space
37204>>>>>   Field MEMORYSTATUS.dwAvailVirtual   As Dword // free user bytes
37204>>>>>End_Type // MEMORYSTATUS
37204>>>>>
37204>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
37205>>>>>
37205>>>>>// If a global workspace object exists it will use this variable to store
37205>>>>>// its object id.
37205>>>>>
37205>>>>>Class SysinfoDisplay Is An Edit
37206>>>>>    Procedure Construct_Object
37207>>>>>        forward send construct_object
37209>>>>>
37209>>>>>        Set Location To 6 6
37210>>>>>        Set Size To 110 255
37211>>>>>        Set Read_Only_State To True
37212>>>>>        Set wrap_state to False
37213>>>>>    end_Procedure
37214>>>>>
37214>>>>>    //****************************************************************************
37214>>>>>    // $Module type: PROCEDURE
37214>>>>>    // $Module name: Add_Line
37214>>>>>    // $Author     : VOO
37214>>>>>    // Created     : 06-10-96 @ 15:23
37214>>>>>    //
37214>>>>>    // Description
37214>>>>>    //    This method will add a line to this edit object, it should go simpler
37214>>>>>    //    but it seems to be done this way.
37214>>>>>    //
37214>>>>>    // $Rev History
37214>>>>>    //    06-10-96  Module header created
37214>>>>>    //****************************************************************************
37214>>>>>    Procedure Add_Line String sVal
37215>>>>>        Local Integer iLine
37216>>>>>
37216>>>>>        Moveint (Line_Count (Current_Object)) To iLine
37217>>>>>>
37217>>>>>        If (iLine = 1 And Changed_State (Current_Object) = False) Moveint 0 To iLine
37220>>>>>        Set Value Item iLine To sVal
37221>>>>>    End_Procedure // Add_Line
37222>>>>>
37222>>>>>    //****************************************************************************
37222>>>>>    // $Module type: PROCEDURE
37222>>>>>    // $Module name: Show_Current_Directory
37222>>>>>    // $Author     : VOO
37222>>>>>    // Created     : 06-10-96 @ 15:24
37222>>>>>    //
37222>>>>>    // Description
37222>>>>>    //    This method will show the name of the current directory in the system
37222>>>>>    //    information box
37222>>>>>    //
37222>>>>>    // $Rev History
37222>>>>>    //    06-10-96  Module header created
37222>>>>>    //****************************************************************************
37222>>>>>    Procedure Show_Current_Directory
37223>>>>>        Local String sDir
37224>>>>>
37224>>>>>        Get_Current_Directory To sDir
37225>>>>>        Send Add_Line ("Current Directory: " + sDir)
37226>>>>>    End_Procedure // Show_Current_Directory
37227>>>>>
37227>>>>>    Procedure Show_Windows_Directory
37228>>>>>        Local String sWindir
37229>>>>>
37229>>>>>        Get_Windows_Directory To sWindir
37230>>>>>        Send Add_Line ("Windows Directory: " * sWindir)
37231>>>>>    End_Procedure // Show_Windows_Directory
37232>>>>>
37232>>>>>    Procedure Show_Current_User
37233>>>>>        Send Add_Line ("Network User Name: " * Network_User_Name (Current_Object))
37234>>>>>    End_Procedure // Show_Current_User
37235>>>>>
37235>>>>>    Procedure Show_Number_Format
37236>>>>>        Local Integer iFormat
37237>>>>>
37237>>>>>        Get_Attribute Df_Thousands_Separator To iFormat
37240>>>>>        Send Add_Line ('Thousands Separator: "' - Character (iFormat) - '" (' - String (iFormat) - ')')
37241>>>>>        Get_Number_Format To iFormat
37242>>>>>        Send Add_Line ('Decimal Separator: "' - If (iFormat = 0, '.', ',') - '"')
37243>>>>>    End_Procedure // Show_Number_Format
37244>>>>>
37244>>>>>    Procedure Show_Filelist_Name
37245>>>>>        Local String sFilename
37246>>>>>
37246>>>>>        Get_Attribute Df_Filelist_Name To sFilename
37249>>>>>        Send Add_Line ("Current Filelist: " * sFilename)
37250>>>>>    End_Procedure // Show_Filelist_Name
37251>>>>>
37251>>>>>    Procedure Show_Lock_Delay
37252>>>>>        Local Integer iLockdelay
37253>>>>>
37253>>>>>        Get_Attribute Df_Lock_Delay To iLockdelay
37256>>>>>        Send Add_Line ("Database Locking Delay: " * String (iLockdelay) * "Milliseconds")
37257>>>>>    End_Procedure // Show_Lock_Delay
37258>>>>>
37258>>>>>    Procedure Show_Lock_Timeout
37259>>>>>        Local Integer iLockTimeout
37260>>>>>
37260>>>>>        Get_Attribute Df_Lock_Timeout To iLockTimeout
37263>>>>>        Send Add_Line ("Database Locking Timeout: " * String (iLockTimeout) * "Milliseconds")
37264>>>>>    End_Procedure // Show_Lock_Timeout
37265>>>>>
37265>>>>>    Procedure Show_Screen_Size
37266>>>>>        Local Integer iYscreensize iXscreensize
37267>>>>>
37267>>>>>        Moveint (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
37268>>>>>>
37268>>>>>        Moveint (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
37269>>>>>>
37269>>>>>
37269>>>>>        Send Add_Line ("Video Resolution: " * String (iXscreensize) * "by" * String (iYscreensize))
37270>>>>>    End_Procedure // Show_Screen_Size
37271>>>>>
37271>>>>>    Procedure Show_Page_Size
37272>>>>>        Send Add_Line ("Page End: " * String (Pageend) * "Form Feed: " * String (Pagefeed))
37273>>>>>    End_procedure
37274>>>>>
37274>>>>>    Procedure Show_Date
37275>>>>>        Local Date dToday
37276>>>>>
37276>>>>>        Sysdate4 dToday
37277>>>>>        Send Add_Line ("Current System Date: " * String (dToday))
37278>>>>>    End_procedure // Show_Date
37279>>>>>
37279>>>>>    Procedure Show_Date_Format
37280>>>>>        Local Integer iDateFormat
37281>>>>>        Local String sDateFormat
37281>>>>>
37281>>>>>        Get_Attribute Df_Date_Format To iDateFormat
37284>>>>>        if iDateFormat Eq DF_DATE_USA ;            Movestr "USA" To sDateFormat
37287>>>>>        else if iDateformat Eq DF_DATE_EUROPEAN ;            Movestr "European" To sDateFormat
37291>>>>>        else if iDateformat Eq DF_DATE_MILITARY ;            Movestr "Military" To sDateFormat
37295>>>>>        else ;            Movestr "Unknown Date Type" To sDateFormat
37297>>>>>        Send Add_Line ("Date Format: " * sDateformat)
37298>>>>>    End_Procedure // Show_Date_Format
37299>>>>>
37299>>>>>    Procedure Show_Memavail
37300>>>>>        Local Integer iMem
37301>>>>>
37301>>>>>        Memory iMem
37302>>>>>>
37302>>>>>        Send Add_Line ("Available Memory: " * String (iMem))
37303>>>>>    End_Procedure // Show_Memavail
37304>>>>>
37304>>>>>    Procedure Show_Systemresources
37305>>>>>        Local String sMemoryStatus
37306>>>>>        Local Pointer lpsMemoryStatus
37306>>>>>        Local Integer iVoid
37306>>>>>        Local Dword dwMemoryLoad dwTotalPhys dwAvailPhys dwTotalPageFile dwAvailPageFile dwTotalVirtual dwAvailVirtual
37306>>>>>
37306>>>>>        ZeroType MEMORYSTATUS To sMemoryStatus
37307>>>>>        GetAddress Of sMemoryStatus To lpsMemoryStatus
37308>>>>>
37308>>>>>        Moveint (GlobalMemoryStatus (lpsMemoryStatus)) To iVoid
37309>>>>>>
37309>>>>>
37309>>>>>        GetBuff From sMemoryStatus At MEMORYSTATUS.dwMemoryLoad    To dwMemoryLoad
37310>>>>>        GetBuff From sMemoryStatus At MEMORYSTATUS.dwTotalPhys     To dwTotalPhys
37311>>>>>        GetBuff From sMemoryStatus At MEMORYSTATUS.dwAvailPhys     To dwAvailPhys
37312>>>>>        GetBuff From sMemoryStatus At MEMORYSTATUS.dwTotalPageFile To dwTotalPageFile
37313>>>>>        GetBuff From sMemoryStatus At MEMORYSTATUS.dwAvailPageFile To dwAvailPageFile
37314>>>>>        GetBuff From sMemoryStatus At MEMORYSTATUS.dwTotalVirtual  To dwTotalVirtual
37315>>>>>        GetBuff From sMemoryStatus At MEMORYSTATUS.dwAvailVirtual  To dwAvailVirtual
37316>>>>>
37316>>>>>        Send Add_Line ("Current memory utilization:" * String (dwMemoryLoad))
37317>>>>>        Send Add_Line ("Percentage available physical memory:" * String (dwAvailPhys / dwTotalPhys * 100.0) - "%")
37318>>>>>        Send Add_Line ("Percentage available pagefile space:" * String (dwAvailPageFile / dwTotalPageFile * 100.0) - "%")
37319>>>>>        Send Add_Line ("Percentage available virtual memory:" * String (dwAvailVirtual / dwTotalVirtual * 100.0) - "%")
37320>>>>>    End_Procedure // Show_Systemresources
37321>>>>>
37321>>>>>    Procedure Show_Registration
37322>>>>>        Local String sRegName
37323>>>>>        Local Integer iSN
37323>>>>>        Registration sRegName iSN
37324>>>>>>
37324>>>>>
37324>>>>>        Send Add_Line ("Serial# : " + (String(iSN)))
37325>>>>>        Send Add_Line ("Reg Name: " + sRegName)
37326>>>>>
37326>>>>>    End_Procedure // Show_Current_Directory
37327>>>>>
37327>>>>>
37327>>>>>
37327>>>>>    //****************************************************************************
37327>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
37327>>>>>    // to the workspace object passing the an object and message to send back
37327>>>>>    // to this object. It is expected that the workspace object will send this
37327>>>>>    // message for every line of information it wants displayed (passing the
37327>>>>>    // information to be displayed
37327>>>>>    //****************************************************************************
37327>>>>>    register_procedure EnumerateWorkspaceData integer hObjId integer hmMessId
37327>>>>>    Procedure Show_WorkspaceInformation
37328>>>>>        If ghoWorkspace ;            Send EnumerateWorkspaceData to ghoWorkspace Current_object Msg_add_Line
37331>>>>>    End_Procedure
37332>>>>>
37332>>>>>    Function VersionStr integer iVer integer iRev integer iBld Returns string
37333>>>>>        Function_Return (string(iVer)-"."-string(iRev)-"."-string(iBld))
37334>>>>>    End_Function
37335>>>>>
37335>>>>>    Procedure Show_Versions
37336>>>>>        local integer iVersion iRevision iBuild
37337>>>>>        Version_information iVersion iRevision iBuild
37339>>>>>        Send Add_Line ("Runtime Version:" * VersionStr(self,iVersion,iRevision,iBuild) )
37340>>>>>        Send Add_Line ("Package Version:" * VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) )
37341>>>>>        Send Add_Line ("FMAC Version:"    * VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) )
37342>>>>>    End_Procedure
37343>>>>>
37343>>>>>
37343>>>>>    //***
37343>>>>>    //*** BW
37343>>>>>    //*** Procedure: Show_Drivers
37343>>>>>    //*** Purpose  : Show loaed database drivers
37343>>>>>    //***
37343>>>>>
37343>>>>>    Procedure Show_Drivers
37344>>>>>        Local String  Current_drvr
37345>>>>>        Local String  Loadeddrvrs
37345>>>>>        Local Integer Number_of_drvrs
37345>>>>>        Local Integer Count
37345>>>>>
37345>>>>>        Move "" To Loadeddrvrs
37346>>>>>        Get_attribute DF_NUMBER_DRIVERS To Number_of_drvrs
37349>>>>>        For Count From 1 To Number_of_drvrs
37355>>>>>>
37355>>>>>            Get_attribute DF_DRIVER_NAME Of Count To Current_drvr
37358>>>>>            If (Loadeddrvrs <> "") ;                Move (Append(Loadeddrvrs, ", ")) To Loadeddrvrs
37361>>>>>            Move (Append(Loadeddrvrs, Current_drvr)) To Loadeddrvrs
37362>>>>>        Loop
37363>>>>>>
37363>>>>>        Send Add_Line ("Database driver(s):" * Loadeddrvrs)
37364>>>>>    End_Procedure // Show_Drivers
37365>>>>>
37365>>>>>    //****************************************************************************
37365>>>>>    // $Module type: PROCEDURE
37365>>>>>    // $Module name: Add_Focus
37365>>>>>    // $Author     : VOO
37365>>>>>    // Created     : 24-09-96 @ 19:43
37365>>>>>    //
37365>>>>>    // Description
37365>>>>>    //    During activation we will remove the old information and add the newly
37365>>>>>    //    found systeminformation
37365>>>>>    //
37365>>>>>    // $Rev History
37365>>>>>    //    24-09-96  Module header created
37365>>>>>    //****************************************************************************
37365>>>>>    Procedure Add_Focus Integer hoRoot
37366>>>>>        Forward Send Add_Focus hoRoot
37368>>>>>
37368>>>>>        Send Delete_Data
37369>>>>>        Set Changed_State To False
37370>>>>>        Set Read_Only_State To True
37371>>>>>        Send Show_WorkSpaceInformation // added to show WS info
37372>>>>>        SEnd Show_Drivers
37373>>>>>        Send Show_Current_User
37374>>>>>        Send Show_Windows_Directory
37375>>>>>        Send Show_Current_Directory
37376>>>>>        Send Show_Filelist_Name
37377>>>>>        Send Show_Versions
37378>>>>>        Send Show_Memavail
37379>>>>>        Send Show_Screen_Size
37380>>>>>        Send Show_Page_Size
37381>>>>>        Send Show_Number_Format
37382>>>>>        Send Show_Date_Format
37383>>>>>        Send Show_Lock_Delay
37384>>>>>        Send Show_Lock_Timeout
37385>>>>>        Send Show_Date
37386>>>>>        Send Show_Systemresources
37387>>>>>        Send Show_Registration
37388>>>>>    End_Procedure // Show_All_Info
37389>>>>>
37389>>>>>End_Class // SysinfoDisplay
37390>>>>>
37390>>>>>
37390>>>>>//****************************************************************************
37390>>>>>// $Module type: OBJECT
37390>>>>>// $Module name: Sysinfo_Dialog
37390>>>>>// $Author     : VOO
37390>>>>>// Created     : 24-09-96 @ 18:47
37390>>>>>//
37390>>>>>// Description
37390>>>>>//    This object shows the systeminformation on the screen
37390>>>>>//
37390>>>>>// $Rev History
37390>>>>>//    24-09-96  Module header created
37390>>>>>//****************************************************************************
37390>>>>>Class SysInfoDialog Is A ModalPanel
37391>>>>>    Procedure Construct_Object
37392>>>>>        forward send construct_object
37394>>>>>
37394>>>>>        Set Caption_Bar To True
37395>>>>>        Set Sysmenu_Icon To True
37396>>>>>        Set Label To "System Information"
37397>>>>>        Set Size To 152 270
37398>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
37399>>>>>        Set Minimize_Icon To False
37400>>>>>        Set Maximize_Icon To False
37401>>>>>        Set Border_Style To Border_Dialog
37402>>>>>
37402>>>>>        Object Sysinfo_Display Is A SysInfoDisplay
37404>>>>>        End_Object
37405>>>>>
37405>>>>>        Object Close_Button Is A Button
37407>>>>>            Set Label to "&Close"
37408>>>>>            Set Location To 120 212
37409>>>>>            Set Message item 0 to msg_Close_Panel
37410>>>>>            Set default_action_button to current_object
37411>>>>>        End_Object // Close_Button
37412>>>>>
37412>>>>>        On_Key Kcancel       Send Close_Panel
37413>>>>>        On_Key Key_Alt+Key_C Send Close_Panel
37414>>>>>    End_procedure
37415>>>>>
37415>>>>>End_Class // SysinfoDialog
37416>>>>>
37416>>>>>// Purpose:
37416>>>>>//
37416>>>>>// Ken Ross 12/17/96 5:16PM
37416>>>>>//
37416>>>>>Class AboutDialog Is A ModalPanel
37417>>>>>
37417>>>>>    Procedure construct_object
37418>>>>>        String sVdfRootDir
37419>>>>>        forward send construct_object
37421>>>>>        Set Label to "About..."
37422>>>>>        Set Size to 100 217
37423>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
37424>>>>>
37424>>>>>        Object SysInfo_Dialog is a SysInfoDialog
37426>>>>>        End_Object
37427>>>>>
37427>>>>>        Object oBox is a Container3d
37429>>>>>            Set Border_Style to Border_StaticEdge
37430>>>>>            Set Size to 63 202
37431>>>>>            Set Location to 4 5
37432>>>>>
37432>>>>>            Object AboutGraphic is a BitmapContainer
37434>>>>>                Set Border_Style to Border_None
37435>>>>>                Set Bitmap_Style to Bitmap_Center
37436>>>>>                Set Size to 48 48
37437>>>>>                Set Location to 7 2
37438>>>>>            End_Object    // AboutGraphic
37439>>>>>
37439>>>>>            Object ProductName is a TextBox
37441>>>>>                Set label to "ProductName"
37442>>>>>                Set Size to 10 45
37443>>>>>                Set Location to 8 53
37444>>>>>            End_Object    // ProductName
37445>>>>>
37445>>>>>            Object Version is a TextBox
37447>>>>>                Set label to "Version"
37448>>>>>                Set Size to 10 25
37449>>>>>                Set Location to 21 53
37450>>>>>            End_Object    // Version
37451>>>>>
37451>>>>>            Object Copyright is a TextBox
37453>>>>>                Set label to "Copyright"
37454>>>>>                Set Size to 10 31
37455>>>>>                Set Location to 34 53
37456>>>>>            End_Object    // Copyright
37457>>>>>
37457>>>>>            Object Author is a TextBox
37459>>>>>                Set label to "Author"
37460>>>>>                Set Size to 10 22
37461>>>>>                Set Location to 46 53
37462>>>>>            End_Object    // Author
37463>>>>>
37463>>>>>        End_Object    // oBox
37464>>>>>
37464>>>>>        Object OK_bn is a Button
37466>>>>>            On_Item "&OK" Send Close_Panel
37467>>>>>            Set Size to 14 50
37468>>>>>            Set Location to 71 157
37469>>>>>        End_Object    // OK_bn
37470>>>>>
37470>>>>>        Object SysInfo_bn is a Button
37472>>>>>            On_Item "&System Info" Send Show_Sysinfo
37473>>>>>            Set Size to 14 50
37474>>>>>            Set Location to 71 101
37475>>>>>        End_Object    // SysInfo_bn
37476>>>>>
37476>>>>>        On_Key Kcancel Send KeyAction to (Ok_bn(Current_Object))
37477>>>>>        On_Key Key_Alt+Key_O Send KeyAction to (Ok_bn(Current_Object))
37478>>>>>        On_Key Key_Alt+Key_S Send KeyAction to (SysInfo_bn(Current_Object))
37479>>>>>
37479>>>>>        Get_Profile_String "Defaults" "VdfRootDir" To sVdfRootDir
37482>>>>>        Set logo to (sVdfRootDir +"\Bitmaps\DacAbout.bmp")  // square bitmaps of 42x42 work best
37483>>>>>
37483>>>>>    End_Procedure
37484>>>>>
37484>>>>>    Procedure set productname string sval
37485>>>>>        set label of (productname(oBox(current_object))) to sval
37486>>>>>    End_Procedure
37487>>>>>
37487>>>>>    Procedure set version string sval
37488>>>>>        set label of (version(oBox(current_object))) to sval
37489>>>>>    End_Procedure
37490>>>>>
37490>>>>>    Procedure set copyright string sval
37491>>>>>        set label of (copyright(oBox(current_object))) to sval
37492>>>>>    End_Procedure
37493>>>>>
37493>>>>>    Procedure set author string sval
37494>>>>>        set label of (author(oBox(current_object))) to sval
37495>>>>>    End_Procedure
37496>>>>>
37496>>>>>    // square bitmaps of 42x42 work best
37496>>>>>    //
37496>>>>>    Procedure set logo string sval
37497>>>>>        set bitmap of (aboutgraphic(oBox(current_object))) to sval
37498>>>>>    End_Procedure
37499>>>>>
37499>>>>>    Procedure Show_Sysinfo
37500>>>>>        Send Popup_Modal To (Sysinfo_Dialog(Current_Object))
37501>>>>>    End_Procedure // Show_Sysinfo
37502>>>>>
37502>>>>>End_Class
37503>>>>>
37503>>>>>
37503>>>>>//Object About_Dialog is an AboutDialog
37503>>>>>//    set productname to "Visual DataFlex"
37503>>>>>//    set version to "version 4.0"
37503>>>>>//    set copyright to "Copyright 1997 Data Access Corporation"
37503>>>>>//    set author to ""
37503>>>>>//    set logo to "ablogo.bmp"  // square bitmaps of 42x42 work best
37503>>>>>//End_Object
37503>>>>>
37503>>>>>//Procedure Activate_About
37503>>>>>//   Send Popup_Modal To (About_Dialog (Current_Object))
37503>>>>>//End_Procedure
37503>>>
37503>>>// *************************************************************************
37503>>>//  Public message. This is the default message. It is expected that you will
37503>>>//   create your own message to override this
37503>>>// *************************************************************************
37503>>>
37503>>>Procedure Activate_About
37505>>>   Send DoAbout "" "" "" "" "" ""
37506>>>End_Procedure
37507>>>
37507>>>// *************************************************************************
37507>>>//  Public message. It is expected that you will send this message (most
37507>>>//  likely from Activate_About. This creates an about object, activates it
37507>>>//  and destroys it when done. It is not exepected that you will augment this.
37507>>>// *************************************************************************
37507>>>
37507>>>Procedure DoAbout string sTitle string sVersion string sCopyRight string sAuthor string sBitmap
37509>>>        Local integer hoObj hoMain
37510>>>
37510>>>        // create object
37510>>>        Object About is an AboutDialog
37512>>>            // if no title passed use the label of the main panel
37512>>>            // (if a main panel exists).
37512>>>            if sTitle     eq '' Begin
37514>>>                Get Main_Window to hoMain
37515>>>                if hoMain Get Label of hoMain to sTitle
37518>>>            end
37518>>>>
37518>>>            set productname to sTitle
37519>>>            set version     to sVersion
37520>>>            set copyright   to sCopyRight
37521>>>            set author      to sAuthor
37522>>>            If sBitmap    ne '' ;               set logo to sBitMap // square bitmaps of 42x42 work best
37525>>>            Move Current_Object to hoObj // object Id
37526>>>        End_Object
37527>>>        Send Popup to hoObj    // popup the about object
37528>>>        Send Request_Destroy_Object to hoObj // when done, it will be destroyed
37529>>>End_procedure
37530>    Use Tooltip.Inc
INCLUDING FILE: TOOLTIP.INC
37530>>>Use Tooltip.pkg
37530>>>
37530>>>object StandardToolTip is a StandardToolTip000
37532>>>    move (current_object) to DefaultTooltipHintID
37533>>>end_object
37534>>>
37534>>>object ToolTipTimer is a ToolTipTimer000
37536>>>    move (current_object) to TooltipControllerID
37537>>>end_object
37538>    
37538>    
37538>    
37538>    //AB-PanelStoreEnd
37538>
37538>
37538>End_Object
37539>
37539>
37539>//AB-StoreStart
37539>
37539>set bitmap of (client_area(main(self))) to "protem1.bmp"
37540>
37540>Start_UI
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>
37541>//AB-StoreEnd
37541>
37541>
Summary
Memory Available: 2147483647
Total Errors   : 0
Total Symbols  : 21319
Total Resources: 0
Total Commands : 37540
Total Windows  : 1
Total Pages    : 1
Static Data    : 261318
Message area   : 182851
Total Blocks   : 12298
