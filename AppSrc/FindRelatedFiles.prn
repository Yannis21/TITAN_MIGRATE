Compiling Program: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
Memory Available: 2147483647
1>//AB/ Project Find all Related Files
1>//AB/ Object prj is a View_Project
1>//AB/     Set ProjectName to "Find all Related Files"
1>//AB/     Set ProjectFileName to "FindRelatedFiles.VW"
1>
1>// Project Object Structure
1>//   oRelated is a dbView
1>//     WorkSpaceBtn is a Button
1>//     BuildFileWorkList is a Button
1>//     RelatedFileListGrid is a Grid
1>//     ReworkListArray is a Array
1>//     RecurArray is a Array
1>//     Mew32 is a Form
1>//     RelatedRpt is a Form
1>//     PrintLog is a Button
1>//     FieldSortCheckBox is a CheckBox
1>//     CloseOpenTypeSize is a Button
1>//     ProcessOverLaps is a CheckBox
1>//     CurrentFileList is a Form
1>
1>// Register all objects
1>Register_Object BuildFileWorkList
#REM FMAC FOR DATAFLEX FOR WINDOWS.
2>Register_Object CloseOpenTypeSize
2>Register_Object CurrentFileList
2>Register_Object FieldSortCheckBox
2>Register_Object Mew32
2>Register_Object oRelated
2>Register_Object PrintLog
2>Register_Object ProcessOverLaps
2>Register_Object RecurArray
2>Register_Object RelatedFileListGrid
2>Register_Object RelatedRpt
2>Register_Object ReworkListArray
2>Register_Object WorkSpaceBtn
2>
2>
2>//AB/ AppBuild VIEW
2>
2>
2>//AB-StoreTopStart
/ORELATEDHDR RESIDENT
Image 1, ORELATEDHDR
   __________________
--------------------------------------|---------------------------------------------|-----------------------------------------|---------------------------------------------|-------------------------------------------|--------------------------------------------|--------------------------------------------|
   Data      :______________________________________________________________   User    :___________________________________
   File List :______________________________________________________________   Machine :__________________
 File-Feld Child File Field           Type    File-Feld Parent File Field           Type    File-Feld Child File Field         Type     File-Feld Child File Field          Type    File-Feld Child File Field           Type    File-Feld Child File Field           Type   File-Feld Child File Field
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/oRelatedBody Resident
Image 2, ORELATEDBODY
 __0.-_0.  ________________________  ___ _0.  __0.-_0.  ________________________  ___ _0.  __0.-_0.  ________________________  ___ _0.  _0_.-_0.  ________________________  ___ _0.  _0_.-_0.  ________________________  ___ _0.  _0_.-_0.  ________________________  ___ _0.  _0_.-_0.  ________________________
/oRelatedHdrCSV Resident
Image 3, ORELATEDHDRCSV
/oRelatedBodyCSV Resident
Image 4, ORELATEDBODYCSV
/oRelatedFooter Resident
Image 5, ORELATEDFOOTER
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
2>
2>External_Function Win32_WNetGetUser "WNetGetUserA" MPR.dll ;   Pointer lpName;   Pointer lpUserName;   String  lpnLength;   Returns DWord
External_Function Win32_WNetGetUser "WNetGetUserA" MPR.dll ;   Pointer lpName;   Pointer lpUserName;   String  lpnLength;   Returns DWord
ERROR: 4298 Command not found EXTERNAL_FUNCTION ON LINE: 63 (2) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
2>
2>External_Function Win32_GetComputername "GetComputerNameA" kernel32.dll ;      Pointer  sBuffer ;      Pointer  lSize   ;      Returns Integer //Boolean
External_Function Win32_GetComputername "GetComputerNameA" kernel32.dll ;      Pointer  sBuffer ;      Pointer  lSize   ;      Returns Integer //Boolean
ERROR: 4298 Command not found EXTERNAL_FUNCTION ON LINE: 71 (2) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
2>
2>Type __vsdwSizeGetComputerName
Type __vsdwSizeGetComputerName
ERROR: 4298 Command not found TYPE ON LINE: 73 (2) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
2>    Field dwSize as dWord
    Field dwSize as dWord
ERROR: 4298 Command not found FIELD ON LINE: 74 (2) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
2>End_Type
End_Type
ERROR: 4298 Command not found END_TYPE ON LINE: 75 (2) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
2>
2>Function GetComputerNameFunc  Returns String
3>    Local String  strName
4>    Local Pointer lpNameAddr
ERROR: 4345 Type check error POINTER, POINTER,  ON LINE: 80 (4) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4>    Local Integer iResult
4>    Local Pointer lpSize
ERROR: 4345 Type check error POINTER, POINTER,  ON LINE: 82 (4) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4>    Local String  lsSize
4>    Move (Repeat(Character(0),255)) To strName
5>    GetAddress Of strName To lpNameAddr
    GetAddress Of strName To lpNameAddr
ERROR: 4298 Command not found GETADDRESS ON LINE: 85 (5) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5>    Move (Repeat( Character(0), __vsdwSizeGetComputerName_SIZE )) To lsSize
ERROR: 54 Invalid symbol in expression __VSDWSIZEGETCOMPUTERNAME_SIZE ON LINE: 86 (5) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
6>    Put 16 To lsSize at dwSize
    Put 16 To lsSize at dwSize
ERROR: 4298 Command not found PUT ON LINE: 87 (6) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
6>    GetAddress Of lsSize To lpSize
    GetAddress Of lsSize To lpSize
ERROR: 4298 Command not found GETADDRESS ON LINE: 88 (6) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
6>    Move (Win32_GetComputername(lpNameAddr, lpSize )) To iResult
ERROR: 54 Invalid symbol in expression WIN32_GETCOMPUTERNAME ON LINE: 89 (6) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
7>    If iresult ;       Function_Return (cstring(strName))
ERROR: 54 Invalid symbol in expression CSTRING ON LINE: 91 (7) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
10>    Else ;       Function_Return "Unknown"
12>End_Function // vsWin32_GetComputerName
13>
13>Function WNetGetUserFunc  Returns String
14>  Local String strName
15>  Local Pointer lpNameAddr
ERROR: 4345 Type check error POINTER, POINTER,  ON LINE: 98 (15) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
15>  Local Integer iResult
15>  Move (Repeat(Character(0),255)) To strName
16>  GetAddress Of strName To lpNameAddr
  GetAddress Of strName To lpNameAddr
ERROR: 4298 Command not found GETADDRESS ON LINE: 101 (16) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
16>  Move (Win32_WNetGetUser(0, lpNameAddr, DWORDtoBytes(255))) To iResult
ERROR: 54 Invalid symbol in expression WIN32_WNETGETUSER ON LINE: 102 (16) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
17>  If iresult Eq 0 ;      Function_Return (Uppercase(Cstring(strName)))
ERROR: 54 Invalid symbol in expression CSTRING ON LINE: 104 (17) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
20>  Else ;      Function_Return "Unknown"
22>End_Function // vsWin32_WNetGetUser
23>
23>Use Statpnl
INCLUDING FILE: STATPNL.PKG
23>>>//************************************************************************
23>>>// Confidential Trade Secret.
23>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
23>>>// as an unpublished work.  All rights reserved.
23>>>// DataFlex is a registered trademark of Data Access Corporation.
23>>>//
23>>>//************************************************************************
23>>>//
23>>>// $File name  : StatPnl.pkg
23>>>// $File title : Status Panel Support for VDF
23>>>// Notice      :
23>>>// $Author(s)  : John Tuohy
23>>>//
23>>>// $Rev History
23>>>//
23>>>// JT  9/22/97   Added status_params, status_default_params and changed
23>>>//               interface for no-cancel, and created interface for additional
23>>>//               parameter passing
23>>>// JT 06/27/97   Added no-cancel support w/ Allow_cancel_state
23>>>// JT ??/??/96   File created for VDF 4.0
23>>>//************************************************************************
23>>>
23>>>// Host/Sentinel Status Panel
23>>>//
23>>>use Windows.pkg
INCLUDING FILE: WINDOWS.PKG
23>>>>>Use winbase.pkg
INCLUDING FILE: WINBASE.PKG
23>>>>>>>//*************************************************************************
23>>>>>>>//*
23>>>>>>>//*  Copyright (c) 1997 Data Access Corporation, Miami Florida,
23>>>>>>>//*  All rights reserved.
23>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.
23>>>>>>>//*
23>>>>>>>//*************************************************************************
23>>>>>>>//*
23>>>>>>>//*  Module Name:
23>>>>>>>//*      WINDOWS.PKG
23>>>>>>>//*
23>>>>>>>//*  Creator:
23>>>>>>>//*      DataFlex 4.0 Development Team
23>>>>>>>//*      01/01/1997
23>>>>>>>//*
23>>>>>>>//*  Purpose:
23>>>>>>>//*      DataFlex 4.0 Windows classes and constants
23>>>>>>>//*
23>>>>>>>//* 07/23/96 JJT - New Class names
23>>>>>>>//*************************************************************************
23>>>>>>>use ui
23>>>>>>>
23>>>>>>>use registry
INCLUDING FILE: REGISTRY.PKG
23>>>>>>>>>//  Registry Access Package
23>>>>>>>>>//  2/17/96 by Michael Gouker
23>>>>>>>>>//
23>>>>>>>>>//  This package defines commands to access the registry.
23>>>>>>>>>
23>>>>>>>>>Use Windows
23>>>>>>>>>Use Dll
INCLUDING FILE: DLL.PKG
23>>>>>>>>>>>//*************************************************************************
23>>>>>>>>>>>//*
23>>>>>>>>>>>//*  Copyright (c) 1997 Data Access Corporation, Miami Florida,
23>>>>>>>>>>>//*  All rights reserved.
23>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.
23>>>>>>>>>>>//*
23>>>>>>>>>>>//*************************************************************************
23>>>>>>>>>>>//*
23>>>>>>>>>>>//*  Module Name:
23>>>>>>>>>>>//*      DLL.PKG
23>>>>>>>>>>>//*
23>>>>>>>>>>>//*  Creator:
23>>>>>>>>>>>//*      Data Access Corporation
23>>>>>>>>>>>//*
23>>>>>>>>>>>//*  Purpose:
23>>>>>>>>>>>//*      Define the commands and replacements needed to call external
23>>>>>>>>>>>//*      function in Dynamic Link Libraies.
23>>>>>>>>>>>//*
23>>>>>>>>>>>//*  Modifications:
23>>>>>>>>>>>//*      JVH - Apr 30, 1999
23>>>>>>>>>>>//*      Changed Pointer, DWord & Handle types from Number to Integer. They
23>>>>>>>>>>>//*      should always have been this way. Now we can use the Handle type
23>>>>>>>>>>>//*      to store Object ID's.
23>>>>>>>>>>>//*          Previously we defined the pointer data type as a DataFlex number.
23>>>>>>>>>>>//*          This was a flag that will tell the DLL calling code that the passed parameter
23>>>>>>>>>>>//*          is a pointer and should be placed on the stack as a 4 byte value. (no longer done)
23>>>>>>>>>>>//*
23>>>>>>>>>>>//*************************************************************************
23>>>>>>>>>>>
23>>>>>>>>>>>use windows
23>>>>>>>>>>>define support$Address
23>>>>>>>>>>>
23>>>>>>>>>>>// The following set of replacements define the type of load for the
23>>>>>>>>>>>// DLL.  Each load type has the standard set of trade offs, speed
23>>>>>>>>>>>// vs memory.  A lib that is loaded each time is probable the most memory
23>>>>>>>>>>>// efficient, but suffers from load speed overhead.  However, large DLLs
23>>>>>>>>>>>// that are retained in memory are not using system resources as
23>>>>>>>>>>>// efficientry as possible.  Note that some DLLs are already in memory.
23>>>>>>>>>>>// The Windows Kernel and USER libs are already loaded by Windows, and
23>>>>>>>>>>>// do not take up more memory.
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>// External function command declairs the external entry point to
23>>>>>>>>>>>// The DF system.  The compiler creates a reference to the function
23>>>>>>>>>>>// complete with return type and parameter information.  The macro
23>>>>>>>>>>>// also generates code that retains the name of the function and the
23>>>>>>>>>>>// name of the library in a runtime array.  This array is used when
23>>>>>>>>>>>// the DLL is "loaded".
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>//External_Function FunctionName "FunctionName" DLLName {Parameters ...} Returns DataType
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>//External$Function Command Flag GET_|MSG_ FunctionName {"FunctionName"} DLLName {Parameters ...} Returns DataType
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>// Define the sizes of the known data types
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>
23>>>>>>>>>>>// Since DF allows the imbedding of binary zeros in strings, strings
23>>>>>>>>>>>// passed back to DF (via reference pointers) often need to be sized
23>>>>>>>>>>>// based on the position of the zero terminator.  This function will
23>>>>>>>>>>>// a valid DF string from a 'C' string.
23>>>>>>>>>>>
23>>>>>>>>>>>Function CString Global String Buffer Returns String
24>>>>>>>>>>>    Local Integer TermPos
25>>>>>>>>>>>    Pos (Character(0)) in Buffer to TermPos
27>>>>>>>>>>>>
27>>>>>>>>>>>    Function_Return (left(buffer,termpos-1))
28>>>>>>>>>>>End_Function
29>>>>>>>>>>>
29>>>>>>>>>>>Function DWORDtoBytes Global Integer aDWORD Returns String
30>>>>>>>>>>>    Function_Return ( ;          character(low(aDWORD) iand 255) + ;          character(low(aDWORD) / 256) + ;          character(hi(aDWORD) iand 255) + ;          character(hi(aDWORD) / 256) )
31>>>>>>>>>>>End_Function
32>>>>>>>>>>>
32>>>>>>>>>>>Function SHORTtoBytes Global Integer SHORT Returns String
33>>>>>>>>>>>    Function_Return ( ;          character( SHORT iand 255) + ;          character( SHORT / 256) )
34>>>>>>>>>>>End_Function
35>>>>>>>>>>>
35>>>>>>>>>>>Function BytesToSHORT Global String Buffer Integer Offset Returns Integer
36>>>>>>>>>>>    local integer in1 in2
37>>>>>>>>>>>    ascii (mid(Buffer,1,Offset)) to in1
38>>>>>>>>>>>>
38>>>>>>>>>>>    ascii (mid(Buffer,1,Offset+1)) to in2
39>>>>>>>>>>>>
39>>>>>>>>>>>    move ( in1 + (in2*256) ) to in1
40>>>>>>>>>>>    if in2 gt 127 Move (in1 - 65536) to in1
43>>>>>>>>>>>    function_return ( in1 )
44>>>>>>>>>>>End_Function
45>>>>>>>>>>>
45>>>>>>>>>>>Function BytesToDWORD Global String Buffer Integer Offset Returns Integer
46>>>>>>>>>>>    Local integer in1 in2 in3 in4
47>>>>>>>>>>>
47>>>>>>>>>>>    ascii (Mid( Buffer, 1, offset )) to in1
48>>>>>>>>>>>>
48>>>>>>>>>>>    ascii (Mid( Buffer, 1, offset+1 )) to in2
49>>>>>>>>>>>>
49>>>>>>>>>>>    ascii (Mid( Buffer, 1, offset+2 )) to in3
50>>>>>>>>>>>>
50>>>>>>>>>>>    ascii (Mid( Buffer, 1, offset+3 )) to in4
51>>>>>>>>>>>>
51>>>>>>>>>>>
51>>>>>>>>>>>    move (in1 + (in2*256) + (in3*65536) + (in4*16777216)) to in1
52>>>>>>>>>>>    function_return in1
53>>>>>>>>>>>End_Function
54>>>>>>>>>>>
54>>>>>>>>>>>Function CVTtoBytes Global Integer iValue Integer Offset Integer DSize String Host Returns String
55>>>>>>>>>>>    Local String Buff
56>>>>>>>>>>>    if      DSize eq 2 Move (SHORTtoBytes(iValue)) to Buff
59>>>>>>>>>>>    Else if DSize eq 4 Move (DWORDtoBytes(iValue)) to Buff
63>>>>>>>>>>>    Else               Move (Character(iValue))    to Buff
65>>>>>>>>>>>    Function_Return (OverStrike(Buff, Host, Offset))
66>>>>>>>>>>>End_Function
67>>>>>>>>>>>
67>>>>>>>>>>>Function BytestoCVT Global String sValue Integer Offset Integer DSize Returns Integer
68>>>>>>>>>>>    Local Integer iValue
69>>>>>>>>>>>    if      DSize eq 2 Move (BytestoShort(sValue,Offset)) to iValue
72>>>>>>>>>>>    Else if DSize eq 4 Move (BytestoDWORD(sValue,Offset)) to iValue
76>>>>>>>>>>>    Else               Move (Ascii(mid(sValue,1,Offset))) to iValue
78>>>>>>>>>>>    Function_Return (iValue)
79>>>>>>>>>>>End_Function
80>>>>>>>>>>>
80>>>>>>>>>>>Function StringtoBytes Global String sValue Integer Offset Integer DSize String Host Returns String
81>>>>>>>>>>>    local string  Buff
82>>>>>>>>>>>    local integer Len
82>>>>>>>>>>>    length sValue to Len
83>>>>>>>>>>>>
83>>>>>>>>>>>    If      Len lt DSize Move (sValue+(repeat(character(0),DSize-Len))) to Buff
86>>>>>>>>>>>    Else if Len gt DSize Move (left(sValue,DSize)) to Buff
90>>>>>>>>>>>    Else                 Move sValue to Buff
92>>>>>>>>>>>    Function_Return (OverStrike(Buff, Host, Offset))
93>>>>>>>>>>>End_Function
94>>>>>>>>>>>
94>>>>>>>>>>>// Memory access functions without strings.
94>>>>>>>>>>>
94>>>>>>>>>>>Function MemoryGetByte Global Integer Buffer Integer Offset Returns Integer
95>>>>>>>>>>>    local integer in1
96>>>>>>>>>>>    move (derefc(Buffer,Offset)) to in1
97>>>>>>>>>>>    function_return in1
98>>>>>>>>>>>End_Function
99>>>>>>>>>>>
99>>>>>>>>>>>Function MemoryGetWord Global Integer Buffer Integer Offset Returns Integer
100>>>>>>>>>>>    local integer in1
101>>>>>>>>>>>    move (derefw(Buffer,Offset)) to in1
102>>>>>>>>>>>    function_return in1
103>>>>>>>>>>>End_Function
104>>>>>>>>>>>
104>>>>>>>>>>>Function MemoryGetDWORD Global Integer Buffer Integer Offset Returns Integer
105>>>>>>>>>>>    local integer in1
106>>>>>>>>>>>    move (derefdw( Buffer, offset)) to in1
107>>>>>>>>>>>    function_return in1
108>>>>>>>>>>>End_Function
109>>>>>>>>>>>
109>>>>>>>>>>>Procedure MemoryPutByte Global Integer iValue Integer Offset integer Host
110>>>>>>>>>>>    local integer in1
111>>>>>>>>>>>    move (storec ( Host, offset, IValue)) to in1
112>>>>>>>>>>>End_Procedure
113>>>>>>>>>>>
113>>>>>>>>>>>Procedure MemoryPutWord Global Integer iValue Integer Offset integer Host
114>>>>>>>>>>>    local integer in1
115>>>>>>>>>>>    move (storew( Host, offset, IValue)) to in1
116>>>>>>>>>>>End_Procedure
117>>>>>>>>>>>
117>>>>>>>>>>>Procedure MemoryPutDWord Global Integer iValue Integer Offset integer Host
118>>>>>>>>>>>    local integer in1
119>>>>>>>>>>>    move (storedw( Host, offset, IValue)) to in1
120>>>>>>>>>>>End_Procedure
121>>>>>>>>>>>
121>>>>>>>>>>>Function AddBitValue GLOBAL integer iBitValue integer iSource RETURNS integer
122>>>>>>>>>>>    Function_Return (iSource IOR iBitValue)
123>>>>>>>>>>>End_Function
124>>>>>>>>>>>
124>>>>>>>>>>>Function RemoveBitValue GLOBAL integer iBitValue integer iSource RETURNS integer
125>>>>>>>>>>>    if (iSource IAND iBitValue) eq iBitValue Begin
127>>>>>>>>>>>        Function_Return (iSource - iBitValue)
128>>>>>>>>>>>    End
128>>>>>>>>>>>>
128>>>>>>>>>>>    Else Function_Return iSource
130>>>>>>>>>>>End_Function
131>>>>>>>>>>>
131>>>>>>>>>>>
131>>>>>>>>>>>
131>>>>>>>>>>>
131>>>>>>>>>>>
131>>>>>>>>>>>
131>>>>>>>>>>>
131>>>>>>>>>>>
131>>>>>>>>>>>
131>>>>>>>>>Use DFTypes
INCLUDING FILE: DFTYPES.PKG
131>>>>>>>>>>>//************************************************************************
131>>>>>>>>>>>//--- DFTypes.pkg
131>>>>>>>>>>>//
131>>>>>>>>>>>// Copyright (c) 1983-1997 Data Access Corporation, Miami Florida,
131>>>>>>>>>>>// All rights reserved.
131>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
131>>>>>>>>>>>//
131>>>>>>>>>>>//************************************************************************
131>>>>>>>>>>>//  Description:
131>>>>>>>>>>>//      Common TYPEs used by the Windows' API from DataFlex.
131>>>>>>>>>>>//
131>>>>>>>>>>>//  Author: Stuart W. Booth
131>>>>>>>>>>>//************************************************************************
131>>>>>>>>>>>Use DLL
131>>>>>>>>>>>
131>>>>>>>>>>>TYPE tPOINT
131>>>>>>>>>>>    Field tPOINT.x as DWORD
131>>>>>>>>>>>    Field tPOINT.y as DWORD
131>>>>>>>>>>>END_TYPE
131>>>>>>>>>>>
131>>>>>>>>>>>TYPE tRECT
131>>>>>>>>>>>    Field tRECT.left     as DWORD
131>>>>>>>>>>>    Field tRECT.top      as DWORD
131>>>>>>>>>>>    Field tRECT.right    as DWORD
131>>>>>>>>>>>    Field tRECT.bottom   as DWORD
131>>>>>>>>>>>END_TYPE
131>>>>>>>>>>>
131>>>>>>>>>>>TYPE tPAINTSTRUCT
131>>>>>>>>>>>    Field tPAINTSTRUCT.hdc            as HANDLE
131>>>>>>>>>>>    Field tPAINTSTRUCT.fErase         as INTEGER
131>>>>>>>>>>>    Field tPAINTSTRUCT.rcPaint.left   as INTEGER
131>>>>>>>>>>>    Field tPAINTSTRUCT.rcPaint.top    as INTEGER
131>>>>>>>>>>>    Field tPAINTSTRUCT.rcPaint.right  as INTEGER
131>>>>>>>>>>>    Field tPAINTSTRUCT.rcPaint.bottom as INTEGER
131>>>>>>>>>>>    Field tPAINTSTRUCT.fRestore       as INTEGER
131>>>>>>>>>>>    Field tPAINTSTRUCT.fIncUpdate     as INTEGER
131>>>>>>>>>>>    Field tPAINTSTRUCT.rgbReserved    as CHAR 32
131>>>>>>>>>>>END_TYPE
131>>>>>>>>>>>
131>>>>>>>>>>>
131>>>>>>>>>>>TYPE tNMHDR
131>>>>>>>>>>>    Field tNMHDR.hWndFrom as HANDLE
131>>>>>>>>>>>    Field tNMHDR.idFrom   as DWORD
131>>>>>>>>>>>    Field tNMHDR.code     as DWORD
131>>>>>>>>>>>END_TYPE
131>>>>>>>>>>>
131>>>>>>>>>>>TYPE tHANDLE
131>>>>>>>>>>>    Field tHANDLE.handle As Handle
131>>>>>>>>>>>END_TYPE
131>>>>>>>>>>>
131>>>>>>>>>>>TYPE tDWORD
131>>>>>>>>>>>    Field tDWORD.dword As DWord
131>>>>>>>>>>>END_TYPE
131>>>>>>>>>>>
131>>>>>>>>>>>TYPE tWindowPlacement
131>>>>>>>>>>>    Field tWindowPlacement.length                  as DWORD
131>>>>>>>>>>>    Field tWindowPlacement.flags                   as DWORD
131>>>>>>>>>>>    Field tWindowPlacement.showCmd                 as DWORD
131>>>>>>>>>>>    Field tWindowPlacement.ptMinPosition.x         as DWORD
131>>>>>>>>>>>    Field tWindowPlacement.ptMinPosition.y         as DWORD
131>>>>>>>>>>>    Field tWindowPlacement.ptMaxPosition.x         as DWORD
131>>>>>>>>>>>    Field tWindowPlacement.ptMaxPosition.y         as DWORD
131>>>>>>>>>>>    Field tWindowPlacement.rcNormalPosition.left   as DWORD
131>>>>>>>>>>>    Field tWindowPlacement.rcNormalPosition.top    as DWORD
131>>>>>>>>>>>    Field tWindowPlacement.rcNormalPosition.right  as DWORD
131>>>>>>>>>>>    Field tWindowPlacement.rcNormalPosition.bottom as DWORD
131>>>>>>>>>>>END_TYPE
131>>>>>>>>>>>
131>>>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>// These are the key root values.
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>// This command retrieves the tree root of the registry and the default key path.
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>// This command sets the tree root of the registry and the default key path.
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>// This command retrieves the value associated with the application and
131>>>>>>>>>// tag passed.  If the tag is not found, then the return value will be
131>>>>>>>>>// a null string.  If the string is not found in the application, but
131>>>>>>>>>// it is found in the [DEFAULTS] section, this string will be returned.
131>>>>>>>>>//  Usage:  Get_Profile_String AppName TagName to ValueStr
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>// Mike-S modification for recursion flag
131>>>>>>>>>
131>>>>>>>>>// Mike-S modification for recursion flag
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>//************************************************************************
131>>>>>>>>>//  Description:
131>>>>>>>>>//      Enumerate keys (one level) for a given tag under HKEY_LOCAL_MACHINE
131>>>>>>>>>//
131>>>>>>>>>//      The function, EnumRegistryKey, takes a Tag (eg SOFTWARE\DFWIN40) and
131>>>>>>>>>//      'returns' all sub-keys. This is achieved by passing the function a
131>>>>>>>>>//      call-back procedure-id. The call-back will take one parameter, a string,
131>>>>>>>>>//      that is the name of the sub-key.
131>>>>>>>>>//
131>>>>>>>>>//      The return value is the number of sub-keys enumerated.
131>>>>>>>>>//
131>>>>>>>>>//  Author: Stuart W. Booth
131>>>>>>>>>//************************************************************************
131>>>>>>>>>
131>>>>>>>>>//DEFINE_SYMBOL HKEY_LOCAL_MACHINE |CI$80000002
131>>>>>>>>>
131>>>>>>>>>   // No value type
131>>>>>>>>>   // Unicode nul terminated string
131>>>>>>>>>    // Unicode nul terminated string
131>>>>>>>>>    // (with environment variable references)
131>>>>>>>>>   // Free form binary
131>>>>>>>>>   // 32-bit number
131>>>>>>>>>   // 32-bit number (same as REG_DWORD)
131>>>>>>>>>   // 32-bit number
131>>>>>>>>>   // Symbolic Link (unicode)
131>>>>>>>>>   // Multiple Unicode strings
131>>>>>>>>>   // Resource list in the resource map
131>>>>>>>>>
131>>>>>>>>>
131>>>>>>>>>// Stuart's external functions --------------------------------------------
131>>>>>>>>>
131>>>>>>>>>External_Function RegOpenKeyEx "RegOpenKeyExA" AdvApi32.dll ;    Handle hKey String sSubKey DWord ulOptions DWord samDesired Pointer lphKey ;    Returns Dword
132>>>>>>>>>
132>>>>>>>>>External_Function RegCloseKey "RegCloseKey" AdvApi32.dll ;    Handle hKey ;    Returns DWord
133>>>>>>>>>
133>>>>>>>>>External_Function RegEnumKeyEx "RegEnumKeyExA" AdvApi32.dll ;    Handle hKey Dword dwIndex Pointer lpsName Pointer lpcbName ;    Pointer lpReserved Pointer lpClass Pointer lpcbClass Pointer pTime ;    Returns DWord
134>>>>>>>>>
134>>>>>>>>>External_Function RegSetValueEx "RegSetValueExA" AdvApi32.dll ;    Handle hKey String sValueName Dword dwReserved Dword dwType Pointer lpsData Dword cbData ;    Returns Dword
135>>>>>>>>>
135>>>>>>>>>External_Function RegQueryValueEx "RegQueryValueExA" AdvApi32.dll ;    Handle hKey String sValueName Pointer lpRes Pointer lpsDwType Pointer lpsData Pointer lpcbData ;    Returns Dword
136>>>>>>>>>
136>>>>>>>>>Class Windows_Registry is an Array
137>>>>>>>>>
137>>>>>>>>>    Procedure construct_object
138>>>>>>>>>        Forward Send Construct_Object
140>>>>>>>>>        property integer phRegistry_Root public HKEY_LOCAL_MACHINE
141>>>>>>>>>
141>>>>>>>>>        // Mike-S modification for recursion flag
141>>>>>>>>>        property integer bRecurse public FALSE
142>>>>>>>>>    End_Procedure
143>>>>>>>>>
143>>>>>>>>>    Function EnumKeys integer hKey returns Integer
144>>>>>>>>>        Local integer iKeyCnt
145>>>>>>>>>        REG_ENUM_KEY_INFO (object_id(current_object))
146>>>>>>>>>
146>>>>>>>>>        // Mike-S modification for recursion flag
146>>>>>>>>>        REG_ENUM_KEY hKey (bRecurse(Current_Object)) 
147>>>>>>>>>        Function_Return iKeyCnt
148>>>>>>>>>    End_Function
149>>>>>>>>>
149>>>>>>>>>    Function EnumValues integer hKey returns Integer
150>>>>>>>>>        Local integer iKeyCnt
151>>>>>>>>>        REG_ENUM_KEY_INFO (object_id(current_object))
152>>>>>>>>>
152>>>>>>>>>        // Mike-S modification for recursion flag
152>>>>>>>>>        REG_ENUM_VALUE hKey (bRecurse(Current_Object)) 
153>>>>>>>>>        Function_Return iKeyCnt
154>>>>>>>>>    End_Function
155>>>>>>>>>
155>>>>>>>>>    Function CreateKey string sKeyName Returns Integer
156>>>>>>>>>        Local integer hKeyWrkSpc
157>>>>>>>>>        REG_CREATE_KEY sKeyName TO hKeyWrkSpc
158>>>>>>>>>        Function_Return hKeyWrkSpc
159>>>>>>>>>    End_Function
160>>>>>>>>>
160>>>>>>>>>    Function CloseKey integer hKey
161>>>>>>>>>        if hKey begin
163>>>>>>>>>            REG_CLOSE_KEY hKey
164>>>>>>>>>            Function_Return TRUE
165>>>>>>>>>        end
165>>>>>>>>>>
165>>>>>>>>>        else;            Function_Return FALSE
167>>>>>>>>>    End_Function
168>>>>>>>>>
168>>>>>>>>>    Function OpenKey string sKeyName Returns Integer
169>>>>>>>>>        Local integer hKeyWrkSpc
170>>>>>>>>>        REG_OPEN_KEY sKeyName TO hKeyWrkSpc
171>>>>>>>>>        Function_Return hKeyWrkSpc
172>>>>>>>>>    End_Function
173>>>>>>>>>
173>>>>>>>>>//    Function EnumRegistryKey String sKeyName Integer hmCallBack Returns Integer
173>>>>>>>>>    Function EnumRegistryKey String sKeyName Returns Integer
174>>>>>>>>>        Local Integer hKeyWrkSpc
175>>>>>>>>>        Local Integer iKeyCount
175>>>>>>>>>        REG_OPEN_KEY sKeyName to hKeyWrkSpc
176>>>>>>>>>        if hKeyWrkSpc ne 0 begin
178>>>>>>>>>            REG_ENUM_KEY_INFO (object_id(current_object))
179>>>>>>>>>            // Mike-S modification for recursion flag
179>>>>>>>>>            REG_ENUM_KEY hKeyWrkSpc (bRecurse(Current_Object)) 
180>>>>>>>>>            REG_CLOSE_KEY hKeyWrkSpc
181>>>>>>>>>        end
181>>>>>>>>>>
181>>>>>>>>>        Function_Return iKeyCount
182>>>>>>>>>    End_Function
183>>>>>>>>>
183>>>>>>>>>End_Class
184>>>>>>>>>
184>>>>>>>>>Procedure Set Profile_Dword Global String sKey String sValueName Dword dwValue
185>>>>>>>>>    REG_SET_DWORD "" sKey sValueName to dwValue
189>>>>>>>>>End_Procedure
190>>>>>>>>>
190>>>>>>>>>//  This function can be used instead of the one below if you would rather
190>>>>>>>>>//  pass the function the 'default return value' to return in the event
190>>>>>>>>>//  that the value requested doesn't exist.
190>>>>>>>>>//
190>>>>>>>>>//Function Profile_Dword Global String sKey String sValueName integer defValue Returns Dword
190>>>>>>>>>//    local integer dwValue
190>>>>>>>>>//    REG_GET_DWORD "" sKey sValueName defValue to dwValue
190>>>>>>>>>//    Function_Return dwValue
190>>>>>>>>>//End_Function
190>>>>>>>>>
190>>>>>>>>>//  If the registry value requested doesn't exist, the value defined
190>>>>>>>>>//  by REG_VALUE_NOT_EXIST will be returned.
190>>>>>>>>>//
190>>>>>>>>>Function Profile_Dword Global String sKey String sValueName Returns Dword
191>>>>>>>>>    local integer dwValue defValue
192>>>>>>>>>    move REG_VALUE_NOT_EXIST to defValue
193>>>>>>>>>    REG_GET_DWORD "" sKey sValueName defValue to dwValue
197>>>>>>>>>>
197>>>>>>>>>    Function_Return dwValue
198>>>>>>>>>End_Function
199>>>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>//#REPLACE U_DFComboButton                |CI39  // no longer exists
199>>>>>>>//#REPLACE U_DFComboForm                  |CI45  // no longer exists
199>>>>>>>//#REPLACE U_DFVconsole                   |CI67  // no longer exists
199>>>>>>>
199>>>>>>>//* Justification modes */
199>>>>>>>
199>>>>>>>
199>>>>>>>// New Justification modes - undocumented vertical-center by MS
199>>>>>>>//#REPLACE jmCenter    $0001
199>>>>>>>//#REPLACE jmVCenter   $1000
199>>>>>>>//#REPLACE jmAllCenter $1001
199>>>>>>>
199>>>>>>>//* Form Justificationmodes */
199>>>>>>>
199>>>>>>>//* Button Aspects */
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>// Map modes
199>>>>>>>
199>>>>>>>//* Borders */
199>>>>>>>
199>>>>>>>//* View Modes */
199>>>>>>>
199>>>>>>>// Data Types
199>>>>>>>
199>>>>>>>// Make Proportional constants
199>>>>>>>
199>>>>>>>
199>>>>>>>// ImageList constants
199>>>>>>>
199>>>>>>>// Buttonbar constants
199>>>>>>>// Button Styles
199>>>>>>>
199>>>>>>>
199>>>>>>>// icon indexes for standard bitmaps
199>>>>>>>
199>>>>>>>// icon indexes for standard view bitmaps
199>>>>>>>
199>>>>>>>
199>>>>>>>// MAPI constants
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>// MAPIFindNext() flags.
199>>>>>>>
199>>>>>>>// MAPIReadMail() flags.
199>>>>>>>
199>>>>>>>
199>>>>>>>// Masked Edit control constants
199>>>>>>>
199>>>>>>>// Form Button constants
199>>>>>>>
199>>>>>>>// Grid Modes
199>>>>>>>
199>>>>>>>// Bitmap Styles
199>>>>>>>
199>>>>>>>//* Window Messages */
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>Define USE_RGB_COLORS // this determines if RGB support is being used
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>// Key Extensions
199>>>>>>>Register_Function Virtual_Key returns integer
199>>>>>>>Register_Function Shift_State returns integer
199>>>>>>>
199>>>>>>>Register_Procedure Set DDE_Server_Link integer conversation
199>>>>>>>
199>>>>>>>Register_Function Reg_Key_Enum integer iKey string szKeyName returns Integer
199>>>>>>>Register_Function Reg_Integer_Value_Enum string szKeyName integer dwKeyValue returns Integer
199>>>>>>>Register_Function Reg_String_Value_Enum string szKeyName string szKeyValue returns Integer
199>>>>>>>
199>>>>>>>// serial i/o extensions.
199>>>>>>>
199>>>>>>>register_procedure fill_comm_timeouts pointer pCommTimeouts
199>>>>>>>register_procedure set comm_timeouts pointer pCommTimeouts
199>>>>>>>register_procedure fill_comm_properties pointer pCommProps
199>>>>>>>register_procedure set comm_mask integer eventmask
199>>>>>>>register_function comm_mask returns integer
199>>>>>>>register_function comm_modem_status returns integer
199>>>>>>>register_procedure set comm_dcb pointer pDCB
199>>>>>>>register_procedure  fill_dcb pointer pDCB
199>>>>>>>
199>>>>>>>// keyboard emulation.
199>>>>>>>
199>>>>>>>register_procedure generate_virtual_key integer keyval integer flags
199>>>>>>>register_procedure generate_df_key integer keyval integer flags
199>>>>>>>register_procedure onkeyup integer winWParam integer winLParam
199>>>>>>>register_procedure onsyskeyup integer winWParam integer winLParam
199>>>>>>>
199>>>>>>>// flags can be added together.
199>>>>>>>
199>>>>>>>
199>>>>>>>// line stuff
199>>>>>>>
199>>>>>>>register_function horizontal_state returns integer
199>>>>>>>register_procedure set horizontal_state integer iState
199>>>>>>>register_function line_thickness returns integer
199>>>>>>>register_procedure set line_thickness integer iThickness
199>>>>>>>register_function line_offset returns integer
199>>>>>>>register_procedure set line_offset integer iOffset
199>>>>>>>register_function line_style returns integer
199>>>>>>>register_procedure set line_style integer iStyle
199>>>>>>>register_function top_line_color returns integer
199>>>>>>>register_procedure set top_line_color integer iTopLineColor // system color
199>>>>>>>register_function bottom_line_color returns integer
199>>>>>>>register_procedure set bottom_line_color integer iBottomLineColor // system color
199>>>>>>>
199>>>>>>>
199>>>>>>>// main window of application controls popup windows.
199>>>>>>>
199>>>>>>>
199>>>>>>>Register_Function Mapi_Attachment_Count Returns Integer
199>>>>>>>Register_Function Mapi_Attachment_Path Integer ct Returns String
199>>>>>>>Register_Function Mapi_Attachment_File Integer ct Returns String
199>>>>>>>
199>>>>>>>Register_Procedure Mapi_Reply
199>>>>>>>Register_Procedure SET MAPI_Message_Subject String subject
199>>>>>>>
199>>>>>>>Register_Function Mapi_Message_ReceiverName Integer rcvno Returns String
199>>>>>>>Register_Procedure Set Mapi_Message_ReceiverName Integer rcvno String rcvname
199>>>>>>>
199>>>>>>>Register_Procedure Set Bitmap_Style Integer style
199>>>>>>>Register_Function      Bitmap_Style Returns Integer
199>>>>>>>Register_Function      Bitmap_Width Returns Integer
199>>>>>>>Register_Function      Bitmap_Height Returns Integer
199>>>>>>>Register_Procedure Set Transparent_State Integer state
199>>>>>>>Register_Function      Transparent_State Returns Integer
199>>>>>>>
199>>>>>>>register_procedure set main_window integer wnd
199>>>>>>>register_function main_window returns integer
199>>>>>>>
199>>>>>>>
199>>>>>>>Register_Procedure Set Default_Icons Integer defico
199>>>>>>>Register_Function      Default_Icons Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure OnDeltaPos Integer item# Integer DeltaInfo
199>>>>>>>Register_Procedure Set Form_Button_Bitmap Integer item# String btmname
199>>>>>>>Register_Procedure     Form_Button_Mouse_Down Integer item# Integer counter
199>>>>>>>
199>>>>>>>Register_Procedure Set Form_Justification_Mode Integer item# Integer mode
199>>>>>>>Register_Function Form_Justification_Mode Integer item# Returns Integer
199>>>>>>>
199>>>>>>>
199>>>>>>>Register_Procedure Form_Button_Notification Integer item# Integer position
199>>>>>>>
199>>>>>>>// sentinel program allows multiprocessing for process control.
199>>>>>>>
199>>>>>>>register_procedure set sentinelwindow integer hnd
199>>>>>>>register_function sentinelwindow returns integer
199>>>>>>>register_procedure set sentinel_program string name_of_sentinel
199>>>>>>>register_function sentinel_program returns string
199>>>>>>>register_function start_sentinel_program returns integer
199>>>>>>>register_function stop_sentinel_program returns integer
199>>>>>>>register_procedure set sentinel_return_value integer val
199>>>>>>>register_function sentinel_return_value returns integer
199>>>>>>>// shared data.
199>>>>>>>register_function HostData integer iBeg integer iLen returns string
199>>>>>>>register_function SentinelData integer iBeg integer iLen returns string
199>>>>>>>register_procedure Set HostData string stuff integer iBeg integer iLen
199>>>>>>>register_procedure Set SentinelData string stuff integer iBeg integer iLen
199>>>>>>>register_procedure OnSentinelDataChange integer iBeg integer iLen
199>>>>>>>
199>>>>>>>// for radio button toggling.
199>>>>>>>
199>>>>>>>register_procedure Notify_Select_State integer objId integer itemNo
199>>>>>>>
199>>>>>>>Register_Function Masked_Value Integer item# Returns String
199>>>>>>>
199>>>>>>>Register_Procedure Set Oem_Translate_State Integer state
199>>>>>>>Register_Function      Oem_Translate_State Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure Set Form_Button Integer item Integer type
199>>>>>>>Register_Procedure Set Form_Button_Value Integer item String val
199>>>>>>>
199>>>>>>>register_Procedure set form_mask integer item# string mask
199>>>>>>>register_function          form_mask integer item# returns string
199>>>>>>>
199>>>>>>>register_procedure set item_color integer item number rgbcolor
199>>>>>>>
199>>>>>>>// lowlevel interface to window of object.
199>>>>>>>
199>>>>>>>register_function Window_Style integer stylemask integer and_or
199>>>>>>>register_procedure Set Window_Style integer stylemask integer and_or
199>>>>>>>
199>>>>>>>register_function Extended_Window_Style integer stylemask integer and_or
199>>>>>>>register_procedure Set Extended_Window_Style integer stylemask integer and_or
199>>>>>>>
199>>>>>>>Register_Procedure Header_Notification Integer type Integer item#
199>>>>>>>Register_Procedure Set Horz_Scroll_Bar_Visible_State Integer state
199>>>>>>>Register_Function          Horz_Scroll_Bar_Visible_State Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure Set Current_Item_Color Integer red Integer green Integer blue
199>>>>>>>Register_Function Current_Item_Color returns Integer
199>>>>>>>Register_Procedure Set AutoSize_Height_State Integer state
199>>>>>>>Register_Function AutoSize_Height_State Returns Integer
199>>>>>>>register_procedure initialize_sysmenu integer menuhandle
199>>>>>>>
199>>>>>>>Register_Procedure Set HEADER_JUSTIFICATION_MODE Integer item Integer fmt
199>>>>>>>Register_Function      HEADER_JUSTIFICATION_MODE Integer item# Returns Integer
199>>>>>>>Register_Procedure Set Bitmap_Format Integer fmt
199>>>>>>>Register_Function      Bitmap_Format Returns Integer
199>>>>>>>Register_Procedure Set Password_State Integer item# Integer state
199>>>>>>>Register_Function      Password_State Integer item# Returns Integer
199>>>>>>>register_procedure change_menu integer itemId integer objId integer flags
199>>>>>>>Register_Procedure set timeout_value integer timeout_value
199>>>>>>>Register_Function      timeout_value returns integer
199>>>>>>>Register_Procedure set status_line_object integer objId
199>>>>>>>Register_Function      status_line_object returns integer
199>>>>>>>Register_Procedure set Windows_Override_State integer stateValue
199>>>>>>>Register_Function      Windows_Override_State returns integer
199>>>>>>>Register_Function Menu_Handle returns Integer
199>>>>>>>Register_Procedure Initialize_Menu integer hMenuHandle
199>>>>>>>
199>>>>>>>
199>>>>>>>//  This symbol can be used to detect if an object is in its preconstruction
199>>>>>>>//  phase - before Contruct_Object is called. If BuildingObjectID is GT 0, the
199>>>>>>>//  object is being initialized. The value contained in BuildingObjectID is actually
199>>>>>>>//  the ID of the object currently being initialized.
199>>>>>>>//
199>>>>>>>
199>>>>>>>Register_Function Window_Handle returns integer
199>>>>>>>Register_Function Container_Handle returns integer
199>>>>>>>
199>>>>>>>Register_Function GUISIZE returns integer
199>>>>>>>Register_Procedure Set GUISIZE integer Height integer Width
199>>>>>>>
199>>>>>>>Register_Function CLIENT_SIZE returns integer
199>>>>>>>
199>>>>>>>Register_Function GUILOCATION returns integer
199>>>>>>>Register_Procedure Set GUILOCATION integer Row integer Column
199>>>>>>>
199>>>>>>>Register_Function Form_Window_Handle integer Itm returns integer
199>>>>>>>Register_Procedure Notify_Application_Activation integer flag
199>>>>>>>
199>>>>>>>Register_Function ABSOLUTE_GUIORIGIN returns integer
199>>>>>>>
199>>>>>>>Register_Function FONT returns integer
199>>>>>>>Register_Procedure Set FONT integer font_to_set
199>>>>>>>
199>>>>>>>Register_Function MAP_MODE returns integer
199>>>>>>>Register_Procedure Set MAP_MODE integer mode
199>>>>>>>
199>>>>>>>Register_Function TYPEFACE returns string
199>>>>>>>Register_Procedure Set TYPEFACE string face
199>>>>>>>
199>>>>>>>Register_Function FONTSIZE returns integer
199>>>>>>>Register_Procedure Set FONTSIZE integer height integer width
199>>>>>>>
199>>>>>>>Register_Function PHYSICAL_FONTSIZE returns integer
199>>>>>>>Register_Procedure Set Physical_FontSize integer height integer width
199>>>>>>>
199>>>>>>>Register_Function FONTITALICS returns integer
199>>>>>>>Register_Procedure Set FONTITALICS integer italicsstate
199>>>>>>>
199>>>>>>>Register_Function FONTUNDERLINE returns integer
199>>>>>>>Register_Procedure Set FONTUNDERLINE integer unserlinestate
199>>>>>>>
199>>>>>>>Register_Function BORDER_STYLE returns integer
199>>>>>>>Register_Procedure  Set BORDER_STYLE integer param1
199>>>>>>>
199>>>>>>>Register_Function CLIPPING_MODE returns integer
199>>>>>>>Register_Procedure  Set CLIPPING_MODE integer param1
199>>>>>>>
199>>>>>>>Register_Function FONTWEIGHT returns integer
199>>>>>>>Register_Procedure Set FONTWEIGHT integer param1
199>>>>>>>
199>>>>>>>Register_Function MAP_RATIOS returns integer
199>>>>>>>Register_Procedure Set MAP_RATIOS integer param1 integer param2
199>>>>>>>
199>>>>>>>Register_Function CAPTION_BAR returns integer
199>>>>>>>Register_Procedure Set CAPTION_BAR integer param
199>>>>>>>
199>>>>>>>Register_Function MINIMIZE_ICON returns integer
199>>>>>>>Register_Procedure Set MINIMIZE_ICON integer param
199>>>>>>>
199>>>>>>>Register_Function MAXIMIZE_ICON returns integer
199>>>>>>>Register_Procedure Set MAXIMIZE_ICON integer param
199>>>>>>>
199>>>>>>>Register_Function SYSMENU_ICON returns integer
199>>>>>>>Register_Procedure Set SYSMENU_ICON integer param
199>>>>>>>
199>>>>>>>Register_Function VIEW_MODE returns integer
199>>>>>>>Register_Procedure Set VIEW_MODE integer param
199>>>>>>>
199>>>>>>>Register_Function BORDER_WIDTH returns integer
199>>>>>>>Register_Procedure Set BORDER_WIDTH integer param
199>>>>>>>
199>>>>>>>Register_Function SCROLL_RANGE returns integer
199>>>>>>>Register_Procedure Set SCROLL_RANGE integer param1 integer param2
199>>>>>>>
199>>>>>>>Register_Function PAGESIZE returns integer
199>>>>>>>Register_Procedure Set PAGESIZE integer param
199>>>>>>>
199>>>>>>>Register_Function LINESIZE returns integer
199>>>>>>>Register_Procedure Set LINESIZE integer param
199>>>>>>>
199>>>>>>>Register_Function COLUMN_WIDTH returns integer
199>>>>>>>Register_Procedure Set COLUMN_WIDTH integer param
199>>>>>>>
199>>>>>>>Register_Function JUSTIFICATION_MODE returns integer
199>>>>>>>Register_Procedure SET JUSTIFICATION_MODE integer param
199>>>>>>>
199>>>>>>>Register_Function SORTED_STATE returns integer
199>>>>>>>Register_Procedure Set SORTED_STATE integer param
199>>>>>>>
199>>>>>>>Register_Function UNDO returns integer
199>>>>>>>
199>>>>>>>Register_Function ITEM_TYPE integer param returns integer
199>>>>>>>Register_Procedure Set ITEM_TYPE integer param1 integer param2
199>>>>>>>
199>>>>>>>Register_Function PRIVATEFOREIGNLINK Returns Integer
199>>>>>>>Register_Procedure SET PRIVATEFOREIGNLINK
199>>>>>>>
199>>>>>>>Register_Function FOREIGNLINK Returns Integer
199>>>>>>>Register_Procedure SET FOREIGNLINK
199>>>>>>>
199>>>>>>>Register_Function ACKSTATE Returns Integer
199>>>>>>>Register_Procedure SET ACKSTATE
199>>>>>>>
199>>>>>>>Register_Function LINKTEMPERATURE Returns Integer
199>>>>>>>Register_Procedure SET LINKTEMPERATURE
199>>>>>>>
199>>>>>>>Register_Function RETRYCOUNT Returns Integer
199>>>>>>>Register_Procedure SET RETRYCOUNT
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_WIDTH integer form_number integer param
199>>>>>>>Register_Function FORM_WIDTH    integer form_number  Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_HEIGHT integer form_number integer param
199>>>>>>>Register_Function FORM_HEIGHT    integer form_number  Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_COLOR integer form_number integer param
199>>>>>>>Register_Function FORM_COLOR    integer form_number  Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_DATATYPE  integer form_number integer param
199>>>>>>>Register_Function FORM_DATATYPE integer form_number  Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_OPTIONS  integer form_number integer param
199>>>>>>>Register_Function FORM_OPTIONS  integer form_number  Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_FONT   integer form_number integer param
199>>>>>>>Register_Function FORM_FONT     integer form_number  Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_ROW    integer form_number integer param
199>>>>>>>Register_Function FORM_ROW      integer form_number  Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_COLUMN integer form_number integer param
199>>>>>>>Register_Function FORM_COLUMN   integer form_number  Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_TYPEFACE      integer form_number string param
199>>>>>>>Register_Function FORM_TYPEFACE           integer form_number returns string
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_FONTHEIGHT    integer form_number int param
199>>>>>>>Register_Function FORM_FONTHEIGHT         integer form_number returns integer
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_FONTWEIGHT    integer form_number int param
199>>>>>>>Register_Function FORM_FONTWEIGHT         integer form_number returns integer
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_FONTITALICS   integer form_number int param
199>>>>>>>Register_Function FORM_FONTITALICS        integer form_number returns integer
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_FONTUNDERLINE integer form_number int param
199>>>>>>>Register_Function FORM_FONTUNDERLINE      integer form_number returns integer
199>>>>>>>
199>>>>>>>Register_Procedure SET BUTTON_ASPECT  integer form_number integer param
199>>>>>>>Register_Function  BUTTON_ASPECT      integer form_number  Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure Set NAME String oName
199>>>>>>>Register_Procedure Set BITMAP String BitmapName
199>>>>>>>
199>>>>>>>Register_Function DDE_INITIATE integer Remote string Path Returns integer
199>>>>>>>Register_Function SESS_REQUEST string dataitem  Returns string
199>>>>>>>Register_Function SESS_RECEIVE string dataitem string buffer Returns integer
199>>>>>>>Register_Function SESS_TERMINATE Returns integer
199>>>>>>>Register_Function SESS_EXECUTE string commands Returns integer
199>>>>>>>Register_Function SESS_CONNECT string app string topic Returns integer
199>>>>>>>Register_Function SESS_READ string dataitem Returns string
199>>>>>>>Register_Function SESS_WRITE string dataitem string buffer Returns integer
199>>>>>>>Register_Function SESS_DISCONNECT Returns integer
199>>>>>>>Register_Function SESS_PERFORM string commands Returns integer
199>>>>>>>register_procedure set dde_timeout_value integer val
199>>>>>>>register_function dde_timeout_value returns integer
199>>>>>>>
199>>>>>>>Register_Function SELECTED_OBJECTID returns integer
199>>>>>>>
199>>>>>>>Register_Procedure  SET BUTTON_ASPECT   integer formwindow integer aspect
199>>>>>>>Register_Function  BUTTON_ASPECT        integer item returns integer
199>>>>>>>
199>>>>>>>Register_Procedure  SET BUTTON_POSITION integer position
199>>>>>>>Register_Function  BUTTON_POSITION      returns integer
199>>>>>>>
199>>>>>>>Register_Procedure  SET BANDED_OBJECT   integer user_object
199>>>>>>>Register_Function   BANDED_OBJECT       returns integer
199>>>>>>>
199>>>>>>>Register_Procedure  SET AUTO_ALIGN   integer t_f
199>>>>>>>Register_Function   AUTO_ALIGN       returns integer
199>>>>>>>
199>>>>>>>Register_Function   COMBO_DATA_OBJECT returns integer
199>>>>>>>Register_Procedure  SET COMBO_DATA_OBJECT returns integer
199>>>>>>>
199>>>>>>>Register_Procedure  SET COMBO_LIST_OFFSET   integer offset
199>>>>>>>Register_Function       COMBO_LIST_OFFSET   returns integer
199>>>>>>>
199>>>>>>>Register_Procedure  SET COMBO_BUTTON_OFFSET   integer offset
199>>>>>>>Register_Function       COMBO_BUTTON_OFFSET   returns integer
199>>>>>>>
199>>>>>>>Register_Procedure  SET COMBO_LIST_GUI_OFFSET   integer offset
199>>>>>>>Register_Function       COMBO_LIST_GUI_OFFSET   returns integer
199>>>>>>>
199>>>>>>>Register_Procedure  SET COMBO_BUTTON_GUI_OFFSET   integer offset
199>>>>>>>Register_Function       COMBO_BUTTON_GUI_OFFSET   returns integer
199>>>>>>>
199>>>>>>>Register_Procedure PULLDOWN_COMBOLIST
199>>>>>>>
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_GUIWIDTH    integer formwindow integer iwidth
199>>>>>>>Register_Function  FORM_GUIWIDTH        integer formwindow returns integer
199>>>>>>>Register_Procedure SET FORM_GUIHEIGHT   integer formwindow integer iheight
199>>>>>>>Register_Function  FORM_GUIHEIGHT       integer formwindow returns integer
199>>>>>>>Register_Procedure SET FORM_GUIROW      integer formwindow integer irow
199>>>>>>>Register_Function  FORM_GUIROW          integer formwindow returns integer
199>>>>>>>Register_Procedure SET FORM_GUICOLUMN   integer formwindow integer icolumn
199>>>>>>>Register_Function  FORM_GUICOLUMN       integer formwindow returns integer
199>>>>>>>
199>>>>>>>
199>>>>>>>Register_Procedure HSCROLL integer direction integer amount
199>>>>>>>
199>>>>>>>Register_Procedure EXPORT_CLIPBOARD_DATA
199>>>>>>>Register_Procedure IMPORT_CLIPBOARD_DATA
199>>>>>>>
199>>>>>>>Register_Procedure SET FORM_MARGIN   integer formwindow integer iwidth
199>>>>>>>Register_Function  FORM_MARGIN       integer formwindow returns integer
199>>>>>>>
199>>>>>>>
199>>>>>>>Register_Procedure ENUMERATE_FONTS string facename
199>>>>>>>Register_Function  USER_FONTNAME string facename integer height returns integer
199>>>>>>>
199>>>>>>>Register_Procedure Set Icon String IconName
199>>>>>>>Register_Function PARENT_RATIOS returns integer
199>>>>>>>
199>>>>>>>Register_Procedure  SET BANDING_OBJECT   integer banding_object
199>>>>>>>Register_Function   BANDING_OBJECT       returns integer
199>>>>>>>
199>>>>>>>Register_Procedure MAKE_PROPORTIONAL integer container integer semantics
199>>>>>>>
199>>>>>>>Register_Procedure SYSTEM_HELP string HelpFile string Topic
199>>>>>>>
199>>>>>>>Register_Function DLL_NAME returns string
199>>>>>>>
199>>>>>>>Register_Procedure RETURN_TO_PRIOR_SCOPE
199>>>>>>>Register_Procedure REQUEST_CANCEL
199>>>>>>>Register_Procedure CHOOSE
199>>>>>>>Register_Procedure SET IGNORE_EXIT_STATE integer newstate
199>>>>>>>Register_Function IGNORE_EXIT_STATE returns integer
199>>>>>>>Register_Procedure SET VERIFY_EXIT_MSG integer newmsg
199>>>>>>>Register_Function VERIFY_EXIT_MSG returns integer
199>>>>>>>Register_Procedure SET AUTO_PULL_DOWN_STATE integer newstate
199>>>>>>>Register_Function AUTO_PULL_DOWN_STATE returns integer
199>>>>>>>Register_Function ACTION_BAR_LOCATION returns integer
199>>>>>>>Register_Function ACTION_BAR_WIDTH returns integer
199>>>>>>>Register_Procedure ADD_POPUP_MENU integer pd_objid string strval
199>>>>>>>Register_Procedure EXIT_AREA
199>>>>>>>Register_Procedure EXIT_CASCADE
199>>>>>>>//Register_Procedure REDIRECT_MESSAGE returns integer
199>>>>>>>Register_Procedure ACTIVATE_PULL_DOWN
199>>>>>>>Register_Procedure SET ACTION_BAR_LOCATION integer container_object
199>>>>>>>
199>>>>>>>Register_Procedure SET ACTION_BAR_KEYS_MSG integer xMessage
199>>>>>>>Register_Function  Action_Bar_Keys returns integer
199>>>>>>>
199>>>>>>>Register_Function  AUTO_SCALE_FONT_STATE returns integer
199>>>>>>>
199>>>>>>>Register_Procedure SET AUTO_SCALE_FONT_STATE integer new_state
199>>>>>>>
199>>>>>>>Register_Procedure SCALE_FONTS
199>>>>>>>
199>>>>>>>Register_Procedure Set Form_Option Integer FormNum Integer Option Integer State
199>>>>>>>Register_Function Form_Option Integer FormNum Integer Option Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure Adjust_Logicals
199>>>>>>>
199>>>>>>>Register_Function Exit_System_Confirmation returns integer
199>>>>>>>
199>>>>>>>Register_Procedure Set Caption_Bar_Highlight Integer State
199>>>>>>>
199>>>>>>>Register_Procedure Activate_Sysmenu integer AllowDelegation
199>>>>>>>
199>>>>>>>Register_Function Pull_Left_State returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure Set Pull_Left_State integer state
199>>>>>>>
199>>>>>>>Register_Function Text_Extent String TextVal Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure System_Context_Help String HelpFile Integer Topic
199>>>>>>>
199>>>>>>>Register_Procedure Set Mouse_Capture
199>>>>>>>Register_Function Mouse_Capture Returns Integer
199>>>>>>>Register_Procedure Release_Mouse_Capture
199>>>>>>>
199>>>>>>>Register_Procedure Set Header_Label Integer Item# String lbl
199>>>>>>>//Register_Function Header_Label Integer Item# returns string
199>>>>>>>Register_Procedure Set Form_Bitmap integer item# string bitmapname
199>>>>>>>
199>>>>>>>Register_Procedure Set HIGHLIGHT_ROW_STATE Integer state
199>>>>>>>Register_Function      HIGHLIGHT_ROW_STATE Returns Integer
199>>>>>>>Register_Procedure Set HIGHLIGHT_ROW_COLOR Integer rgbColor
199>>>>>>>Register_Function      HIGHLIGHT_ROW_COLOR Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure Set Header_Visible_State Integer state
199>>>>>>>Register_Function      Header_Visible_State Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure SET FOCUS integer new_focus_wnd integer old_focus_wnd
199>>>>>>>Register_Procedure Begin_Event integer event_type
199>>>>>>>Register_Procedure End_Event integer event_type
199>>>>>>>Register_Procedure Notify integer controlID integer pNMHDR
199>>>>>>>
199>>>>>>>Register_Function Mapi_Send_Documents String pname String fname Returns Integer
199>>>>>>>Register_Function Mapi_InitMessage String pname String fname Returns Integer
199>>>>>>>Register_Function Mapi_Send_Mail Integer flags Returns Integer
199>>>>>>>Register_Function Mapi_Address_Book String caption Integer flag Returns Integer
199>>>>>>>Register_Function Mapi_Find_Next String Subject Integer flags Returns String
199>>>>>>>Register_Function Mapi_Message_Subject Returns String
199>>>>>>>Register_Function Mapi_Read_Mail String mailid Integer flags Returns Integer
199>>>>>>>Register_Function Mapi_Message_Sendername Returns String
199>>>>>>>Register_Function Mapi_Message_DateReceived Returns String
199>>>>>>>Register_Procedure Edit_To_Mail Integer editobj
199>>>>>>>Register_Procedure Mail_To_Edit Integer editobj
199>>>>>>>
199>>>>>>>Register_Procedure Set  Bitmap_Size         Integer sx Integer sy
199>>>>>>>Register_Procedure Set  ImageList_Size      Integer bit Integer grow
199>>>>>>>Register_Procedure Set  ImageList_Type      Integer type
199>>>>>>>Register_Procedure      ImageList_Create
199>>>>>>>Register_Procedure      ImageList_Destroy
199>>>>>>>Register_Procedure      ImageList_Add       String bitmap
199>>>>>>>Register_Procedure      ImageList_BeginDrag Integer bitmap#
199>>>>>>>Register_Procedure Set  ImageList_DragObject Integer dragobj
199>>>>>>>Register_Procedure      ImageList_DragEnter  Integer cx Integer cy
199>>>>>>>Register_Procedure      ImageList_DragMove  Integer cx Integer cy
199>>>>>>>Register_Procedure      ImageList_DragLeave
199>>>>>>>Register_Procedure      ImageList_EndDrag
199>>>>>>>Register_Function       ImageList_DragObject Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure Set ToolTip_State Integer form Integer state
199>>>>>>>Register_Function      ToolTip_State Integer form Returns integer
199>>>>>>>Register_Procedure Set ToolTip_Value Integer form String val
199>>>>>>>Register_Function      ToolTip_Value Integer form Returns String
199>>>>>>>Register_Procedure Set ImageList Integer imgobj
199>>>>>>>Register_Procedure Set Form_Image_Index Integer form Integer idx
199>>>>>>>Register_Function      Form_Image_Index Integer form Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure     Show_View_Name String sName
199>>>>>>>
199>>>>>>>Register_Procedure Set Button_Style Integer form Integer idx
199>>>>>>>Register_Function      Button_Style Integer form Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure Auto_Size Integer sy Integer sx
199>>>>>>>Register_Procedure Auto_Page Integer objid
199>>>>>>>
199>>>>>>>Register_Procedure Undo
199>>>>>>>Register_Procedure Delete
199>>>>>>>
199>>>>>>>Register_Procedure Set MDI_State Integer state
199>>>>>>>Register_Function      MDI_State Returns Integer
199>>>>>>>Register_Procedure Set MDI_Left_Margin Integer state
199>>>>>>>Register_Function      MDI_Left_Margin Returns Integer
199>>>>>>>Register_Procedure Set MDI_Top_Margin Integer state
199>>>>>>>Register_Function      MDI_Top_Margin Returns Integer
199>>>>>>>Register_Procedure Set MDI_Right_Margin Integer state
199>>>>>>>Register_Function      MDI_Right_Margin Returns Integer
199>>>>>>>Register_Procedure Set MDI_Bottom_Margin Integer state
199>>>>>>>Register_Function      MDI_Bottom_Margin Returns Integer
199>>>>>>>
199>>>>>>>Register_Procedure Set MDI_Window_Pulldown Integer winpull
199>>>>>>>Register_Function      MDI_Window_Pulldown Returns Integer
199>>>>>>>
199>>>>>>>// Notify focus change TRUE is sent when an object takes the focus.
199>>>>>>>// Notify focus change FALSE is sent when an object loses the focus.
199>>>>>>>// These messages are sent at the time the window associated with an object
199>>>>>>>// receives the WM_SETFOCUS or WM_KILLFOCUS message.
199>>>>>>>
199>>>>>>>Register_Procedure Notify_Focus_Change integer bFocus
199>>>>>>>
199>>>>>>>// Exit_Menu is sent when the action bar pulldown system exits.
199>>>>>>>// It is sent to the pulldown that is active (or the action bar if no pulldown is
199>>>>>>>// active) at the time the system exits.
199>>>>>>>
199>>>>>>>Register_Procedure Exit_Menu
199>>>>>>>
199>>>>>>>// Edit class.
199>>>>>>>
199>>>>>>>register_function current_offset returns integer
199>>>>>>>register_function current_selection_range returns integer
199>>>>>>>register_procedure set undo_state integer state
199>>>>>>>register_function undo_state returns integer
199>>>>>>>register_procedure reset_find
199>>>>>>>register_procedure reset_replace
199>>>>>>>register_procedure append string stuff_to_append
199>>>>>>>register_procedure select integer pos integer bytes
199>>>>>>>register_function buffer_count returns integer
199>>>>>>>register_procedure set edit_buffer_size integer sizeset
199>>>>>>>register_function edit_buffer_size returns integer
199>>>>>>>register_procedure set text_limit integer limitset
199>>>>>>>register_function text_limit returns integer
199>>>>>>>register_procedure set edit_errspace_message integer msgset
199>>>>>>>register_function edit_errspace_message returns integer
199>>>>>>>register_procedure set tabstop integer tabstop integer position
199>>>>>>>register_function tabstop integer tabstop returns integer
199>>>>>>>register_procedure set format_origin int x int y
199>>>>>>>register_function  format_origin returns integer
199>>>>>>>register_procedure set format_size int x int y
199>>>>>>>register_function format_size returns integer
199>>>>>>>
199>>>>>>>register_function timeout_message returns integer
199>>>>>>>register_procedure set timeout_message integer msg_to_send
199>>>>>>>register_function timeout_request integer event_msg integer time_elapsed returns integer
199>>>>>>>register_procedure mapi_add_receiver integer int1 integer int2
199>>>>>>>
199>>>>>>>
199>>>>>>>// Rubber band stuff
199>>>>>>>
199>>>>>>>register_function destroy_rubber_band integer i returns integer
199>>>>>>>register_function create_rubber_band integer i returns integer
199>>>>>>>register_function create_rubber_band_manual integer i returns integer
199>>>>>>>register_function track_df_window integer i returns integer
199>>>>>>>register_function track_current_window returns integer
199>>>>>>>register_function track_number_of_bands returns integer
199>>>>>>>register_function track_get_rectangle integer i1 integer i2 returns integer
199>>>>>>>register_function track_set_position integer hWnd returns integer
199>>>>>>>register_procedure set Band_position integer i1 integer i2
199>>>>>>>register_procedure set Band_Size integer i1 integer i2
199>>>>>>>register_procedure set band_transparent_flag integer i1
199>>>>>>>register_procedure set band_size_move_flag integer i1
199>>>>>>>register_procedure set band_size_move_min integer i1 integer i2
199>>>>>>>register_procedure set band_multiselect_flag integer i1
199>>>>>>>
199>>>>>>>register_function dfTrackdfWindow integer idx returns integer
199>>>>>>>register_function dfTrackCurrentWindow returns integer
199>>>>>>>register_function dfTrackNumberOfBands returns INTEGER
199>>>>>>>register_function dfTrackGetRectangle integer hWnd integer lpRect returns INTEGER
199>>>>>>>register_function dfTrackSetPosition integer hWnd INTEGER pLeft INTEGER pTop INTEGER pRight INTEGER pBottom returns INTEGER
199>>>>>>>register_function dfCreateRubberBand integer hWnd INTEGER PX INTEGER PY INTEGER SX INTEGER SY;                                INTEGER tFlag INTEGER SMFlag INTEGER SMinX INTEGER SMinY ;                                RETURNS INTEGER
199>>>>>>>register_function dfCreateRubberBandManual  integer hW INTEGER PX INTEGER PY INTEGER SX INTEGER SY ;                            INTEGER tF INTEGER SMF INTEGER SMX INTEGER SMY INTEGER bM ;                            RETURNS INTEGER
199>>>>>>>register_function dfDestroyRubberBand integer hWnd returns Integer
199>>>>>>>
199>>>>>>>
199>>>>>>>register_function      Brush returns integer //?????????
199>>>>>>>
199>>>>>>>register_procedure set TextColor integer rgbColor
199>>>>>>>register_function      TextColor returns integer
199>>>>>>>register_procedure set Color integer rgbColor
199>>>>>>>register_function      Color returns integer
199>>>>>>>register_procedure set CurrentCellColor integer rgbColor
199>>>>>>>register_function      CurrentCellColor returns integer
199>>>>>>>register_procedure set CurrentCellTextColor integer rgbColor
199>>>>>>>register_function      CurrentCellTextColor  returns integer
199>>>>>>>register_procedure set ItemColor integer iItem integer rgbColor
199>>>>>>>register_function      ItemColor integer iItem returns integer
199>>>>>>>register_procedure set ItemTextColor integer iItem integer rgbColor
199>>>>>>>register_function      ItemTextColor integer iItem returns integer
199>>>>>>>register_procedure set CurrentRowColor integer rgbColor
199>>>>>>>register_function      CurrentRowColor returns integer
199>>>>>>>register_procedure set CurrentRowtTextColor  integer rgbColor
199>>>>>>>register_function      CurrentRowTextColor returns integer
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>// This command is the same as GET_CURRENT_DIRECTORY except that a
199>>>>>>>// new parameter has been provided to get the directory  of any drive.
199>>>>>>>// if specified drive is 0, the current drive is used.  Drive A is 1.
199>>>>>>>//   Usage:  Get_Drive_Directory DriveNum to DirString
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>
199>>>>>>>//  This method is in place specifically to aid in the customization of
199>>>>>>>//  system menus on panels and dialogs. Use this message to remove specific
199>>>>>>>//  items from a sysmenu by passing the string to be removed (e.g. "&Close"),
199>>>>>>>//  the object ID of the sysmenu being manipulated, and the starting item#
199>>>>>>>//  to begin searching for the string (usually item 0). The complete string
199>>>>>>>//  should be passed and/or wildcards (* and ?) can be used as well. Remember
199>>>>>>>//  to include the "&" symbol before characters which would appear with an
199>>>>>>>//  underline in the sysmenu at runtime. Also, to remove the dividing lines
199>>>>>>>//  in system menus pass the string "" (nothing).
199>>>>>>>//
199>>>>>>>//  Example:    Send Remove_Item "S&witch*" (sysmenu_icon(current_object)) 0
199>>>>>>>//
199>>>>>>>//  Why use this method instead of just deleting the item by #? Because not
199>>>>>>>//  all versions of Windows will have the same number or ordering of items in
199>>>>>>>//  the system menu(s). This method allows your programs to be more portable
199>>>>>>>//  across Windows 3.1x, NT, and Windows 95.
199>>>>>>>//
199>>>>>>>Procedure Remove_Item Global String iVal Integer Obj# Integer sItem#
200>>>>>>>    Get Item_Matching of Obj# iVal to sItem#
201>>>>>>>    If sItem# NE -1 Send Delete_Item to Obj# sItem#
204>>>>>>>End_Procedure
205>>>>>>>
205>>>>>>>// The GetAddress Command returns the memory address of a DF string
205>>>>>>>// variable.  The command is necessary where external function require
205>>>>>>>// The address of a string to be passed.
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>// Get_Program_Key to Program-Key-Name
205>>>>>>>// returns name of key that started the program. Returns blank
205>>>>>>>// if no key (program was started with file name).
205>>>>>>>
205>>>>>>>
205>>>>>>>// This command returns the state of a key of the keyboard.
205>>>>>>>//
205>>>>>>>//      1st Parameter is the virtual key code of the key being tested.
205>>>>>>>//      2nd Parameter receives the result.
205>>>>>>>//
205>>>>>>>
205>>>>>>>
205>>>>>>>// This command maps a virtual key to a scancode.
205>>>>>>>//
205>>>>>>>//      1st Parameter is the virtual key code to translate.
205>>>>>>>//      2nd Parameter is the translated scancode.
205>>>>>>>//
205>>>>>>>
205>>>>>>>
205>>>>>>>// This command maps a scancode to a virtual key.
205>>>>>>>//
205>>>>>>>//      1st Parameter is the scancode to translate.
205>>>>>>>//      2nd Parameter is the translated virtual key code.
205>>>>>>>//
205>>>>>>>
205>>>>>>>
205>>>>>>>// This command maps a character to a virtual key code and shift state.
205>>>>>>>//
205>>>>>>>//      1st Parameter is the char to translate. Integer represents TCHAR.
205>>>>>>>//      2nd Parameter is the virtual key code and shift state.
205>>>>>>>//        If the function succeeds, the low-order byte of the return value contains the virtual-key code
205>>>>>>>//    and the high-order byte contains the shift state, which can be a combination of the following flag
205>>>>>>>//    bits:
205>>>>>>>//
205>>>>>>>//Bit  1 Meaning  Either SHIFT key is pressed.
205>>>>>>>//     2 Either CTRL key is pressed.
205>>>>>>>//     4 Either ALT key is pressed.
205>>>>>>>//
205>>>>>>>//        If the function finds no key that translates to the passed character code, both the low-order
205>>>>>>>//    and high-order bytes contain -1.
205>>>>>>>//
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>
205>>>>>>>// Retreives: Version, Revision and Build
205>>>>>>>
205>>>>>>>
205>>>>>>>BEGIN$NEW$ERROR$SYSTEM        // internal
206>>>>>>>BEGIN$NEW$MOUSE$INTERFACE     // internal
207>>>>>>>
207>>>>>>>// Define all Form properties that require an index (item). If the item parameter
207>>>>>>>// is omitted item 0 is used as a default. This allows single item objects (e.g. Form)
207>>>>>>>// to omit the item number. (e.g. Set Password_State to True).
207>>>>>>>
207>>>>>>>
207>>>>>>>// These are index (item or form) tem based properties that require two
207>>>>>>>// parameters in the set statement following the "to". Please do not
207>>>>>>>// create any more of these kinds of messages
207>>>>>>>
207>>>>>>>
207>>>>>>>Set_Default_Map_Mode to Map_Dialog
208>>>>>>>
208>>>>>>>Use DfBase.pkg //**JJT** Very last thing is to include extended base classes
INCLUDING FILE: DFBASE.PKG
208>>>>>>>>>// Define the following "Base" Classes:
208>>>>>>>>>// 07/23/96 JJT - New Class names
208>>>>>>>>>//
208>>>>>>>>>// Class Mixin
208>>>>>>>>>// Class TextBox
208>>>>>>>>>// Class MenuBar
208>>>>>>>>>// Class PopupMenu
208>>>>>>>>>// Class FloatingPopupMenu
208>>>>>>>>>// Class FormFloatingPopupMenu
208>>>>>>>>>// Class SystemMenu
208>>>>>>>>>// Class Button
208>>>>>>>>>// Class Edit
208>>>>>>>>>// Class List
208>>>>>>>>>// Class Form
208>>>>>>>>>// Class Grid
208>>>>>>>>>// Class Entry
208>>>>>>>>>// Class EntryList
208>>>>>>>>>// Class BasicPanel
208>>>>>>>>>// Class ToolPanel
208>>>>>>>>>// Class Dialog
208>>>>>>>>>// Class Container3d
208>>>>>>>>>// Class Group
208>>>>>>>>>// Class Container
208>>>>>>>>>// Class CheckBox
208>>>>>>>>>// Class RadioButton
208>>>>>>>>>// Class MdiClientArea
208>>>>>>>>>// Class MdiDialog
208>>>>>>>>>// Class BasicToolBar
208>>>>>>>>>// Class VertScrollBar
208>>>>>>>>>// Class HorzScrollBar
208>>>>>>>>>// Class ImageList
208>>>>>>>>>//
208>>>>>>>>>// Class DFObject
208>>>>>>>>>// Class DFWindow
208>>>>>>>>>// Class DFUIWindow
208>>>>>>>>>// Class DFContainer
208>>>>>>>>>// Class DFDesktop
208>>>>>>>>>// Class DFControl
208>>>>>>>>>// Class DFMenu
208>>>>>>>>>// Class DFList
208>>>>>>>>>// Class DFForm
208>>>>>>>>>// Class DFButton
208>>>>>>>>>//
208>>>>>>>>>// Class DFSession
208>>>>>>>>>// Class DFDllSession
208>>>>>>>>>// Class DFSerial
208>>>>>>>>>// Class DFMapiSession
208>>>>>>>>>//
208>>>>>>>>>// Class DFTriState
208>>>>>>>>>// Class DFCheckList
208>>>>>>>>>// Class DFRadioList
208>>>>>>>>>// Class DFTriStateList
208>>>>>>>>>// Class DFPushButtonList
208>>>>>>>>>
208>>>>>>>>>
208>>>>>>>>>// 04/26/96 JJT - Augmented Set Current_item/Item to handle status bar
208>>>>>>>>>//                refresh in lists. (we need to improve this
208>>>>>>>>>// 04/27/96 JJT - Set DfList border_Style to Client_edge
208>>>>>>>>>// 04/29/96 JJT - Added global function GuiScreen_Size
208>>>>>>>>>// 05/02/96 JJT - Set client_area_State to false in dfmdi_client
208>>>>>>>>>// 02/05/97 JJT - Augmented EntryList set current_item to properly skip
208>>>>>>>>>//                noenter (actually jump to row but stay out of col) and to
208>>>>>>>>>//                work right with the thumb (top list, bottom list)
208>>>>>>>>>// 02/06/97 JJT - Augmented header_notification to pop out the label button.
208>>>>>>>>>// 03/14/97 JJT - Changed Set Object_Shadow_state to look for skipfound.
208>>>>>>>>>//                SkipFound was causing recursion error.
208>>>>>>>>>// 07/30/97 JJT - Added set current_item check in EntryList for negative item
208>>>>>>>>>//  8/2/97  JJT - KeyAction inits RetVal to 0, Else it can stop the UI
208>>>>>>>>>// 08/05/97 JJT - Made two fixes in Grid mixin (activate and set focus) to
208>>>>>>>>>//                workaround two C bugs.
208>>>>>>>>>//  8/5/97  JJT - 1. Added prompt-button/prompt object support to form class and
208>>>>>>>>>//                moved this support from dbform down to entry.
208>>>>>>>>>//                2. Added message prompt_callback to standard object. All popup
208>>>>>>>>>//                dblists now send this. This way all classes support this.
208>>>>>>>>>// 08/07/97 JJT   Added capslock_state support to the following classes:
208>>>>>>>>>//                Form, Entry (for dbForm), Edit. Also added to ComboForm
208>>>>>>>>>//                and comboEntry (in dfcmbfrm) and dbGrid/dbList (in
208>>>>>>>>>//                dfData). Note Grid class is not, yet, supported. Note that
208>>>>>>>>>//                this could be moved to C - each class required a unique
208>>>>>>>>>//                and in some cases, odd, solution.
208>>>>>>>>>//  8/19/97 JJT   Fixed end_construct_object in entry. Shouldn't be commented
208>>>>>>>>>//  9/4/97  KCR/JJT Added default button support to "panel" classes and
208>>>>>>>>>//                button class. Public interface is: get/set default_action_button
208>>>>>>>>>//  9/15/97 KCR/JJT Major change internal workings of default button.
208>>>>>>>>>//  9/19/97 JJT   added set File_name to "" in edit class. If undefined edit will
208>>>>>>>>>//                crash on a read.
208>>>>>>>>>//  9/22/97 KCR   Put back Bitmap_Support_Mixin which provides get/set bitmap
208>>>>>>>>>//                support for classes that support displaying of bitmaps.
208>>>>>>>>>//  9/29/97 KCR   Added Enabled_State to Shadow_Mixin. Enabled_State is now the
208>>>>>>>>>//                preferred public interface for enabling/disabling VDF objects.
208>>>>>>>>>//  9/29/97 KCR   Added SELF symbol as an alternative to CURRENT_OBJECT.
208>>>>>>>>>// 10/15/97 JJT   Use destobj.pkg to get request_destroy_object
208>>>>>>>>>// 10/16/97 JJT   Added Notify_application_activate to ToolPanel (and sub
208>>>>>>>>>//                class ModalPanel) and changed all of these messages to send
208>>>>>>>>>//                onActivateApp and onDeactivateApp to the Main_window (main
208>>>>>>>>>//                panel object.
208>>>>>>>>>// 10/26/97 JJT   Added get default_currency_symbol & added windows currency to
208>>>>>>>>>//                default currency masks
208>>>>>>>>>// 10/26/97 JJT   Added fixed to list class to fix select_count, etc. (see list class).
208>>>>>>>>>// 10/29/97 JJT/KCR Corrected list class (checks item count before setting select state)
208>>>>>>>>>//                Select_state sets window control sel-state directly
208>>>>>>>>>// 11/19/97 JJT   If item is shadowed, disable the context menu (for grids)
208>>>>>>>>>// 11/19/97 JJT   default_action now returns a value (to stop UI if needed)
208>>>>>>>>>// 11/20/97 JJT   Fixed set Read_only_state but in edit
208>>>>>>>>>//11/20/97  JJT   Added new keyboard conversion support from runtme. New global messages
208>>>>>>>>>//                ToOEm, ToAnsi, ConvertChar, To_Ascii. Base classes messages (to be used
208>>>>>>>>>//                within key procedure) AnsiKey, OemKey, DFKey.
208>>>>>>>>>//  1/12/98 JJT   Strip all "." from windows currenct symbol
208>>>>>>>>>//  1/28/98 JJT   Added rgb color support
208>>>>>>>>>//  2/10/98 JJT   Added Mouse_drag augmentation to grids to stop flickering
208>>>>>>>>>// 10/21/98 JJT   For New RT / Added KbdFix.pkg & minor syntax clean ups
208>>>>>>>>>// 11/5/98  JJT   Added version control logic
208>>>>>>>>>//
208>>>>>>>>>// The following classes Currently have no augmentation over their
208>>>>>>>>>// base class implementation. Because of that we maintain their DF
208>>>>>>>>>// access names (since they will behave as they always did). It is not
208>>>>>>>>>// expected that a developer will use any of these.
208>>>>>>>>>
208>>>>>>>>>// Very low level abstract classes. Note that these replacement
208>>>>>>>>>// name are never directly used in the class heirarchy. They are
208>>>>>>>>>// provided so the documented class hierarchy may use these names.
208>>>>>>>>>
208>>>>>>>>>// Low Level Communication classes
208>>>>>>>>>
208>>>>>>>>>// Classes that we currently don't support at other than this
208>>>>>>>>>// very low level. If any of these become needed we will abstract these
208>>>>>>>>>// to a higher level.
208>>>>>>>>>
208>>>>>>>>>
208>>>>>>>>>// Classes that require no augmentation (so far)
208>>>>>>>>>
208>>>>>>>>>
208>>>>>>>>>//  This replacement creates an alternate symbol for Current_Object as used
208>>>>>>>>>//  in message addressing. Future revisions of VDF will use SELF as the
208>>>>>>>>>//  preferred addressing reference.
208>>>>>>>>>//
208>>>>>>>>>
208>>>>>>>>>// Minimum fmac version required for these packages
208>>>>>>>>>// fmac versions are stored in FMAC
208>>>>>>>>>
208>>>>>>>>>// Minimum Runtime version required for these packages
208>>>>>>>>>// return versions returned in version_information
208>>>>>>>>>
208>>>>>>>>>// Current Package version - can be used by programs to
208>>>>>>>>>// make sure the packages are up to date (use command Validate_packages)
208>>>>>>>>>
208>>>>>>>>>// This adds support for the Case command. The only reason this is not provided
208>>>>>>>>>// as part of FMAC is that some developers have created their own custom case command.
208>>>>>>>>>// If you are one of those developers, you are strongly encouraged to use this one
208>>>>>>>>>// instead. If you cannot (or will not) you can comment out this and precompile.
208>>>>>>>>>// Be warned: Next DF revision will probably not allow this command to be optional.
208>>>>>>>>>Use case.mac
INCLUDING FILE: CASE.MAC
208>>>>>>>>>>>//*************************************************************************
208>>>>>>>>>>>// 
208>>>>>>>>>>>//   Copyright (c) 1995 Data Access Corporation, Miami Florida,
208>>>>>>>>>>>//   All rights reserved.
208>>>>>>>>>>>//   DataFlex is a registered trademark of Data Access Corporation.
208>>>>>>>>>>>// 
208>>>>>>>>>>>//*************************************************************************
208>>>>>>>>>>>
208>>>>>>>>>>>//   CASE.MAC
208>>>>>>>>>>>//   version: 2.02e
208>>>>>>>>>>>//   Author John J. Tuohy
208>>>>>>>>>>>
208>>>>>>>>>>>
208>>>>>>>>>
208>>>>>>>>>Use VersionControl.pkg // version control checking commands and procedure
INCLUDING FILE: VERSIONCONTROL.PKG
208>>>>>>>>>>>//************************************************************************
208>>>>>>>>>>>//
208>>>>>>>>>>>// Confidential Trade Secret.
208>>>>>>>>>>>// Copyright 1998 Data Access Corporation, Miami FL, USA
208>>>>>>>>>>>// All Rights reserved
208>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
208>>>>>>>>>>>//
208>>>>>>>>>>>//****************************************************************************//
208>>>>>>>>>>>//                                                                            //
208>>>>>>>>>>>// $File name  : VersionControl.pkg                                           //
208>>>>>>>>>>>// $File title : Internal control for version checking                        //
208>>>>>>>>>>>// Notice      :                                                              //
208>>>>>>>>>>>// $Author(s)  : John Tuohy                                                   //
208>>>>>>>>>>>//                                                                            //
208>>>>>>>>>>>// $Rev History                                                               //
208>>>>>>>>>>>//                                                                            //
208>>>>>>>>>>>// JT  11/9/98 Created                                                        //                                                                           //
208>>>>>>>>>>>//****************************************************************************//
208>>>>>>>>>>>
208>>>>>>>>>>>//This is an internal pakcage and is USEd within dfbase.pkg
208>>>>>>>>>>>//
208>>>>>>>>>>>//This contains two compiler commands and one Runtime command:
208>>>>>>>>>>>//Validate_Fmac Ver# Rev# Build#
208>>>>>>>>>>>//    If version number in fmac is not equal to or greater than the value
208>>>>>>>>>>>//    passed here, a compile error is declared. This command is invoked within this
208>>>>>>>>>>>//    package. The Version numbers are stored in fmac as :
208>>>>>>>>>>>//          FMAC_Version FMAC_Revision FMAC_Build
208>>>>>>>>>>>//    The required version numbers are defined in dfbase.pkg as:
208>>>>>>>>>>>//          Required_FMAC_Version Required_FMAC_Revision Required_FMAC_Build
208>>>>>>>>>>>
208>>>>>>>>>>>
208>>>>>>>>>>>//Validate_Packages Ver# Rev# Build#
208>>>>>>>>>>>//    If version number of package is not equal to or greater than the value
208>>>>>>>>>>>//    passed here, a compile error is declared. The package number is defined in
208>>>>>>>>>>>//    dfbase.pkg as:
208>>>>>>>>>>>//          PKG_Version PKG_Revision PKG_Build
208>>>>>>>>>>>//    This is not invoked automatically but may be added to a developer's
208>>>>>>>>>>>//    program. You must define and pass the minimum required version numbers.
208>>>>>>>>>>>
208>>>>>>>>>>>//Send ValidateVersion
208>>>>>>>>>>>//   This is called at runtime (and is called by this package). It insures that the
208>>>>>>>>>>>//   runtime version (which is stored in dfrun.dll) is equal to or greater than the
208>>>>>>>>>>>//   minimum required runtime version. The minimum is defined in dfbase.pkg as:
208>>>>>>>>>>>//        Required_RT_Version Required_RT_Revision Required_RT_Build
208>>>>>>>>>>>
208>>>>>>>>>>>
208>>>>>>>>>>>
208>>>>>>>>>>>
208>>>>>>>>>>>
208>>>>>>>>>>>
208>>>>>>>>>>>// Validate fmac version against a passed minumum
208>>>>>>>>>>>
208>>>>>>>>>>>// Validate fmac version against a passed minumum
208>>>>>>>>>>>
208>>>>>>>>>>>Procedure ValidateVersion Global integer iReqVersion integer iReqRevision integer iReqBuild
209>>>>>>>>>>>    local Integer iVersion iRevision iBuild
210>>>>>>>>>>>    Version_Information iVersion iRevision iBuild
212>>>>>>>>>>>    //
212>>>>>>>>>>>    If (iVersion < iReqVersion OR ;        (iVersion=iReqVersion AND iRevision<iReqRevision) OR ;        (iVersion=iReqVersion AND iRevision=iReqRevision AND iBuild<iReqBuild) ) Begin
214>>>>>>>>>>>           Error 999 ("Runtime/Package Mismatch: Runtime (" - ;                      string(iVersion) - "." - string(iRevision) - "." - string(iBuild) - ;                      ") Min. Required (" -;                      string(iReqVersion) - "." - string(iReqRevision) - "." - string(iReqBuild) - ")" )
215>>>>>>>>>>>>
215>>>>>>>>>>>           Abort
216>>>>>>>>>>>>
216>>>>>>>>>>>    End
216>>>>>>>>>>>>
216>>>>>>>>>>>End_Procedure
217>>>>>>>>>>>
217>>>>>>>>>>>// This will gen compiler error if fmac is too old
217>>>>>>>>>>>Validate_Fmac Required_FMAC_Version Required_FMAC_Revision Required_FMAC_Build
217>>>>>>>>>>>// This generates a runtime error packages are old
217>>>>>>>>>>>Send ValidateVersion Required_RT_Version Required_RT_Revision Required_RT_Build
218>>>>>>>>>                       // this package will gen compiler and RT errors if fmac
218>>>>>>>>>                       // packages or runtime are out of synch.
218>>>>>>>>>use destobj.pkg      // Object class definitions for object destruction
INCLUDING FILE: DESTOBJ.PKG
218>>>>>>>>>>>//************************************************************************
218>>>>>>>>>>>//
218>>>>>>>>>>>// Confidential Trade Secret.
218>>>>>>>>>>>// Copyright 1987-1995 Data Access Corporation, Miami FL, USA
218>>>>>>>>>>>// All Rights reserved
218>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
218>>>>>>>>>>>//
218>>>>>>>>>>>//************************************************************************
218>>>>>>>>>>>
218>>>>>>>>>>>//************************************************************************
218>>>>>>>>>>>// destobj.Pkg
218>>>>>>>>>>>// Version: 1.0
218>>>>>>>>>>>//  09-12-1992 : Created
218>>>>>>>>>>>//
218>>>>>>>>>>>// Author: John J. Tuohy
218>>>>>>>>>>>//
218>>>>>>>>>>>// Destroys standard (non-DEO) object structures.
218>>>>>>>>>>>//
218>>>>>>>>>>>// Desktop procedures modifies the OBJECT class so all objects inherit
218>>>>>>>>>>>// this message
218>>>>>>>>>>>//
218>>>>>>>>>>>// 09-12-1992 modified to support reverse order child destruction via the
218>>>>>>>>>>>//            request_destroy_children message which uses 3.01's NO_STOP
218>>>>>>>>>>>//            broadcasting capability
218>>>>>>>>>>>//   
218>>>>>>>>>>>//************************************************************************
218>>>>>>>>>>>
218>>>>>>>>>>>use ui
218>>>>>>>>>>>
218>>>>>>>>>>>// Send request_destroy_object to all children in reverse object tree
218>>>>>>>>>>>// order. This will recurse.
218>>>>>>>>>>>//
218>>>>>>>>>>>// Procedure added 09-12-1992
218>>>>>>>>>>>//
218>>>>>>>>>>>Procedure Request_Destroy_Children FOR DESKTOP
219>>>>>>>>>>>  local integer id
220>>>>>>>>>>>  Repeat                                  // For all child objects.
220>>>>>>>>>>>>
220>>>>>>>>>>>    move 0 to ID                          // In case no object is found.
221>>>>>>>>>>>    Broadcast NO_STOP Get Object_ID to ID // Get last ID.
224>>>>>>>>>>>    if id eq 0 Procedure_Return           // If no more children...done.
227>>>>>>>>>>>    Send request_Destroy_Object to id     // RQD this last object
228>>>>>>>>>>>  Loop                                    // and try again.
229>>>>>>>>>>>>
229>>>>>>>>>>>End_Procedure
230>>>>>>>>>>>
230>>>>>>>>>>>Procedure Request_Destroy_Object FOR DESKTOP
231>>>>>>>>>>>  Send Request_Destroy_Children // added 09-12-1992
232>>>>>>>>>>>  // removed 09-12-1992
232>>>>>>>>>>>  // Broadcast Recursive_Up Send Request_Destroy_Object
232>>>>>>>>>>>  Send Destroy_Object
233>>>>>>>>>>>End_Procedure
234>>>>>>>>>>>
234>>>>>>>>>Use DfColor          // symbolic replacements for colors
INCLUDING FILE: DFCOLOR.PKG
234>>>>>>>>>>>//*************************************************************************
234>>>>>>>>>>>//*
234>>>>>>>>>>>//*  Copyright (c) 1997 Data Access Corporation, Miami Florida,
234>>>>>>>>>>>//*  All rights reserved.
234>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.
234>>>>>>>>>>>//*
234>>>>>>>>>>>//*
234>>>>>>>>>>>//*  Module Name:
234>>>>>>>>>>>//*      DFCOLOR.PKG
234>>>>>>>>>>>//*
234>>>>>>>>>>>//*  Creator:
234>>>>>>>>>>>//*      MIKE-Z
234>>>>>>>>>>>//*      01/27/93
234>>>>>>>>>>>//*
234>>>>>>>>>>>//*  Purpose:
234>>>>>>>>>>>//*
234>>>>>>>>>>>//*************************************************************************
234>>>>>>>>>>>
234>>>>>>>>>>>
234>>>>>>>>>>>
234>>>>>>>>>>>
234>>>>>>>>>>>
234>>>>>>>>>>>
234>>>>>>>>>>>
234>>>>>>>>>Use Help_mx          // Context help protocol
INCLUDING FILE: HELP_MX.PKG
234>>>>>>>>>>>//************************************************************************
234>>>>>>>>>>>//
234>>>>>>>>>>>// Confidential Trade Secret.
234>>>>>>>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
234>>>>>>>>>>>// as an unpublished work.  All rights reserved.
234>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
234>>>>>>>>>>>//
234>>>>>>>>>>>//************************************************************************/
234>>>>>>>>>>>
234>>>>>>>>>>>//************************************************************************
234>>>>>>>>>>>// help_mx.pkg
234>>>>>>>>>>>// Version: 1.0
234>>>>>>>>>>>//  12-07-1994 : Created
234>>>>>>>>>>>//
234>>>>>>>>>>>// Author: John J. Tuohy
234>>>>>>>>>>>//
234>>>>>>>>>>>// Use package provides help support to DEO objects.
234>>>>>>>>>>>//
234>>>>>>>>>>>//
234>>>>>>>>>>>// This mixin defines:
234>>>>>>>>>>>//
234>>>>>>>>>>>//   Public:
234>>>>>>>>>>>//     Property Integer Help_id      public 0
234>>>>>>>>>>>//     Property String  Help_Keyword public ''
234>>>>>>>>>>>//
234>>>>>>>>>>>//   Protected:
234>>>>>>>>>>>//     Procedure Define_help_mixin - defines the above properties
234>>>>>>>>>>>//     Function Help_Datafile Returns string
234>>>>>>>>>>>//     Function Help_Context Integer Context_Type Returns String
234>>>>>>>>>>>//
234>>>>>>>>>>>//************************************************************************
234>>>>>>>>>>>// 03/29/95 JJT - Converted back to mixin class from include for 3.1
234>>>>>>>>>>>//************************************************************************
234>>>>>>>>>>>
234>>>>>>>>>>>
234>>>>>>>>>>>//
234>>>>>>>>>>>//  Used when help object makes a request to the object requesting help.
234>>>>>>>>>>>//
234>>>>>>>>>>>DEFINE HELP_CONTEXT_ID        FOR 1
234>>>>>>>>>>>DEFINE HELP_CONTEXT_KEYWORD   FOR 2
234>>>>>>>>>>>DEFINE HELP_CONTEXT_ID_OR_KEY FOR 3
234>>>>>>>>>>>DEFINE HELP_CONTEXT_DATAFILE  FOR 4
234>>>>>>>>>>>DEFINE HELP_CONTEXT_ERROR     FOR 5
234>>>>>>>>>>>
234>>>>>>>>>>>Class Help_Mixin is a Mixin
235>>>>>>>>>>>
235>>>>>>>>>>>   Procedure Define_Help_Mixin
236>>>>>>>>>>>      Property Integer Help_id      public 0
237>>>>>>>>>>>      Property String  Help_Keyword public ''
238>>>>>>>>>>>   End_Procedure // Define_Help_Mixin
239>>>>>>>>>>>
239>>>>>>>>>>>   //  Dummy. Only data-file awre object do this automatically.
239>>>>>>>>>>>   Function Help_Datafile Returns string
240>>>>>>>>>>>   End_Function // Help_Datafile
241>>>>>>>>>>>
241>>>>>>>>>>>   //
241>>>>>>>>>>>   // Function Help_Context Integer Context_type returns String
241>>>>>>>>>>>   //
241>>>>>>>>>>>   // This message is sent to an object by the help system. It is up to
241>>>>>>>>>>>   // the object to return a context value. Depending on the type of
241>>>>>>>>>>>   // context requested (context_type) different values are returned.
241>>>>>>>>>>>   //
241>>>>>>>>>>>   //     Context_type = HELP_CONTEXT_ID
241>>>>>>>>>>>   //       Returns the object's help context Id. Will delegate to the
241>>>>>>>>>>>   //       desktop searching for an id. Uses Help_ID property
241>>>>>>>>>>>   //
241>>>>>>>>>>>   //     Context_type = HELP_CONTEXT_KEYWORD
241>>>>>>>>>>>   //       Returns the object's help keyword Id. Will delegate to the
241>>>>>>>>>>>   //       desktop searching for an id. Uses Help_Keyword property
241>>>>>>>>>>>   //
241>>>>>>>>>>>   //     Context_type = HELP_CONTEXT_ID_OR_KEY
241>>>>>>>>>>>   //       Returns the object's help ID. This can be a context integer ID or
241>>>>>>>>>>>   //       a keyword string id. It first looks for the object context_id. If
241>>>>>>>>>>>   //       this is non-zero, it returns the id. Otherwise, it checks the object
241>>>>>>>>>>>   //       keyword id. If an Id exists it returns it. Else it delegates. Uses
241>>>>>>>>>>>   //       properties help_id and help_keyword.
241>>>>>>>>>>>   //
241>>>>>>>>>>>   //     Context_type = HELP_CONTEXT_DATAFILE
241>>>>>>>>>>>   //       returns the data file and field for the object requesting help.
241>>>>>>>>>>>   //       It returns a string in "FILE.FIELD" format. Blank if no File
241>>>>>>>>>>>   //
241>>>>>>>>>>>   //     Context_type = HELP_CONTEXT_ERROR
241>>>>>>>>>>>   //       Not actually used by DEOs (although it could be). It returns
241>>>>>>>>>>>   //       error context (most likely an error number). Is used by the
241>>>>>>>>>>>   //       error system.
241>>>>>>>>>>>   //
241>>>>>>>>>>>   Function Help_Context Integer Context_Type Returns String
242>>>>>>>>>>>
242>>>>>>>>>>>     local Integer ID
243>>>>>>>>>>>     local String  rVal
243>>>>>>>>>>>
243>>>>>>>>>>>     If Context_Type eq HELP_CONTEXT_ID Begin
245>>>>>>>>>>>        Get Help_ID to ID
246>>>>>>>>>>>        if ID eq 0 Delegate Get Help_Context Context_type to ID
250>>>>>>>>>>>        Move ID to rVal
251>>>>>>>>>>>     End
251>>>>>>>>>>>>
251>>>>>>>>>>>     else If Context_Type eq HELP_CONTEXT_KEYWORD Begin
254>>>>>>>>>>>        Get Help_Keyword to rVal
255>>>>>>>>>>>        if rval eq '' Delegate Get Help_Context Context_Type to rVal
259>>>>>>>>>>>     End
259>>>>>>>>>>>>
259>>>>>>>>>>>     else If Context_Type eq HELP_CONTEXT_ID_OR_KEY Begin
262>>>>>>>>>>>        Get Help_ID to ID         // 1st try for a context integer ID.
263>>>>>>>>>>>        If ID eq 0 Begin          // If no ID check for a keyword.
265>>>>>>>>>>>           Get Help_Keyword to rVal
266>>>>>>>>>>>           if rVal eq '' Delegate Get Help_Context Context_Type to rVal
270>>>>>>>>>>>        End
270>>>>>>>>>>>>
270>>>>>>>>>>>        Else Move ID to rVal
272>>>>>>>>>>>     End
272>>>>>>>>>>>>
272>>>>>>>>>>>     else if Context_Type eq HELP_CONTEXT_DATAFILE Begin
275>>>>>>>>>>>        Get Help_DataFile to rVal
276>>>>>>>>>>>     End
276>>>>>>>>>>>>
276>>>>>>>>>>>
276>>>>>>>>>>>     Function_Return rVal
277>>>>>>>>>>>
277>>>>>>>>>>>   End_Function // Help_Context
278>>>>>>>>>>>
278>>>>>>>>>>>End_class // Help_Mixin
279>>>>>>>>>>>
279>>>>>>>>>>>
279>>>>>>>>>>>Class DataFile_Help_Mixin is a Mixin
280>>>>>>>>>>>
280>>>>>>>>>>>   Function Help_Datafile Returns string
281>>>>>>>>>>>      local integer file# field#
282>>>>>>>>>>>       Local String rVal
282>>>>>>>>>>>       Get Data_file item current to file#
283>>>>>>>>>>>       If file# ne 0 Begin
285>>>>>>>>>>>          Get Data_field item current to field#
286>>>>>>>>>>>          Move ( string(file#) - '.' - string(field#) ) to rVal
287>>>>>>>>>>>       end
287>>>>>>>>>>>>
287>>>>>>>>>>>       Function_return rVal
288>>>>>>>>>>>   End_Function // Help_Datafile
289>>>>>>>>>>>End_Class
290>>>>>>>>>>>
290>>>>>>>>>Use Modal_mx         // modal object support
INCLUDING FILE: MODAL_MX.PKG
290>>>>>>>>>>>// Modal_mx.pkg - Modal mixin pacakge support
290>>>>>>>>>>>//
290>>>>>>>>>>>// John Tuohy
290>>>>>>>>>>>// Data Access Corporation
290>>>>>>>>>>>//
290>>>>>>>>>>>// 02/01/96 - Created
290>>>>>>>>>>>// 11/14/97 JJT - Fixed problem where modal objects improperly inherit acc.
290>>>>>>>>>>>//                keys from parents. This no longer happens. Popup_state blocks
290>>>>>>>>>>>//                all parent inheritance. To override and get the old behavior
290>>>>>>>>>>>//                do following: Set Key_Path to (parent(Current_Object))
290>>>>>>>>>>>//
290>>>>>>>>>>>// Primary Interface:
290>>>>>>>>>>>//
290>>>>>>>>>>>// Get msg_Popup_Modal to Rval  - starts a modal popup, Returns UI stop
290>>>>>>>>>>>// Send popup_Modal               value. Can be used on any object (modal
290>>>>>>>>>>>//                                or modeless)
290>>>>>>>>>>>//
290>>>>>>>>>>>// Set Modal_State to T|F       - When true, an object becomes a modal
290>>>>>>>>>>>//                                popup object. This sets  TRUE  False
290>>>>>>>>>>>//                                    Block_mouse_State   = t      f
290>>>>>>>>>>>//                                    Attach_Parent_state = f      t
290>>>>>>>>>>>//                                    Ring_State          = t    nochange
290>>>>>>>>>>>//                                    Scope_State         = t    nochange
290>>>>>>>>>>>//                                    Popup_State         = t    nochange
290>>>>>>>>>>>//                                    Key_Pathe           = desktop 0  * (see msg)
290>>>>>>>>>>>//
290>>>>>>>>>>>// Send Stop_modal_UI           - Stops Current Level of Modal UI.
290>>>>>>>>>>>//                                Note: You should NOT use Stop_UI or
290>>>>>>>>>>>//                                      set stop_ui_state any more
290>>>>>>>>>>>//
290>>>>>>>>>>>// Private Augmentations and Changes
290>>>>>>>>>>>// ---------------------------------
290>>>>>>>>>>>// Global integer Current_modal_object - tracks current modal UI object
290>>>>>>>>>>>//
290>>>>>>>>>>>// Procedure remove_object - Augmented to stop UI if current modal object
290>>>>>>>>>>>//
290>>>>>>>>>>>// Procedure Create_Dialog - Augmented to track current_modal object and
290>>>>>>>>>>>//                           restore previous modal_object when done.
290>>>>>>>>>>>// Property Private_Stop_UI_State - internal, tracks if the current
290>>>>>>>>>>>//                           modal ui has been stopped
290>>>>>>>>>>>//
290>>>>>>>>>>>//
290>>>>>>>>>>>
290>>>>>>>>>>>// Global integer. Keeps track of current modal object if one
290>>>>>>>>>>>// exists. We made this global so that all objects may check this.
290>>>>>>>>>>>// It is possible to next modal objects but only one has the active
290>>>>>>>>>>>// focus at any one time.
290>>>>>>>>>>>
290>>>>>>>>>>>Integer Current_modal_Object
290>>>>>>>>>>>Move 0 to Current_modal_Object  // 0 = no object current modal object
291>>>>>>>>>>>
291>>>>>>>>>>>Class Modal_Mixin is a Mixin
292>>>>>>>>>>>
292>>>>>>>>>>>  Procedure Define_Modal_Mixin
293>>>>>>>>>>>     property integer private.stop_ui_state public false
294>>>>>>>>>>>     // This can only be used with the CD_Popup_Object command. If true
294>>>>>>>>>>>     // the command will destroy the object it created.
294>>>>>>>>>>>     Property Integer Destroy_Object_State   Public false
295>>>>>>>>>>>     Property Integer Exit_Application_Local_State public False
296>>>>>>>>>>>  End_Procedure // Define_Modal_Mixin
297>>>>>>>>>>>
297>>>>>>>>>>>  // Public Message: Get Msg_Popup_Modal to rval
297>>>>>>>>>>>  //                 Send Popup_Modal
297>>>>>>>>>>>  //
297>>>>>>>>>>>  //  Allows any object to be used as a modal popup object.
297>>>>>>>>>>>  //  This messages creates a modal object (Setting all properties as
297>>>>>>>>>>>  //  required), activates via ui_accept, restores all properties, and
297>>>>>>>>>>>  //  then returns the exit value.
297>>>>>>>>>>>  //
297>>>>>>>>>>>  Procedure Popup_Modal Returns Integer // force object to be modal and then pop it up!
298>>>>>>>>>>>     Local Integer OldBMS OldAPS OldPS OldRS OldSS OldEALS
299>>>>>>>>>>>     Local Integer rVal
299>>>>>>>>>>>     // If object is active we can't do anything. -1 means already active
299>>>>>>>>>>>     If (Active_State(Current_Object)) procedure_Return -1
302>>>>>>>>>>>
302>>>>>>>>>>>     // Remember all important modal property settings.
302>>>>>>>>>>>     Get Block_mouse_State            to OldBMS
303>>>>>>>>>>>     Get Attach_parent_State          to OldAPS
304>>>>>>>>>>>     Get Popup_State                  to OldPS
305>>>>>>>>>>>     Get Ring_State                   to OldRS
306>>>>>>>>>>>     Get Scope_State                  to OldSS
307>>>>>>>>>>>     Get Exit_Application_Local_State to OldEALS
308>>>>>>>>>>>
308>>>>>>>>>>>     Set Modal_State to True  // Set modal properties (can be augmented)
309>>>>>>>>>>>     Get Msg_Popup to rVal
310>>>>>>>>>>>     If rval Move -2 to rVal      // did not activate
313>>>>>>>>>>>     Else    Move StrMark to rVal // StrMark keeps track of UI value
315>>>>>>>>>>>                                  // if 0- a stop_ui, if >0, ret value
315>>>>>>>>>>>     Set Modal_State to False // Unset (in case of augmentation)
316>>>>>>>>>>>     // restore all expected properties
316>>>>>>>>>>>     Set Block_mouse_State   to OldBMS
317>>>>>>>>>>>     Set Attach_parent_State to OldAPS
318>>>>>>>>>>>     Set Popup_State         to OldPS
319>>>>>>>>>>>     Set Ring_State          to OldRS
320>>>>>>>>>>>     Set Scope_State         to OldSS
321>>>>>>>>>>>     Set Exit_Application_Local_State to OldEALS
322>>>>>>>>>>>     Procedure_Return rVal
323>>>>>>>>>>>  End_Procedure
324>>>>>>>>>>>
324>>>>>>>>>>>  // Public Message: Set Modal_State - T = Makes object Modal
324>>>>>>>>>>>  //                                   F = Make object nonModal
324>>>>>>>>>>>  //
324>>>>>>>>>>>  Procedure Set Modal_State integer Fg
325>>>>>>>>>>>     Set Block_mouse_state to fg
326>>>>>>>>>>>     Set Attach_parent_state to (not(fg))
327>>>>>>>>>>>     Set Exit_Application_Local_State to fg
328>>>>>>>>>>>     if fg begin
330>>>>>>>>>>>        set popup_state to true
331>>>>>>>>>>>        set ring_state to true
332>>>>>>>>>>>        set scope_state to true
333>>>>>>>>>>>     end
333>>>>>>>>>>>>
333>>>>>>>>>>>     // this will block parent accelorator keys in modal objects
333>>>>>>>>>>>     // by assigning the inheritance path directly to the desktop
333>>>>>>>>>>>     // thereby skipping all inherited keys. Only do this if Key_path
333>>>>>>>>>>>     // has not been tampered with (i.e. set by developer). If changed,
333>>>>>>>>>>>     // its up to developer to make this right
333>>>>>>>>>>>     // Note that 0 = no special path - use parent
333>>>>>>>>>>>     // To override and get the old behavior do the following in your object:
333>>>>>>>>>>>     //     Set Key_Path to (parent(Current_Object))
333>>>>>>>>>>>
333>>>>>>>>>>>     if (Fg and key_path(Current_Object)=0) ;  // if set to modal, and no special inheritance path        set Key_path to Desktop                // set to desktop (skipping all objects)
336>>>>>>>>>>>     Else if (not(Fg) and key_path(Current_Object)=desktop) ;  // if non modal and on desktop        set Key_path to 0                      // change to no special path
340>>>>>>>>>>>  End_Procedure
341>>>>>>>>>>>
341>>>>>>>>>>>  //  Public Message: Get Modal_State
341>>>>>>>>>>>  //
341>>>>>>>>>>>  Function Modal_state Returns integer
342>>>>>>>>>>>     function_return (block_mouse_state(Current_Object))
343>>>>>>>>>>>  End_Function // Modal_state
344>>>>>>>>>>>
344>>>>>>>>>>>  //  Public Message: This will stop the current modal UI if a modal UI level
344>>>>>>>>>>>  //  exists and it has not already been stopped.
344>>>>>>>>>>>  //  This is smarter than Stop_ui (which should dnot be used) because it can
344>>>>>>>>>>>  //  be sent multiple times and only the current UI is stopped.
344>>>>>>>>>>>  //
344>>>>>>>>>>>  Procedure Stop_Modal_UI
345>>>>>>>>>>>      If ( Current_Modal_Object AND ; // only if modal object exists           Private.stop_ui_state(Current_Modal_Object) ) Begin // and it needs stopping
347>>>>>>>>>>>             Send stop_ui
348>>>>>>>>>>>             set private.stop_ui_state of Current_Modal_Object to false
349>>>>>>>>>>>      End
349>>>>>>>>>>>>
349>>>>>>>>>>>  End_Procedure
350>>>>>>>>>>>
350>>>>>>>>>>>
350>>>>>>>>>>>
350>>>>>>>>>>>  // Private
350>>>>>>>>>>>  //
350>>>>>>>>>>>  Procedure create_dialog integer i1 integer i2
351>>>>>>>>>>>      Local Integer OldModalObj
352>>>>>>>>>>>      // by keeping track of the old modal object we can properly nest
352>>>>>>>>>>>      // modal popups
352>>>>>>>>>>>      Move Current_Modal_Object to OldModalObj
353>>>>>>>>>>>      Move Current_Object to Current_Modal_Object
354>>>>>>>>>>>      set private.stop_ui_state to true
355>>>>>>>>>>>      forward send create_dialog i1 i2 // will activate and start a new UI
357>>>>>>>>>>>
357>>>>>>>>>>>      // at this point the object may or may not be active. To handle
357>>>>>>>>>>>      // this, DF will send deactivate_group to get rid of it if it is
357>>>>>>>>>>>      // still active. It will send this after the procedure is complete.
357>>>>>>>>>>>      // We know that the UI is stopped!
357>>>>>>>>>>>
357>>>>>>>>>>>      set private.stop_ui_state to false // since UI is stopped. Shut this off
358>>>>>>>>>>>      Move OldModalObj to Current_Modal_Object // the prior modal level if any
359>>>>>>>>>>>  End_procedure
360>>>>>>>>>>>
360>>>>>>>>>>>  // Private
360>>>>>>>>>>>  //
360>>>>>>>>>>>  procedure remove_object
361>>>>>>>>>>>      forward send remove_object
363>>>>>>>>>>>      // If we are removing the current modal object we might need
363>>>>>>>>>>>      // to stop the UI as well.
363>>>>>>>>>>>      if Current_Modal_Object eq Current_Object ;         Send Stop_Modal_UI
366>>>>>>>>>>>  end_procedure
367>>>>>>>>>>>
367>>>>>>>>>>>End_Class
368>>>>>>>>>Use WinUser          // windows API support
INCLUDING FILE: WINUSER.PKG
368>>>>>>>>>>>
368>>>>>>>>>>>Use DFTypes.pkg     // DataFlex Types (structures)
368>>>>>>>>>>>
368>>>>>>>>>>>Handle EXTKEY
368>>>>>>>>>>>MOVE 16777216 TO extkey
369>>>>>>>>>>>
369>>>>>>>>>>>
369>>>>>>>>>>>External_Function AnsiToOem 'CharToOemA' User32.dll ;    Pointer lpszAnsi Pointer lpszOem Returns Integer
370>>>>>>>>>>>
370>>>>>>>>>>>External_Function AppendMenu "AppendMenuA" User32.dll ;    Handle hMenu Integer flags Integer NewItem STRING val Returns Integer
371>>>>>>>>>>>
371>>>>>>>>>>>External_Function ArrangeIcons "ArrangeIconicWindows" User32.dll ;    Handle hWnd Returns Integer
372>>>>>>>>>>>
372>>>>>>>>>>>External_Function BeginPaint "BeginPaint" User32.dll ;    Handle hWnd Pointer lpPS Returns Handle
373>>>>>>>>>>>
373>>>>>>>>>>>External_Function ClientToScreen "ClientToScreen" User32.dll ;    Handle hWnd Pointer lpsPoint Returns Integer
374>>>>>>>>>>>
374>>>>>>>>>>>External_Function CreatePopupMenu "CreatePopupMenu" User32.dll ;    Returns Handle
375>>>>>>>>>>>
375>>>>>>>>>>>//External_Function CreateWindowEx 'CreateWindowExA' User32.dll ;
375>>>>>>>>>>>//    DWORD exst Pointer clsn Pointer wnd DWORD wst DWORD px DWORD py DWORD width ;
375>>>>>>>>>>>//    DWORD height Handle hP Handle hm Handle hinst Pointer cstruct Returns Handle
375>>>>>>>>>>>
375>>>>>>>>>>>External_Function DrawText 'DrawTextA' User32.dll ;    Handle  hDC Pointer lpsz DWORD cb Pointer lprc DWORD fuFormat RETURNS Integer
376>>>>>>>>>>>
376>>>>>>>>>>>External_Function EnableMenuItem "EnableMenuItem" User32.dll ;    Handle hmenu Integer uitem Integer uFlags Returns Integer
377>>>>>>>>>>>
377>>>>>>>>>>>External_Function EndPaint "EndPaint" User32.dll ;    Handle hWnd Pointer lpPS Returns Handle
378>>>>>>>>>>>
378>>>>>>>>>>>External_Function FindWindow "FindWindowA" User32.dll ;    String sClassName String sCaption Returns Handle
379>>>>>>>>>>>
379>>>>>>>>>>>External_Function GetAsyncKeyState "GetAsyncKeyState" User32.dll ;    DWORD vkey Returns Integer
380>>>>>>>>>>>
380>>>>>>>>>>>External_Function GetClassLong "GetClassLongA" ;    User32.DLL Integer hWnd Integer Offset Returns Integer
381>>>>>>>>>>>
381>>>>>>>>>>>External_Function GetClientRect 'GetClientRect' User32.dll ;    Handle hwnd Pointer lprect Returns Integer
382>>>>>>>>>>>
382>>>>>>>>>>>External_Function GetCursorPos "GetCursorPos" User32.dll ;    Pointer lppoint Returns Integer
383>>>>>>>>>>>
383>>>>>>>>>>>External_Function GetDesktopWindow "GetDesktopWindow" User32.dll ;    Returns Handle
384>>>>>>>>>>>
384>>>>>>>>>>>External_Function GetDC "GetDC" User32.dll  ;    Handle hWnd  Returns Integer
385>>>>>>>>>>>
385>>>>>>>>>>>External_Function GetKeyboardState "GetKeyboardState" User32.dll ;    Pointer lpkeystate Returns Integer
386>>>>>>>>>>>
386>>>>>>>>>>>External_Function GetKeyState "GetKeyState" User32.dll ;    DWORD vkey Returns Integer
387>>>>>>>>>>>
387>>>>>>>>>>>External_Function GetSysColor "GetSysColor" User32.dll ;    DWORD nSysColor Returns DWORD
388>>>>>>>>>>>
388>>>>>>>>>>>External_Function GetWindowLong "GetWindowLongA" User32.dll ;    Integer hWnd Integer offset Returns Integer
389>>>>>>>>>>>
389>>>>>>>>>>>External_Function GetWindowPlacement "GetWindowPlacement" User32.dll ;    Handle hWnd Pointer lpsWndPl Returns Integer
390>>>>>>>>>>>
390>>>>>>>>>>>External_Function GetWindowRect 'GetWindowRect' User32.dll ;    Handle hwnd Pointer lprect Returns Integer
391>>>>>>>>>>>
391>>>>>>>>>>>External_Function GetWindow "GetWindow" User32.dll ;    Handle hWnd Integer fuRel Returns Handle
392>>>>>>>>>>>
392>>>>>>>>>>>External_Function GetWindowText "GetWindowTextA" User32.dll ;    Handle hWnd Pointer lpsText INTEGER cbText Returns Integer
393>>>>>>>>>>>
393>>>>>>>>>>>External_Function GetWindowWord "GetWindowWord" User32.dll ;    Handle hWnd DWORD  nOffset Returns Integer
394>>>>>>>>>>>
394>>>>>>>>>>>External_Function InitCommonControls "InitCommonControls" COMCTL32.DLL ;    Returns Integer
395>>>>>>>>>>>
395>>>>>>>>>>>External_Function InvalidateRect "InvalidateRect" User32.dll ;    Handle hWnd Pointer lpRect DWORD fReDraw Returns Integer
396>>>>>>>>>>>
396>>>>>>>>>>>External_Function IsClipboardFormatAvailable "IsClipboardFormatAvailable" User32.dll ;    DWord dwFormat Returns Integer
397>>>>>>>>>>>
397>>>>>>>>>>>External_Function LoadCursor "LoadCursorA" User32.DLL ;    Integer HANDLE Pointer ResourceID Returns Integer
398>>>>>>>>>>>
398>>>>>>>>>>>External_Function LoadResourceCursor "LoadCursorA" User32.DLL ;    HANDLE hModule STRING resid RETURNS HANDLE
399>>>>>>>>>>>
399>>>>>>>>>>>External_Function PostMessage 'PostMessageA' User32.dll ;    Handle hwnd Handle uMsg DWORD wParam DWORD lParam Returns Integer
400>>>>>>>>>>>
400>>>>>>>>>>>External_Function ReleaseDC "ReleaseDC" User32.dll  ;    Handle hWnd  Handle hDC  Returns Integer
401>>>>>>>>>>>
401>>>>>>>>>>>External_Function ScreenToClient 'ScreenToClient' User32.dll ;    Handle hwnd Pointer lppt Returns Integer
402>>>>>>>>>>>
402>>>>>>>>>>>External_Function SendMessage 'SendMessageA' User32.dll ;    Handle hwnd Handle uMsg DWORD wParam DWORD lParam Returns Integer
403>>>>>>>>>>>
403>>>>>>>>>>>External_Function SetCapture "SetCapture" User32.dll ;    Handle hWnd Returns Integer
404>>>>>>>>>>>
404>>>>>>>>>>>External_Function SetClassLong "SetClassLongA" User32.DLL ;    Integer hWnd Integer Offset Integer NewLong Returns Integer
405>>>>>>>>>>>
405>>>>>>>>>>>External_Function SetCursor "SetCursor" User32.DLL ;    Integer HANDLE Returns Integer
406>>>>>>>>>>>
406>>>>>>>>>>>External_Function SetFocus 'SetFocus' User32.dll ;    Handle hwnd Returns Integer
407>>>>>>>>>>>
407>>>>>>>>>>>External_Function SetForegroundWindow "SetForegroundWindow" User32.dll ;    Handle hWnd Returns Integer
408>>>>>>>>>>>
408>>>>>>>>>>>External_Function SetKeyboardState "SetKeyboardState" User32.dll ;    Pointer lpkeystate Returns Integer
409>>>>>>>>>>>
409>>>>>>>>>>>External_Function SetScrollPos 'SetScrollPos' User32.dll ;    Handle hWnd DWORD fnBar DWORD iPos DWORD fnReDraw Returns Integer
410>>>>>>>>>>>
410>>>>>>>>>>>External_Function SetScrollRange 'SetScrollRange' User32.dll ;    Handle hWnd DWORD fnBar DWORD iMin DWORD iMax DWORD fnReDraw Returns Integer
411>>>>>>>>>>>
411>>>>>>>>>>>External_Function SetWindowLong "SetWindowLongA" User32.dll ;    Handle hwnd Integer idx NUMBER wlong Returns Integer
412>>>>>>>>>>>
412>>>>>>>>>>>External_Function SetWindowPos "SetWindowPos" User32.dll ;    Handle hWnd Handle hWndAfter Integer x Integer y Integer cx Integer cy Integer uFlags Returns Integer
413>>>>>>>>>>>
413>>>>>>>>>>>External_Function SetWindowText "SetWindowTextA" User32.dll ;    Handle hWnd string sText Returns Integer
414>>>>>>>>>>>
414>>>>>>>>>>>External_Function ShowWindow 'ShowWindow' User32.dll ;    Handle hwnd DWORD flag Returns Integer
415>>>>>>>>>>>
415>>>>>>>>>>>External_Function TrackPopupMenu "TrackPopupMenu" User32.dll ;    Handle hmenu Integer flags Integer x Integer y Integer res Handle hWnd Pointer lprect Returns Integer
416>>>>>>>>>>>
416>>>>>>>>>>>External_Function WindowFromPoint "WindowFromPoint" User32.dll ;    DWORD ptx DWORD pty Returns Handle
417>>>>>>>>>>>
417>>>>>>>>>>>External_Function EnableWindow 'EnableWindow' User32.dll ;    Handle hWnd Integer bEnable Returns Integer
418>>>>>>>>>>>
418>>>>>>>>>>>External_Function UpdateWindow 'UpdateWindow' User32.dll Handle hWnd Returns DWORD
419>>>>>>>>>>>
419>>>>>>>>>>>External_Function OemToAnsi 'OemToCharA' User32.dll ;    Pointer lpszAnsi Pointer lpszOem Returns Integer
420>>>>>>>>>>>
420>>>>>>>>>>>External_Function GetSystemMetrics "GetSystemMetrics" User32.dll ;    Integer nIndex Returns Integer
421>>>>>>>>>>>
421>>>>>>>>>>>
421>>>>>>>>>>>Move (InitCommonControls()) To WindowIndex
422>>>>>>>>>>>
422>>>>>>>>>>>// SetWindowPos defaults
422>>>>>>>>>>>
422>>>>>>>>>>>//======= Get/SetWindowLong Constants ======================================
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//  WM_ACTIVATE state values
422>>>>>>>>>>>//
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>// Mouse-Key constants
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//====== COMMON CONTROL STYLES ================================================
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//*
422>>>>>>>>>>>// * ShowWindow() Commands
422>>>>>>>>>>>// */
422>>>>>>>>>>>
422>>>>>>>>>>>//*
422>>>>>>>>>>>// * Button Control Styles
422>>>>>>>>>>>// */
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//*
422>>>>>>>>>>>// * User Button Notification Codes
422>>>>>>>>>>>// */
422>>>>>>>>>>>
422>>>>>>>>>>>//*
422>>>>>>>>>>>// * Button Control Messages
422>>>>>>>>>>>// */
422>>>>>>>>>>>
422>>>>>>>>>>>//
422>>>>>>>>>>>// * Window Styles
422>>>>>>>>>>>// */
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//*
422>>>>>>>>>>>// * Common Window Styles
422>>>>>>>>>>> //*/
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//*
422>>>>>>>>>>>// * Extended Window Styles
422>>>>>>>>>>> //*/
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//*
422>>>>>>>>>>>// * Edit Control Styles
422>>>>>>>>>>>// */
422>>>>>>>>>>>
422>>>>>>>>>>>//*
422>>>>>>>>>>>// * Edit Control Notification Codes
422>>>>>>>>>>>//*/
422>>>>>>>>>>>
422>>>>>>>>>>>//*
422>>>>>>>>>>>// * Listbox Styles
422>>>>>>>>>>>// */
422>>>>>>>>>>>
422>>>>>>>>>>>// ;win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags */
422>>>>>>>>>>>//
422>>>>>>>>>>>// Menu flags for Add/Check/EnableMenuItem()
422>>>>>>>>>>>///
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//
422>>>>>>>>>>>// Flags for TrackPopupMenu
422>>>>>>>>>>>//
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//
422>>>>>>>>>>>// Combo Box return Values
422>>>>>>>>>>>//
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//
422>>>>>>>>>>>// Combo Box Notification Codes
422>>>>>>>>>>>//
422>>>>>>>>>>>
422>>>>>>>>>>>//
422>>>>>>>>>>>// Combo Box styles
422>>>>>>>>>>>//
422>>>>>>>>>>>
422>>>>>>>>>>>//
422>>>>>>>>>>>// Combo Box messages
422>>>>>>>>>>>//
422>>>>>>>>>>>
422>>>>>>>>>>>//
422>>>>>>>>>>>// Edit Control Messages
422>>>>>>>>>>>//
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//
422>>>>>>>>>>>// Listbox messages
422>>>>>>>>>>>//
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>// virtual key codes (from winuser.h)
422>>>>>>>>>>>// We recommend that virtual keys are used. The VK set is much more complete.
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>// VK_0 thru VK_9 are the same as ASCII '0' thru '9' (|CI$30 - |CI$39)
422>>>>>>>>>>>// VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (|CI$41 - |CI$5A)
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//
422>>>>>>>>>>>//  VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
422>>>>>>>>>>>//  Used only as parameters to GetAsyncKeyState() and GetKeyState().
422>>>>>>>>>>>//  No other API or message will distinguish left and right keys in this way.
422>>>>>>>>>>>//
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//
422>>>>>>>>>>>// Support for Windows System Colors (GetSysColor etc)
422>>>>>>>>>>>//
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>Type Type_POINT
422>>>>>>>>>>>  Field Type_Point_x as DWORD
422>>>>>>>>>>>  Field Type_Point_y as DWORD
422>>>>>>>>>>>End_Type
422>>>>>>>>>>>
422>>>>>>>>>>>//*** The constants used as parameter to the system metrics function
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>
422>>>>>>>>>>>//GetWindow() Symbols
422>>>>>>>>>>>
422>>>>>>>>>>>// Clipboard Formats
422>>>>>>>>>Use WinKern
INCLUDING FILE: WINKERN.PKG
422>>>>>>>>>>>//************************************************************************
422>>>>>>>>>>>//--- WinKern.pkg   Symbolic Constants
422>>>>>>>>>>>//
422>>>>>>>>>>>// Copyright (c) 1983-1997 Data Access Corporation, Miami Florida,
422>>>>>>>>>>>// All rights reserved.
422>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
422>>>>>>>>>>>//
422>>>>>>>>>>>//************************************************************************
422>>>>>>>>>>>//  Description:
422>>>>>>>>>>>//      Windows' Kernel32 API Functions, Declarations & Constants
422>>>>>>>>>>>//
422>>>>>>>>>>>//  Author: Stuart W. Booth
422>>>>>>>>>>>//************************************************************************
422>>>>>>>>>>>
422>>>>>>>>>>>External_Function CopyMemory "RtlMoveMemory" Kernel32.dll ;    POINTER psDest POINTER psSource DWORD cChars Returns VOID_TYPE
423>>>>>>>>>>>
423>>>>>>>>>>>External_Function FreeLibrary "FreeLibrary" Kernel32.dll ;    Integer hInstLib returns VOID_TYPE
424>>>>>>>>>>>
424>>>>>>>>>>>External_Function GetFullPathName "GetFullPathNameA" Kernel32.dll ;    String sFileName DWord nBufferLength Pointer lpBuffer Pointer lpFilePart Returns Integer
425>>>>>>>>>>>
425>>>>>>>>>>>External_Function LoadLibrary "LoadLibraryA" Kernel32.dll ;    String sFileName returns Integer
426>>>>>>>>>>>
426>>>>>>>>>>>
426>>>>>>>>>>>External_Function GetModuleHandle "GetModuleHandleA" Kernel32.dll ;    Pointer modname Returns Handle
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>Use CommCtrl
INCLUDING FILE: COMMCTRL.PKG
427>>>>>>>>>>>//************************************************************************
427>>>>>>>>>>>// CommCtrl.PKG
427>>>>>>>>>>>//
427>>>>>>>>>>>// Copyright (c) 1983-1997 Data Access Corporation, Miami Florida,
427>>>>>>>>>>>// All rights reserved.
427>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
427>>>>>>>>>>>//
427>>>>>>>>>>>//************************************************************************
427>>>>>>>>>>>//  Description:
427>>>>>>>>>>>//      Symbols required to support the Windows' Common Controls that are
427>>>>>>>>>>>//      defined in package-files.
427>>>>>>>>>>>//
427>>>>>>>>>>>//  Author: Stuart W. Booth
427>>>>>>>>>>>//************************************************************************
427>>>>>>>>>>>Use windows
427>>>>>>>>>>>Use WinUser
427>>>>>>>>>>>Use DLL
427>>>>>>>>>>>
427>>>>>>>>>>>//*** STATUS BAR SUPPORT ***
427>>>>>>>>>>>//==========================
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>//*** TRACK-BAR SUPPORT *** (DFSlider)
427>>>>>>>>>>>//=========================
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>//*** PROGRESS-BAR SUPPORT ***
427>>>>>>>>>>>//============================
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>//*** SPIN-BUTTON SUPPORT ***
427>>>>>>>>>>>//===========================
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>//*** TAB-CONTROL SUPPORT ***
427>>>>>>>>>>>//===========================
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>//====== TREEVIEW CONTROL =====================================================
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>
427>>>>>>>>>>>// Tool-Tips
427>>>>>>>>>>>
427>>>>>>>>>>>// Generic Notification codes
427>>>>>>>>>>>
427>>>>>>>>>>>//=== ToolBar support ===
427>>>>>>>>>Use Autolcmx         // Auto-locate override logic for windows
INCLUDING FILE: AUTOLCMX.PKG
427>>>>>>>>>>>//************************************************************************
427>>>>>>>>>>>//
427>>>>>>>>>>>// Confidential Trade Secret.
427>>>>>>>>>>>// Copyright (c) 1993 2E Software, La Mesa California,
427>>>>>>>>>>>// as an unpublished work.  All rights reserved.
427>>>>>>>>>>>// Portions copyright (c) 1997 Data Access Corporation, Miami Florida
427>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
427>>>>>>>>>>>//
427>>>>>>>>>>>//************************************************************************/
427>>>>>>>>>>>
427>>>>>>>>>>>//************************************************************************
427>>>>>>>>>>>// Autolcmx.Pkg
427>>>>>>>>>>>// Version: 1.0
427>>>>>>>>>>>// Copyright (c) 1993 2E Software
427>>>>>>>>>>>//  05-17-1993 : Created
427>>>>>>>>>>>//
427>>>>>>>>>>>// Author: John J. Tuohy
427>>>>>>>>>>>//
427>>>>>>>>>>>//************************************************************************
427>>>>>>>>>>>//
427>>>>>>>>>>>// This replaces the character based auto_locate message with a GUI
427>>>>>>>>>>>// version. This is only added to DEO clients (since in windaf we only
427>>>>>>>>>>>// auto-locate containers.
427>>>>>>>>>>>//************************************************************************
427>>>>>>>>>>>// 04/29/96 JJT - Use GUIScreen_Size global function to get screen size
427>>>>>>>>>>>//************************************************************************
427>>>>>>>>>>>
427>>>>>>>>>>>Enumeration_list
427>>>>>>>>>>>  Define   NO_LOCATE
427>>>>>>>>>>>  Define   SMART_LOCATE
427>>>>>>>>>>>  Define   POPUP_LOCATE
427>>>>>>>>>>>  Define   CENTER_ON_SCREEN
427>>>>>>>>>>>  Define   CENTER_ON_PANEL
427>>>>>>>>>>>  Define   CENTER_ON_PARENT
427>>>>>>>>>>>End_Enumeration_List
427>>>>>>>>>>>
427>>>>>>>>>>>Function Main_Panel_ID for DFDesktop Returns Integer
428>>>>>>>>>>>  Function_Return 0
429>>>>>>>>>>>End_Function
430>>>>>>>>>>>
430>>>>>>>>>>>// character mode sel-list and enclient call this...does nothing
430>>>>>>>>>>>Class Auto_Locate_Mixin is a Mixin
431>>>>>>>>>>>  Procedure Define_Auto_Locate
432>>>>>>>>>>>  End_procedure
433>>>>>>>>>>>End_Class
434>>>>>>>>>>>
434>>>>>>>>>>>Class dfAuto_Locate_Mixin is a Mixin
435>>>>>>>>>>>
435>>>>>>>>>>>  Procedure Define_dfAuto_Locate
436>>>>>>>>>>>    //Property Integer Auto_Locate_state Public FALSE
436>>>>>>>>>>>    Property Integer Row_Offset     Public 1  // down 1
437>>>>>>>>>>>    Property Integer Column_Offset  Public 2  // right 2
438>>>>>>>>>>>    Property Integer Locate_Mode    Public NO_LOCATE
439>>>>>>>>>>>  End_Procedure
440>>>>>>>>>>>
440>>>>>>>>>>>  Procedure Set Auto_Locate_State integer iState
441>>>>>>>>>>>     If iState ;        Set Locate_Mode to POPUP_LOCATE
444>>>>>>>>>>>     Else ;        if (Locate_Mode(Current_Object)=POPUP_LOCATE) ;           Set Locate_Mode to NO_LOCATE
448>>>>>>>>>>>  End_Procedure
449>>>>>>>>>>>
449>>>>>>>>>>>  Function Auto_Locate_State Returns integer
450>>>>>>>>>>>     Function_Return (Locate_Mode(Current_Object)=POPUP_LOCATE)
451>>>>>>>>>>>  End_Function // Auto_Locate_State
452>>>>>>>>>>>
452>>>>>>>>>>>  Procedure Set Offset_Location integer Row# Integer Col#
453>>>>>>>>>>>     Set Row_Offset    to Row#
454>>>>>>>>>>>     Set Column_Offset to Col#
455>>>>>>>>>>>  End_Procedure // Set Offset_Location
456>>>>>>>>>>>
456>>>>>>>>>>>  // Procedure Auto_Locate
456>>>>>>>>>>>  //
456>>>>>>>>>>>  Procedure Auto_Locate Integer Invoking_Obj#
457>>>>>>>>>>>    Local Integer BC loc gHt gWd gRow gCol sHt sWd pSize
458>>>>>>>>>>>    Local integer screensz
458>>>>>>>>>>>    If Invoking_Obj# gt desktop Begin
460>>>>>>>>>>>       Get Absolute_GUIOrigin of Invoking_Obj# to Loc  // location of inv obj
461>>>>>>>>>>>       Move (Hi(Loc)) to gRow                         // row
462>>>>>>>>>>>       Move (Low(Loc)) to gCol                        // col
463>>>>>>>>>>>       If gCol gt 32767 Move (gCol - 65536 ) to gCol
466>>>>>>>>>>>       If gRow gt 32767 Move (gRow - 65536 ) to gRow
469>>>>>>>>>>>       //
469>>>>>>>>>>>       Get Physical_fontSize to pSize // size of the font
470>>>>>>>>>>>       Add (Row_offset(Current_Object) * (Hi(Psize)+4) ) to gRow
471>>>>>>>>>>>       Add (Column_offset(Current_Object) * (Low(Psize)+4) ) to gCol
472>>>>>>>>>>>       //
472>>>>>>>>>>>       Get GUISize to Loc
473>>>>>>>>>>>       Move (Hi(Loc))  to gHt
474>>>>>>>>>>>       Move (Low(Loc)) to gWd
475>>>>>>>>>>>       //
475>>>>>>>>>>>       Get GuiScreen_size to ScreenSz
476>>>>>>>>>>>       Move (Hi(ScreenSz))  to sHt
477>>>>>>>>>>>       Move (Low(ScreenSz)) to sWd
478>>>>>>>>>>>       // we use 2 a a pixel fudge factor...looks better
478>>>>>>>>>>>       If (gRow+gHt) gt sHt Move (sHt - gHt - 2 ) to gRow
481>>>>>>>>>>>       If (gCol+gWd) gt sWd Move (sWd - gWd - 2 ) to gCol
484>>>>>>>>>>>       If gCol lt 0 Move 2 to gCol
487>>>>>>>>>>>       If gRow lt 0 Move 2 to gRow
490>>>>>>>>>>>       Set GuiLocation to gRow gCol
491>>>>>>>>>>>       Send Adjust_Logicals
492>>>>>>>>>>>    End
492>>>>>>>>>>>>
492>>>>>>>>>>>  End_Procedure
493>>>>>>>>>>>
493>>>>>>>>>>>  //
493>>>>>>>>>>>  //  Locate Panel on Screen/df desktop/current panel
493>>>>>>>>>>>  //
493>>>>>>>>>>>  Procedure Locate_Panel
494>>>>>>>>>>>     Local integer Siz Loc obj#
495>>>>>>>>>>>     Local integer sHt sWd sRow sCol
495>>>>>>>>>>>     Local integer ht Wd Row Col
495>>>>>>>>>>>     Local integer screensz
495>>>>>>>>>>>     Local Integer LocMode Foc
495>>>>>>>>>>>     Get Locate_Mode to LocMode
496>>>>>>>>>>>     Get Focus to Foc
497>>>>>>>>>>>
497>>>>>>>>>>>     If LocMode eq SMART_LOCATE Begin
499>>>>>>>>>>>        If (Modal_State(Current_Object) AND Foc>Desktop AND Foc<>Current_Object) ;           Move POPUP_LOCATE to LocMode
502>>>>>>>>>>>        Else If (GUILocation(Current_Object)<>0) ;           Procedure_Return
506>>>>>>>>>>>        Else Begin
507>>>>>>>>>>>           Delegate Get Main_Panel_Id to Obj#
509>>>>>>>>>>>           If Obj# GT Desktop Move CENTER_ON_PANEL to LocMode
512>>>>>>>>>>>           Else Move CENTER_ON_SCREEN to LocMode
514>>>>>>>>>>>        End
514>>>>>>>>>>>>
514>>>>>>>>>>>     End
514>>>>>>>>>>>>
514>>>>>>>>>>>
514>>>>>>>>>>>     If LocMode eq POPUP_LOCATE Begin
516>>>>>>>>>>>        If (Foc>Desktop AND Foc<>Current_Object);           Send Auto_Locate Foc
519>>>>>>>>>>>        Procedure_Return
520>>>>>>>>>>>     End
520>>>>>>>>>>>>
520>>>>>>>>>>>     //
520>>>>>>>>>>>     Get GuiScreen_Size to screensz
521>>>>>>>>>>>
521>>>>>>>>>>>     If LocMode eq CENTER_ON_SCREEN Begin
523>>>>>>>>>>>        Move 0 to Loc
524>>>>>>>>>>>        Move ScreenSz to Siz
525>>>>>>>>>>>     End
525>>>>>>>>>>>>
525>>>>>>>>>>>     Else if LocMode eq CENTER_ON_PANEL Begin
528>>>>>>>>>>>        Delegate Get Main_Panel_ID to Obj#
530>>>>>>>>>>>        Get Absolute_GUIOrigin of Obj# to Loc
531>>>>>>>>>>>        Get Client_Size of Obj# to Siz
532>>>>>>>>>>>     End
532>>>>>>>>>>>>
532>>>>>>>>>>>     Else Begin // else delegate
533>>>>>>>>>>>        Delegate Get Absolute_GUIOrigin to Loc
535>>>>>>>>>>>        Delegate Get Client_Size to Siz
537>>>>>>>>>>>     End
537>>>>>>>>>>>>
537>>>>>>>>>>>     Move ( hi(Loc))  to sRow
538>>>>>>>>>>>     Move (Low(Loc))  to sCol
539>>>>>>>>>>>     If sCol gt 32767 Move (sCol - 65536 ) to sCol
542>>>>>>>>>>>     If sRow gt 32767 Move (sRow - 65536 ) to sRow
545>>>>>>>>>>>     //
545>>>>>>>>>>>     Move ( hi(Siz))  to sHt
546>>>>>>>>>>>     Move (low(Siz))  to sWd
547>>>>>>>>>>>     //
547>>>>>>>>>>>     Get GUISize to Siz
548>>>>>>>>>>>     Move (hi(Siz))   to Ht
549>>>>>>>>>>>     Move (low(Siz))  to Wd
550>>>>>>>>>>>     Move ( (sHt - Ht)/2 + sRow) to Row
551>>>>>>>>>>>     Move ( (sWd - Wd)/2 + sCol) to Col
552>>>>>>>>>>>     //
552>>>>>>>>>>>     // we use 2 a a pixel fudge factor...looks better
552>>>>>>>>>>>     Move ( Hi(ScreenSz)) to sHt
553>>>>>>>>>>>     Move (Low(ScreenSz)) to sWd
554>>>>>>>>>>>     //
554>>>>>>>>>>>     If (Row+Ht>sHt) Move (sHt - Ht - 2 ) to Row
557>>>>>>>>>>>     If (Col+Wd>sWd) Move (sWd - Wd - 2 ) to Col
560>>>>>>>>>>>     If Col lt 0 Move 2 to Col
563>>>>>>>>>>>     If Row lt 0 Move 2 to Row
566>>>>>>>>>>>     Set GuiLocation to Row Col
567>>>>>>>>>>>     Send Adjust_Logicals
568>>>>>>>>>>>  End_Procedure
569>>>>>>>>>>>
569>>>>>>>>>>>  Procedure Page_Object Integer iState
570>>>>>>>>>>>      Local integer Mode
571>>>>>>>>>>>      If ( iState AND Locate_Mode(Current_Object)<>NO_LOCATE ) ;         Send Locate_Panel
574>>>>>>>>>>>      Forward Send Page_Object iState
576>>>>>>>>>>>  End_Procedure
577>>>>>>>>>>>
577>>>>>>>>>>>End_Class
578>>>>>>>>>>>
578>>>>>>>>>Use StHlp_mx         // Status help mixin
INCLUDING FILE: STHLP_MX.PKG
578>>>>>>>>>>>Class StatusHelp_Item_mixin is a Mixin
579>>>>>>>>>>>
579>>>>>>>>>>>    Procedure Define_StatusHelp_Item_Mixin
580>>>>>>>>>>>        Property Integer StatusHelp_Id  public 0
581>>>>>>>>>>>        Property Integer Simple_Status_Help_State Public 1
582>>>>>>>>>>>        Property String  Shadow_Status_Help Public ' (unavailable)'
583>>>>>>>>>>>        Object Statushelp_Array is an array
585>>>>>>>>>>>            delegate Set StatusHelp_Id to Current_Object
587>>>>>>>>>>>        end_object
588>>>>>>>>>>>    End_Procedure // Define_StatusHelp_Item_Mixin
589>>>>>>>>>>>
589>>>>>>>>>>>   Procedure Xdelete_data
590>>>>>>>>>>>      Local integer id
591>>>>>>>>>>>      get statushelp_id to id
592>>>>>>>>>>>      Forward Send delete_data
594>>>>>>>>>>>      if id Send Delete_Data to id
597>>>>>>>>>>>   End_Procedure // Delete_Data
598>>>>>>>>>>>
598>>>>>>>>>>>   Procedure Add_item integer msg# string sval
599>>>>>>>>>>>//ShowLn 'Add_Item: obj= ' (Name(current_object)) ' msg= ' msg# ' val>' sVal '<'
599>>>>>>>>>>>     Local integer id
600>>>>>>>>>>>     get statushelp_id to id
601>>>>>>>>>>>     Forward Send Add_item msg# sval
603>>>>>>>>>>>     If id send Add_Item to id 0 ''
606>>>>>>>>>>>   End_Procedure // Add_item
607>>>>>>>>>>>
607>>>>>>>>>>>   Procedure Insert_item integer msg# string sval integer item#
608>>>>>>>>>>>//ShowLn 'Insert_Item: obj= ' (Name(current_object)) ' msg= ' msg# ' val>' sVal '< item= ' item#
608>>>>>>>>>>>     Local integer id
609>>>>>>>>>>>     get statushelp_id to id
610>>>>>>>>>>>     Forward Send Insert_item msg# sval item#
612>>>>>>>>>>>     If id send Insert_Item to id item# ''
615>>>>>>>>>>>   End_Procedure // Insert_item
616>>>>>>>>>>>
616>>>>>>>>>>>   Procedure XDelete_Item integer Item#
617>>>>>>>>>>>//ShowLn 'Delete_Item: obj= ' (Name(current_object)) ' item= ' item#
617>>>>>>>>>>>     Local integer id
618>>>>>>>>>>>     get statushelp_id to id
619>>>>>>>>>>>     Forward Send Delete_Item Item#
621>>>>>>>>>>>     If id send Delete_Item to id item#
624>>>>>>>>>>>   end_Procedure // Delete_Item
625>>>>>>>>>>>
625>>>>>>>>>>>   Procedure Set Status_Help string item# string sval
626>>>>>>>>>>>     Local integer id itm#
627>>>>>>>>>>>     Local string stval
627>>>>>>>>>>>     If num_arguments eq 1 Begin
629>>>>>>>>>>>        Move Item# to stval
630>>>>>>>>>>>        Move (item_count(Current_Object)-1) to itm#
631>>>>>>>>>>>     end
631>>>>>>>>>>>>
631>>>>>>>>>>>     else begin
632>>>>>>>>>>>        Move sVal to stval
633>>>>>>>>>>>        Move item# to itm#
634>>>>>>>>>>>     end
634>>>>>>>>>>>>
634>>>>>>>>>>>     get statushelp_id to id
635>>>>>>>>>>>     if id Set Value of id item itm# to stVal
638>>>>>>>>>>>   end_procedure
639>>>>>>>>>>>
639>>>>>>>>>>>   Function Status_Help integer item# returns string
640>>>>>>>>>>>     Local integer id
641>>>>>>>>>>>     Local string sHelp
641>>>>>>>>>>>     get statushelp_id to id
642>>>>>>>>>>>     if (id AND Item_Count(id)>Item#) Begin
644>>>>>>>>>>>        Get value of id item item# to sHelp
645>>>>>>>>>>>        if sHelp eq '0' move '' to shelp
648>>>>>>>>>>>     end
648>>>>>>>>>>>>
648>>>>>>>>>>>     function_return shelp
649>>>>>>>>>>>   End_Function // StatusHelp_Value
650>>>>>>>>>>>
650>>>>>>>>>>>   Function Menu_Status_Help Integer Item# Integer Flags Returns String
651>>>>>>>>>>>        Local String sStatus_Help sFlags sShadowed
652>>>>>>>>>>>
652>>>>>>>>>>>        //if (Flags IAND 3)      Append sFlags ' [Shad]'
652>>>>>>>>>>>        //if (Flags IAND 8)      Append sFlags ' [Tick]'
652>>>>>>>>>>>        //if (Flags IAND 256)    Append sFlags ' [256]'
652>>>>>>>>>>>        //if (Flags IAND 512)    Append sFlags ' [512]'
652>>>>>>>>>>>        //if (Flags IAND 1024)   Append sFlags ' [1024]'
652>>>>>>>>>>>        //if (Flags IAND 2048)   Append sFlags ' [Sep]'
652>>>>>>>>>>>        //if (Flags IAND 4096)   Append sFlags ' [4096]'
652>>>>>>>>>>>        //if (Flags IAND 8192)   Append sFlags ' [8192]'
652>>>>>>>>>>>        //if (Flags IAND 16384)  Append sFlags ' [16384]'
652>>>>>>>>>>>        //if (Flags IAND 32768)  Append sFlags ' [Mouse]'
652>>>>>>>>>>>
652>>>>>>>>>>>        Get Status_Help item# To sStatus_Help
653>>>>>>>>>>>        If ( sStatus_Help<>'' AND (Flags IAND 3) AND (not(Flags IAND 2048)) ) Begin
655>>>>>>>>>>>            Get Shadow_Status_Help To sShadowed
656>>>>>>>>>>>            Append sStatus_Help sShadowed
657>>>>>>>>>>>        End
657>>>>>>>>>>>>
657>>>>>>>>>>>        Function_Return sStatus_Help
658>>>>>>>>>>>    End_Function
659>>>>>>>>>>>
659>>>>>>>>>>>End_Class
660>>>>>>>>>Use DfltClr          // Grid color support
INCLUDING FILE: DFLTCLR.PKG
660>>>>>>>>>>>//************************************************************************
660>>>>>>>>>>>// Confidential Trade Secret.
660>>>>>>>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
660>>>>>>>>>>>// as an unpublished work.  All rights reserved.
660>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
660>>>>>>>>>>>//
660>>>>>>>>>>>//************************************************************************
660>>>>>>>>>>>//************************************************************************
660>>>>>>>>>>>//
660>>>>>>>>>>>// $File name  : DfltClr.pkg
660>>>>>>>>>>>// $File title : Set up default colors in VDF
660>>>>>>>>>>>// Notice      :
660>>>>>>>>>>>// $Author(s)  : John Tuohy
660>>>>>>>>>>>//
660>>>>>>>>>>>// $Rev History
660>>>>>>>>>>>//
660>>>>>>>>>>>// JT 3/25/99    VDF6 - made defaults the same as we use in install. In VDF6 we
660>>>>>>>>>>>//               will not add these values to the registry and in the future we will
660>>>>>>>>>>>//               remove this color setting completely.
660>>>>>>>>>>>// JT 02/06/98   Added support for clXXXXX name constants in registry
660>>>>>>>>>>>// JT  6/30/97   Added support for workspaces. Message DoSetDefaultColors
660>>>>>>>>>>>//               now sets the colors. This can be called at any time (like
660>>>>>>>>>>>//               after selecting a workspace.
660>>>>>>>>>>>// JT ??/??/??   File created for VDF 4.0
660>>>>>>>>>>>//************************************************************************
660>>>>>>>>>>>//
660>>>>>>>>>>>//  Set Application Default colors for lists
660>>>>>>>>>>>//
660>>>>>>>>>>>
660>>>>>>>>>>>Use dfgsini.pkg
INCLUDING FILE: DFGSINI.PKG
660>>>>>>>>>>>>>//************************************************************************
660>>>>>>>>>>>>>// Confidential Trade Secret.
660>>>>>>>>>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
660>>>>>>>>>>>>>// as an unpublished work.  All rights reserved.
660>>>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
660>>>>>>>>>>>>>//
660>>>>>>>>>>>>>//************************************************************************
660>>>>>>>>>>>>>//***************************************************************************
660>>>>>>>>>>>>>// DFGSINI.pkg - GET SET ini variables
660>>>>>>>>>>>>>//
660>>>>>>>>>>>>>//
660>>>>>>>>>>>>>// Create two GLOBAL messages to set and get system profile strings
660>>>>>>>>>>>>>//
660>>>>>>>>>>>>>// Get System_Profile_String
660>>>>>>>>>>>>>// Set System_Profile_String
660>>>>>>>>>>>>>//
660>>>>>>>>>>>>>// These require us to set a global string:
660>>>>>>>>>>>>>//   DAF_INI_SECTION_NAME
660>>>>>>>>>>>>>//
660>>>>>>>>>>>>>// This is done to place all commands to get and set profile strings in a
660>>>>>>>>>>>>>// single location. If the app is workspace aware these messages have been
660>>>>>>>>>>>>>// extended to re-direct to the workspace object (which is the desired way
660>>>>>>>>>>>>>// to use this).
660>>>>>>>>>>>>>
660>>>>>>>>>>>>>//***************************************************************************
660>>>>>>>>>>>>>// 10/14/97 JJT - added get/set system_profile_Dword messages (global)
660>>>>>>>>>>>>>// 06/26/97 JJT - added workspace object awareness
660>>>>>>>>>>>>>// 02/15/95 JJT - Added to allow for more flexible .ini usage. There
660>>>>>>>>>>>>>//                is no way to know the name of the current ini and current
660>>>>>>>>>>>>>//                section from within the program. Hopefully this will change.
660>>>>>>>>>>>>>//                Until then we will use global variables (which the developer
660>>>>>>>>>>>>>//                can change) to allow for full flexibility.
660>>>>>>>>>>>>>// 02/14/95 JJT - created
660>>>>>>>>>>>>>//
660>>>>>>>>>>>>>
660>>>>>>>>>>>>>
660>>>>>>>>>>>>>String DAF_INI_SECTION_NAME   40
660>>>>>>>>>>>>>
660>>>>>>>>>>>>>
660>>>>>>>>>>>>>// Ideally this should be looking in the [appname] section of dfwin.ini.
660>>>>>>>>>>>>>// The problem is, we don't know what that name is. It is most likely
660>>>>>>>>>>>>>// the .flx name - but not always (FLX=). This is the best we can do
660>>>>>>>>>>>>>// for now.
660>>>>>>>>>>>>>Get Module_Name to DAF_INI_SECTION_NAME
661>>>>>>>>>>>>>
661>>>>>>>>>>>>>// These must be defined (or registered) even if the WS
661>>>>>>>>>>>>>// object is not going to be used.
661>>>>>>>>>>>>>integer ghoWorkSpace
661>>>>>>>>>>>>>Move 0 to ghoWorkSpace
662>>>>>>>>>>>>>Register_function CurrentWorkSpaceName returns String
662>>>>>>>>>>>>>Register_function ProfileString string sTag returns string
662>>>>>>>>>>>>>Register_procedure set ProfileString string sTag string sValue
662>>>>>>>>>>>>>Register_function ProfileDWord string sTag returns DWord
662>>>>>>>>>>>>>Register_procedure set ProfileDWord string sTag DWord dwValue
662>>>>>>>>>>>>>
662>>>>>>>>>>>>>// Read and write program profile string to the registry. If
662>>>>>>>>>>>>>// this application is workspace aware it will do this by directing
662>>>>>>>>>>>>>// the messages to the workspace object.
662>>>>>>>>>>>>>//
662>>>>>>>>>>>>>
662>>>>>>>>>>>>>Function System_Profile_String GLOBAL String sTag returns String
663>>>>>>>>>>>>>    Local  String sValue sModName sWSName sSection
664>>>>>>>>>>>>>    If (ghoWorkSpace AND CurrentWorkSpaceName(ghoWorkSpace)<>"");        Get ProfileString of ghoWorkSpace sTag to sValue
667>>>>>>>>>>>>>    Else ;        Get_Profile_String DAF_Ini_Section_Name sTag to sValue
671>>>>>>>>>>>>>    Function_return sValue
672>>>>>>>>>>>>>End_Function // System_Profile_String
673>>>>>>>>>>>>>
673>>>>>>>>>>>>>Procedure SET System_Profile_String GLOBAL string sTag String sValue
674>>>>>>>>>>>>>    Move (trim(sTag)) to sTag
675>>>>>>>>>>>>>    If (ghoWorkSpace AND CurrentWorkSpaceName(ghoWorkSpace)<>"");        Set ProfileString of ghoWorkSpace sTag to sValue
678>>>>>>>>>>>>>    Else ;        Set_Profile_String DAF_Ini_Section_Name sTag sValue
682>>>>>>>>>>>>>End_Procedure // Set System_Profile_String
683>>>>>>>>>>>>>
683>>>>>>>>>>>>>Function System_Profile_DWord GLOBAL String sTag returns dWord
684>>>>>>>>>>>>>    Local  String sValue sModName sWSName sSection
685>>>>>>>>>>>>>    Local DWord dwValue
685>>>>>>>>>>>>>    If (ghoWorkSpace AND CurrentWorkSpaceName(ghoWorkSpace)<>"");        Get ProfileDWord of ghoWorkSpace sTag to dwValue
688>>>>>>>>>>>>>    Else ;        Get Profile_DWord DAF_Ini_Section_Name sTag to dwValue
690>>>>>>>>>>>>>    Function_return dwValue
691>>>>>>>>>>>>>End_Function // System_Profile_DWord
692>>>>>>>>>>>>>
692>>>>>>>>>>>>>Procedure SET System_Profile_DWord GLOBAL string sTag DWord dwValue
693>>>>>>>>>>>>>    Move (trim(sTag)) to sTag
694>>>>>>>>>>>>>    If (ghoWorkSpace AND CurrentWorkSpaceName(ghoWorkSpace)<>"");        Set ProfileDWord of ghoWorkSpace sTag to dwValue
697>>>>>>>>>>>>>    Else ;        Set Profile_DWord DAF_Ini_Section_Name sTag to dwValue
699>>>>>>>>>>>>>End_Procedure // Set System_Profile_dWord
700>>>>>>>>>>>Use Rgb.pkg
INCLUDING FILE: RGB.PKG
700>>>>>>>>>>>>>//************************************************************************
700>>>>>>>>>>>>>//--- RGB.pkg
700>>>>>>>>>>>>>//
700>>>>>>>>>>>>>// Copyright (c) 1983-1997 Data Access Corporation, Miami Florida,
700>>>>>>>>>>>>>// All rights reserved.
700>>>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
700>>>>>>>>>>>>>//
700>>>>>>>>>>>>>//************************************************************************
700>>>>>>>>>>>>>//  Description:
700>>>>>>>>>>>>>//      Provide basic functions and symbols required to use Windows'
700>>>>>>>>>>>>>//      RGB colors.
700>>>>>>>>>>>>>//
700>>>>>>>>>>>>>//  Author: Stuart W. Booth
700>>>>>>>>>>>>>//************************************************************************
700>>>>>>>>>>>>>// 02/06/98 JJT - changed system colors "clxxxx" to standard windows
700>>>>>>>>>>>>>//                system colors with highest bit set ($800000xx). Used by
700>>>>>>>>>>>>>//                new colors.
700>>>>>>>>>>>>>//************************************************************************
700>>>>>>>>>>>>>Use Windows
700>>>>>>>>>>>>>Use WinUser
700>>>>>>>>>>>>>
700>>>>>>>>>>>>>// constants for RGB color schemes NOTE: these are for backwards compatibility - do not use them!
700>>>>>>>>>>>>>
700>>>>>>>>>>>>>// The following symbols mirror the "System-Colors" of Windows and
700>>>>>>>>>>>>>// can be used wherever a RGB value is expected
700>>>>>>>>>>>>>
700>>>>>>>>>>>>>
700>>>>>>>>>>>>>// In VDF a rgb system color is recognized by setting the hi bit
700>>>>>>>>>>>>>// to true and passing the windows system color constant in the lower
700>>>>>>>>>>>>>// bytes. for example: ColorButtonFace in WinUser is $0F. In VDF you can
700>>>>>>>>>>>>>// set the color by setting the value $8000000F.
700>>>>>>>>>>>>>//     Set Color to $8000000F   or Set Color to clBtnFace
700>>>>>>>>>>>>>// VDF will do the system color conversion. It will also recognize that
700>>>>>>>>>>>>>// this is a system color and change the color if the system colors change.
700>>>>>>>>>>>>>//
700>>>>>>>>>>>>>//  If you were using any of these in the past you will now get different
700>>>>>>>>>>>>>//  values. You should be able to use them as before, but the actual value
700>>>>>>>>>>>>>//  is different. If you want to get the actual rgb color for this, use the
700>>>>>>>>>>>>>//  following: Move (GetSysColor(clName IAND $FFFFFF))
700>>>>>>>>>>>>>//  Note that these are better values for setting colors because they
700>>>>>>>>>>>>>//  will change if the system colors are changed.
700>>>>>>>>>>>>>
700>>>>>>>>>>>>>
700>>>>>>>>>>>>>
700>>>>>>>>>>>>>
700>>>>>>>>>>>>>//#REPLACE clDefault |CI$20000000 // not implemented yet
700>>>>>>>>>>>>>//#REPLACE clNone    |CI$1FFFFFFF // not implemented yet
700>>>>>>>>>>>>>
700>>>>>>>>>>>>>// Function RGB
700>>>>>>>>>>>>>// this function is used to generate a COLORREF value for GDI functions
700>>>>>>>>>>>>>
700>>>>>>>>>>>>>Function RGB Global Integer iRed Integer iGreen Integer iBlue Returns Integer
701>>>>>>>>>>>>>    Function_Return (iRed+(iGreen*256)+(iBlue*65536))
702>>>>>>>>>>>>>End_Function
703>>>>>>>>>>>>>
703>>>>>>>>>>>>>Function R_From_RGB Global Integer rgbColor returns Integer
704>>>>>>>>>>>>>    Function_Return (rgbColor IAND $0000FF)
705>>>>>>>>>>>>>End_Function
706>>>>>>>>>>>>>
706>>>>>>>>>>>>>Function G_From_RGB Global Integer rgbColor returns Integer
707>>>>>>>>>>>>>    Function_Return ((rgbColor IAND $00FF00) /256)
708>>>>>>>>>>>>>End_Function
709>>>>>>>>>>>>>
709>>>>>>>>>>>>>Function B_From_RGB Global Integer rgbColor returns Integer
710>>>>>>>>>>>>>    Function_Return ((rgbColor IAND $FF0000) /65536)
711>>>>>>>>>>>>>End_Function
712>>>>>>>>>>>>>
712>>>>>>>>>>>
712>>>>>>>>>>>Function Default_System_Value GLOBAL string ProfileKey String DfltVal returns string
713>>>>>>>>>>>  local string ProfileVal
714>>>>>>>>>>>  Get System_Profile_String ProfileKey to ProfileVal
715>>>>>>>>>>>  If ProfileVal eq '' Move DfltVal to ProfileVal
718>>>>>>>>>>>  Function_return ProfileVal
719>>>>>>>>>>>end_function
720>>>>>>>>>>>
720>>>>>>>>>>>// RgbSt can be a complex r,g,b (e.g. 255,255,255) or an
720>>>>>>>>>>>// evaluatable constant (65535, clYellow, clBtnFace). If you
720>>>>>>>>>>>// pass a bad value (e.g. "john") you will get an error
720>>>>>>>>>>>Function String_to_Rgb Global string RgbSt returns integer
721>>>>>>>>>>>   Local Integer iR iG iB
722>>>>>>>>>>>   Local Integer iPos
722>>>>>>>>>>>   Pos "," in RgbSt to iPos
724>>>>>>>>>>>>
724>>>>>>>>>>>   If Ipos Begin
726>>>>>>>>>>>      Left RgbSt to iR        (iPos-1)
728>>>>>>>>>>>>
728>>>>>>>>>>>      Mid RgbSt  to RgbSt 255 (iPos+1)
731>>>>>>>>>>>>
731>>>>>>>>>>>      Pos "," in RgbSt to iPos
733>>>>>>>>>>>>
733>>>>>>>>>>>      If iPos Begin
735>>>>>>>>>>>         Left RgbSt to iG     (iPos-1)
737>>>>>>>>>>>>
737>>>>>>>>>>>         Mid  RgbSt to iB 255 (iPos+1)
740>>>>>>>>>>>>
740>>>>>>>>>>>      End
740>>>>>>>>>>>>
740>>>>>>>>>>>  End
740>>>>>>>>>>>>
740>>>>>>>>>>>  else Function_return (eval(RgbSt))
742>>>>>>>>>>>  Function_Return (rgb(iR,iG,iB))
743>>>>>>>>>>>End_Procedure
744>>>>>>>>>>>
744>>>>>>>>>>>
744>>>>>>>>>>>Function Default_System_Color GLOBAL string ProfileKey Integer iRGB returns integer
745>>>>>>>>>>>  local string ProfileVal
746>>>>>>>>>>>  Get System_Profile_String ProfileKey to ProfileVal
747>>>>>>>>>>>  If ProfileVal ne '' ;     Get String_to_RGB ProfileVal to iRGB
750>>>>>>>>>>>  Function_return iRGB
751>>>>>>>>>>>end_function
752>>>>>>>>>>>
752>>>>>>>>>>>// These are rgb integers!
752>>>>>>>>>>>Integer Default_Highlight_Row_Color       Default_Current_Item_Color
752>>>>>>>>>>>Integer Default_Slist_Highlight_Row_Color Default_Slist_Current_Item_Color
752>>>>>>>>>>>
752>>>>>>>>>>>Integer Default_Table_Grid Default_sList_Grid
752>>>>>>>>>>>
752>>>>>>>>>>>//************************************************************************
752>>>>>>>>>>>// Global message to set default grid colors and gridlines.
752>>>>>>>>>>>// ***********************************************************************
752>>>>>>>>>>>
752>>>>>>>>>>>Procedure DoSetDefaultColors Global
753>>>>>>>>>>>    Get Default_System_Color "TableRowColor"  (RGB(255,255,255))  to Default_Highlight_row_Color
754>>>>>>>>>>>    Get Default_System_Color "TableCellColor" (RGB(255,255,255))  to Default_Current_Item_Color
755>>>>>>>>>>>    Get Default_System_Color "SlistRowColor"  (RGB(  0,255,255))  to Default_slist_Highlight_row_Color
756>>>>>>>>>>>    Get Default_System_Color "SlistCellColor" (RGB(  0,255,255))  to Default_slist_current_item_color
757>>>>>>>>>>>    Get Default_System_Value "TableGrid"      3 to Default_Table_Grid
758>>>>>>>>>>>    Get Default_System_Value "SListGrid"      2 to Default_SList_Grid
759>>>>>>>>>>>End_procedure
760>>>>>>>>>>>
760>>>>>>>>>>>Send DoSetDefaultColors // Set up the default colors.
761>>>>>>>>>Use DFAutmgn         // auto form_margin, form_column, form_datatype support
INCLUDING FILE: DFAUTMGN.PKG
761>>>>>>>>>>>//************************************************************************
761>>>>>>>>>>>// Confidential Trade Secret.
761>>>>>>>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
761>>>>>>>>>>>// as an unpublished work.  All rights reserved.
761>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
761>>>>>>>>>>>//
761>>>>>>>>>>>//****************************************************************************//
761>>>>>>>>>>>//                                                                            //
761>>>>>>>>>>>// $File name  : DFAutMgn.pkg - Mixin to assign auto margins and types        //
761>>>>>>>>>>>// $Author(s)  : John Tuohy                                                   //
761>>>>>>>>>>>//                                                                            //
761>>>>>>>>>>>// $Rev History                                                               //
761>>>>>>>>>>>// JT 10/14/97   Added better mask support. If datatype is a mask, do not     //
761>>>>>>>>>>>//               change it - assume it was explicitly set.                     //
761>>>>>>>>>>>// JT ??/??/??   File created                                                 //
761>>>>>>>>>>>//****************************************************************************//
761>>>>>>>>>>>// mixin class for automatically setting up form_margins, form_datatypes
761>>>>>>>>>>>// and form_column.
761>>>>>>>>>>>//
761>>>>>>>>>>>// Interface
761>>>>>>>>>>>//
761>>>>>>>>>>>//
761>>>>>>>>>>>//
761>>>>>>>>>>>//  Send Define_Form_Margins  - set form_margin and form_datatype for all
761>>>>>>>>>>>//                              items whose current form_margin is not 0.
761>>>>>>>>>>>//                              Numerics are all set as 0 (no decimal points)
761>>>>>>>>>>>//                              You must SET Points to set the decimal points.
761>>>>>>>>>>>//                              When we can get this information directly this
761>>>>>>>>>>>//                              will change. Sent by End_construct_Object
761>>>>>>>>>>>//
761>>>>>>>>>>>//  Send Define_Form_Margin Integer Item#
761>>>>>>>>>>>//                              Called by Define_form_Margins. As above
761>>>>>>>>>>>//
761>>>>>>>>>>>//  Send Define_List_Form_Columns
761>>>>>>>>>>>//                              Sets form_column for all items in a list
761>>>>>>>>>>>//                              whose current form_column value is zero.
761>>>>>>>>>>>//                              Sent by End_Construct_Object
761>>>>>>>>>>>//
761>>>>>>>>>>>//  Set Points {Item item#} to ##
761>>>>>>>>>>>//                              Sets decimal and adjust form_margin to
761>>>>>>>>>>>//                              accomodate the decimal point. Must be sent
761>>>>>>>>>>>//                              by program. If no item is passed 0 is used.
761>>>>>>>>>>>//
761>>>>>>>>>>>//
761>>>>>>>>>>>// Note: none of these should have any effect on existing programs. If
761>>>>>>>>>>>//       form_margin or form_column is already set (non-zero) these messages
761>>>>>>>>>>>//       will do nothing.
761>>>>>>>>>>>//
761>>>>>>>>>>>
761>>>>>>>>>>>Class Auto_Setup_Mixin is a Mixin
762>>>>>>>>>>>
762>>>>>>>>>>>   // Must be manually set because we can not get at this data
762>>>>>>>>>>>   //
762>>>>>>>>>>>   Procedure Set Points integer item# integer pos
763>>>>>>>>>>>     local integer itm ps pobjid file# field# datatype margin len
764>>>>>>>>>>>     if num_arguments eq 1 ;        Move Item# to ps // itm will be 0
767>>>>>>>>>>>     else begin
768>>>>>>>>>>>        Move item# to itm
769>>>>>>>>>>>        Move pos   to ps
770>>>>>>>>>>>     end
770>>>>>>>>>>>>
770>>>>>>>>>>>     Get protoType_object to pObjId
771>>>>>>>>>>>     Get Data_File  of pObjID item Itm to File#
772>>>>>>>>>>>     Get Data_Field of pObjID item Itm to Field#
773>>>>>>>>>>>     if ps eq -1 ; // -1 = set to the default        Get_Attribute DF_Field_Precision of file# field# to ps
778>>>>>>>>>>>
778>>>>>>>>>>>     Set Form_DataType item itm to ps
779>>>>>>>>>>>
779>>>>>>>>>>>     // set form margin
779>>>>>>>>>>>     If File# Begin
781>>>>>>>>>>>        Get_Attribute DF_Field_Length of file# field# to len
784>>>>>>>>>>>        If Ps Increment len
787>>>>>>>>>>>        Set Form_margin item itm to len
788>>>>>>>>>>>     End
788>>>>>>>>>>>>
788>>>>>>>>>>>   end_Procedure
789>>>>>>>>>>>
789>>>>>>>>>>>   //  set all form_columns settings for any form which is currently 0.
789>>>>>>>>>>>   //
789>>>>>>>>>>>   Procedure Define_List_Form_Columns
790>>>>>>>>>>>     local integer Item# Cnt prev_col col wd
791>>>>>>>>>>>     Get Item_count of (ProtoType_object(Current_Object)) to Cnt
792>>>>>>>>>>>     If Cnt gt 1 Begin
794>>>>>>>>>>>        Decrement Cnt                      // don't set first item
795>>>>>>>>>>>        Get Form_Column item 0 to Prev_col // 0 is already ok.
796>>>>>>>>>>>        For item# from 1 to cnt
802>>>>>>>>>>>>
802>>>>>>>>>>>           Get form_Column item item# to col
803>>>>>>>>>>>           If col eq 0 Begin
805>>>>>>>>>>>              Move (Form_Width(Current_Object,item#-1)+Prev_Col) to col
806>>>>>>>>>>>              Set Form_Column item item# to col
807>>>>>>>>>>>           end
807>>>>>>>>>>>>
807>>>>>>>>>>>           Move col to Prev_col
808>>>>>>>>>>>        Loop
809>>>>>>>>>>>>
809>>>>>>>>>>>     end
809>>>>>>>>>>>>
809>>>>>>>>>>>   End_Procedure
810>>>>>>>>>>>
810>>>>>>>>>>>   Procedure Define_Form_Margins
811>>>>>>>>>>>     local integer Item# Cnt
812>>>>>>>>>>>     Get Item_count of (ProtoType_object(Current_Object)) to Cnt
813>>>>>>>>>>>     Decrement Cnt
814>>>>>>>>>>>     For item# from 0 to cnt
820>>>>>>>>>>>>
820>>>>>>>>>>>         If (Form_margin(Current_Object,item#)=0) ;            send define_Form_Margin item#
823>>>>>>>>>>>     Loop
824>>>>>>>>>>>>
824>>>>>>>>>>>   End_Procedure
825>>>>>>>>>>>
825>>>>>>>>>>>   Procedure Define_Form_Margin Integer item#
826>>>>>>>>>>>     local integer pObjId file# Field#
827>>>>>>>>>>>     Local integer datatype margin wintype formtype
827>>>>>>>>>>>     Get protoType_object to pObjId
828>>>>>>>>>>>     Get Data_File  of pObjID item Item# to File#
829>>>>>>>>>>>     If File# Begin
831>>>>>>>>>>>        Get Data_Field of pObjID item Item# to Field#
832>>>>>>>>>>>        Get_Attribute DF_Field_Length of file# field# to Margin
835>>>>>>>>>>>        Get_Attribute DF_Field_Type of file# field#   to datatype
838>>>>>>>>>>>        move ASCII_WINDOW to wintype
839>>>>>>>>>>>        if datatype eq DF_BCD begin
841>>>>>>>>>>>           Get_Attribute DF_Field_Precision of file# field# to Wintype
844>>>>>>>>>>>           If WinType increment margin
847>>>>>>>>>>>        end
847>>>>>>>>>>>>
847>>>>>>>>>>>        else if datatype eq DF_DATE begin
850>>>>>>>>>>>           move DATE_WINDOW to wintype
851>>>>>>>>>>>           move 10 to margin
852>>>>>>>>>>>        end
852>>>>>>>>>>>>
852>>>>>>>>>>>        Set Form_Margin   item Item# to Margin
853>>>>>>>>>>>        Get Form_datatype item item# to Formtype
854>>>>>>>>>>>        If ( (Formtype=MASK_NUMERIC_WINDOW OR ;              FormType=MASK_CURRENCY_WINDOW) AND ;              Form_Mask(Current_Object,item#)='') Begin
856>>>>>>>>>>>                 If WinType gt 0 Subtract (WinType+1) from Margin
859>>>>>>>>>>>                 If Formtype eq MASK_CURRENCY_WINDOW ;                    Set Currency_Mask item Item# to Margin wintype
862>>>>>>>>>>>                  Else ;                    Set Numeric_Mask item Item# to Margin wintype
864>>>>>>>>>>>        End
864>>>>>>>>>>>>
864>>>>>>>>>>>        Else If FormType le ascii_window ; // only auto-set if non mask. If type is a mask           Set Form_DataType Item Item# to wintype // we assume it was defined.
868>>>>>>>>>>>     End
868>>>>>>>>>>>>
868>>>>>>>>>>>     Else ;        Set Form_Margin   item Item# to (form_width(Current_Object,Item#))
870>>>>>>>>>>>   End_Procedure
871>>>>>>>>>>>
871>>>>>>>>>>>
871>>>>>>>>>>>end_class
872>>>>>>>>>use kbdfix.pkg
INCLUDING FILE: KBDFIX.PKG
872>>>>>>>>>>>//************************************************************************
872>>>>>>>>>>>// KbdFix.pkg
872>>>>>>>>>>>//
872>>>>>>>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida,
872>>>>>>>>>>>// All rights reserved.
872>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
872>>>>>>>>>>>//
872>>>>>>>>>>>//************************************************************************
872>>>>>>>>>>>//  Description:
872>>>>>>>>>>>//      Provides a fix for foreign kbds where the top number row is altered
872>>>>>>>>>>>//      (i.e. French numbers are shifted). This replaces logic found in the
872>>>>>>>>>>>//      C msg_key handler for dfForm and dfEntry. This will be removed when the
872>>>>>>>>>>>//      code is fixed in C.
872>>>>>>>>>>>//   rev 1.1
872>>>>>>>>>>>//
872>>>>>>>>>>>//   Can be added to end of dfbase.pkg
872>>>>>>>>>>>//
872>>>>>>>>>>>//  11/23/98 JJT - use Current instead of 0 for item#. Fixes grid bug
872>>>>>>>>>>>//  06/05/98 JJT - revsion 1.1 Fixed bug in Combos where up/dn arrows don't work
872>>>>>>>>>>>//  04/05/98 JJT - Added Backspace support (from Frank VDV)
872>>>>>>>>>>>//  03/27/98 JJT - created
872>>>>>>>>>>>//************************************************************************
872>>>>>>>>>>>
872>>>>>>>>>>>// replace key procedure to properly check numeric keyboard values
872>>>>>>>>>>>procedure Private.Key for BaseClass integer iKy returns integer
873>>>>>>>>>>>    local integer iRet iCh iType iSep
874>>>>>>>>>>>    Get Form_DataType item CURRENT to iType
875>>>>>>>>>>>    // only special check non mask date and all numerics.
875>>>>>>>>>>>    // for some reason mask numerics allow bad character to slip
875>>>>>>>>>>>    // in. We can filter them here.
875>>>>>>>>>>>    If ( iType<=DATE_WINDOW or iType=MASK_CURRENCY_WINDOW or iType=MASK_NUMERIC_WINDOW) Begin
877>>>>>>>>>>>        // convert to DF key. If ascii, ret ascii/Char value else ret DF key value
877>>>>>>>>>>>        get dfkey iKy to iCh
878>>>>>>>>>>>        // char is ok if between '0' and '9 or above 255 or a BS (8)
878>>>>>>>>>>>        If ( (iCh<48 AND iCh <> 8) OR (iCh>57 AND iCh<=255)) Begin // Changed by FVDV for Backspace support
880>>>>>>>>>>>           If iType EQ DATE_WINDOW Begin // date type
882>>>>>>>>>>>              Get_Attribute DF_DATE_SEPARATOR to iSep //check for date separator
885>>>>>>>>>>>              If iSep ne iCh Procedure_return 0
888>>>>>>>>>>>           end
888>>>>>>>>>>>>
888>>>>>>>>>>>           else Begin // numeric type. 32=" ", 45="-"
889>>>>>>>>>>>              If (iCh<>32 AND iCh<>45) begin
891>>>>>>>>>>>                 Get_Attribute DF_DECIMAL_SEPARATOR to iSep
894>>>>>>>>>>>                 If iSep ne iCh Procedure_return 0
897>>>>>>>>>>>              end
897>>>>>>>>>>>>
897>>>>>>>>>>>           end
897>>>>>>>>>>>>
897>>>>>>>>>>>        end
897>>>>>>>>>>>>
897>>>>>>>>>>>    end
897>>>>>>>>>>>>
897>>>>>>>>>>>    // this means the key is ok
897>>>>>>>>>>>    Set Windows_override_state to false
898>>>>>>>>>>>    Procedure_return 0
899>>>>>>>>>>>End_Procedure
900>>>>>>>>>>>
900>>>>>>>>>>>// replace key procedure to properly check numeric keyboard values
900>>>>>>>>>>>procedure key for dfBaseForm integer iKy returns integer
901>>>>>>>>>>>    Send Private.Key iKy
902>>>>>>>>>>>    If not (Windows_override_State(current_object)) forward send key iKy
906>>>>>>>>>>>End_procedure
907>>>>>>>>>>>
907>>>>>>>>>>>procedure key for dfBaseEntry integer iKy returns integer
908>>>>>>>>>>>    Send Private.Key iKy
909>>>>>>>>>>>    If not (Windows_override_State(current_object)) forward send key iKy
913>>>>>>>>>>>End_procedure
914>>>>>>>>>>>
914>>>>>>>>>>>procedure key for dfBaseFormList integer iKy returns integer
915>>>>>>>>>>>    Send Private.Key iKy
916>>>>>>>>>>>   If not (Windows_override_State(current_object)) forward send key iKy
920>>>>>>>>>>>End_procedure
921>>>>>>>>>>>
921>>>>>>>>>>>procedure key for dfBaseEntryList integer iKy returns integer
922>>>>>>>>>>>    Send Private.Key iKy
923>>>>>>>>>>>    If not (Windows_override_State(current_object)) forward send key iKy
927>>>>>>>>>>>End_procedure
928>>>>>>>>>>>
928>>>>>>>>>>>// This has been moved to DfCmbFrm.pkg and added to the classes ComboForm and
928>>>>>>>>>>>// ComboEntry because Key is defined in dfBaseComboBox and cannot be replaced here.
928>>>>>>>>>>>// When RT is fixed...remember to remove from combo code.
928>>>>>>>>>>>// for some reason these keys get forwarded in the C code.
928>>>>>>>>>>>// if key navigation, just let windows do it.
928>>>>>>>>>>>//procedure key for dfBaseComboBox integer iKy returns integer
928>>>>>>>>>>>//   If (iKy=KUPARROW or iKy=KDOWNARROW or iKy=KSCROLL_BACK or iKy=KSCROLL_FORWARD) ;
928>>>>>>>>>>>//      set windows_override_state to false
928>>>>>>>>>>>//   else forward send key iKy
928>>>>>>>>>>>//end_procedure
928>>>>>>>>>>>
928>>>>>>>>>>>//procedure key for dfBaseComboBoxEntry integer iKy returns integer
928>>>>>>>>>>>//   If (iKy=KUPARROW or iKy=KDOWNARROW or iKy=KSCROLL_BACK or iKy=KSCROLL_FORWARD) ;
928>>>>>>>>>>>//      set windows_override_state to false
928>>>>>>>>>>>//   else forward send key iKy
928>>>>>>>>>>>//end_procedure
928>>>>>>>>>
928>>>>>>>>>Define CAPSLOCK_BIT for 19            // can be used in Item_Option.
928>>>>>>>>>Define CAPSLOCK_BIT_VALUE for (2^19)  // The value when bit 19 is set
928>>>>>>>>>
928>>>>>>>>>// Redefine Exit-application beahviors so that:
928>>>>>>>>>//
928>>>>>>>>>// 1. Exit_Application is always delegated to the desktop
928>>>>>>>>>// 2. From desktop it gets exit_system_confirmation
928>>>>>>>>>// 3. Exit_system_confirmation Broadcasts verify_exit_application and
928>>>>>>>>>//    if successful broadcasts Notify_Exit_application (these will be
928>>>>>>>>>//    (received by main_panels to do with what they want).
928>>>>>>>>>
928>>>>>>>>>Function Desktop_Verify_Exit_Application For DFDesktop Returns Integer
929>>>>>>>>>    Local Integer Fail
930>>>>>>>>>    Broadcast Get Broadcast_Verify_Exit_Application To Fail
932>>>>>>>>>    Function_Return Fail
933>>>>>>>>>End_Function
934>>>>>>>>>
934>>>>>>>>>Procedure Desktop_Notify_Exit_Application For DFDesktop
935>>>>>>>>>    Broadcast Send Broadcast_Notify_Exit_Application
937>>>>>>>>>End_Procedure // Notify_Exit_Application
938>>>>>>>>>
938>>>>>>>>>Function Exit_System_Confirmation For DFDesktop Returns Integer
939>>>>>>>>>    Local Integer Fail
940>>>>>>>>>    Get Desktop_Verify_Exit_Application of desktop To Fail
941>>>>>>>>>    If Not Fail ;        Send Desktop_Notify_Exit_Application to desktop
944>>>>>>>>>    Function_Return (Not(Fail))
945>>>>>>>>>End_Function
946>>>>>>>>>
946>>>>>>>>>Procedure Exit_Application For BaseClass
947>>>>>>>>>    If Current_Object Ne Desktop ;       Delegate Send Exit_Application
951>>>>>>>>>    Else ;       If (Exit_System_Confirmation(Current_Object)) Abort
955>>>>>>>>>End_Procedure
956>>>>>>>>>
956>>>>>>>>>// global returns the size of the screen
956>>>>>>>>>Function GUIScreen_Size GLOBAL Returns Integer
957>>>>>>>>>    Function_Return (GetSystemMetrics(SM_CYSCREEN)*65536 + ;                     GetSystemMetrics(SM_CXSCREEN) )
958>>>>>>>>>End_Function
959>>>>>>>>>
959>>>>>>>>>// Key related global functions
959>>>>>>>>>
959>>>>>>>>>// Private
959>>>>>>>>>// Convert String to Oem->Ansi or Ansi->Oem: Pass bToAnsi to determine convserion
959>>>>>>>>>// This will convert both DF Strings and C Strings (zero terminated). If passed a
959>>>>>>>>>// Cstring it will return a string with a terminating zero. If passed a DFstring
959>>>>>>>>>// the terminating zero is not returned.
959>>>>>>>>>// This function is used by ToAnsi and ToOEM. Developers are encouraged to use
959>>>>>>>>>// these two functions
959>>>>>>>>>
959>>>>>>>>>Function ConvertChar Global integer bToAnsi String sString Returns String
960>>>>>>>>>  Local Pointer psString
961>>>>>>>>>  Local Integer iVoid bIsCString
961>>>>>>>>>  Move (ascii(Right(sString,1))=0) to bIsCString
962>>>>>>>>>  If Not bISCString Append sString (character(0))
965>>>>>>>>>  GetAddress Of sString To psString
966>>>>>>>>>  if bToAnsi Move (OEMToANSI(psString,psString)) To iVoid
969>>>>>>>>>  else       Move (ANSItoOEM(psString,psString)) To iVoid
971>>>>>>>>>  Function_Return (if(bIsCString, sString, cstring(sString)))
972>>>>>>>>>End_Function // ToANSI
973>>>>>>>>>
973>>>>>>>>>// Convert OEM string to ANSI
973>>>>>>>>>// Can be either DF string or zero terminated C style string
973>>>>>>>>>Function ToANSI Global String sString Returns String
974>>>>>>>>>  Function_Return (ConvertChar(1,sString))
975>>>>>>>>>End_Function // ToANSI
976>>>>>>>>>
976>>>>>>>>>// Convert ANSI string to OEM
976>>>>>>>>>// Can be either DF string or zero terminated C style string
976>>>>>>>>>Function ToOEM Global String sString Returns String
977>>>>>>>>>  Function_Return (ConvertChar(0,sString))
978>>>>>>>>>End_Function // ToOEM
979>>>>>>>>>
979>>>>>>>>>// Convert Passed info into an Ascii (ansi) character using the
979>>>>>>>>>// current regional style defined within windows.
979>>>>>>>>>//
979>>>>>>>>>// Pass:    Virtual Key, Shift key state, Capslock key state
979>>>>>>>>>// Return:  Ascii Char
979>>>>>>>>>Function To_Ascii Global Integer vKey Integer bShift integer bCaps Returns Integer
980>>>>>>>>>  Local Integer iScan iChar
981>>>>>>>>>  Map_virtual_key vKey to iScan              // convert vkey to scan code
982>>>>>>>>>  Reset_key_Array                            // clear keyboard array
983>>>>>>>>>  Set_Key_Array vKey to ($80)                // Push VKey Down
984>>>>>>>>>  If bShift Set_Key_Array VK_SHIFT to ($80)  // if shift, push shift key down
987>>>>>>>>>  if bCaps  Set_Key_Array VK_CAPITAL to 1    // if Capslock, toggle capital key
990>>>>>>>>>  To_Ascii ((iScan*65536)+vkey) to iChar     // convert.
991>>>>>>>>>  Function_Return iChar
992>>>>>>>>>End_Function
993>>>>>>>>>
993>>>>>>>>>//  Take the last key processed by the Key message and return
993>>>>>>>>>//  its ANSI value. Returns 0, if a non-printable character (e.g. F1).
993>>>>>>>>>//  This should normally only get called within a Key message handler
993>>>>>>>>>Function AnsiKey FOR BaseClass Returns integer
994>>>>>>>>>    local integer vkCode
995>>>>>>>>>    local integer iShift iCapsLock
995>>>>>>>>>    local integer iCh
995>>>>>>>>>    get virtual_key to vkcode
996>>>>>>>>>    get shift_state to iShift // this has Key_Alt, Key_Shift and Key_Ctrl
997>>>>>>>>>    Get_Key_State VK_CAPITAL to iCapslock  // is the capslock key currently depressed?
998>>>>>>>>>    Get To_Ascii vkCode (iShift IAND KEY_SHIFT<>0) (iCapslock=1) to iCh
999>>>>>>>>>    Function_Return iCh
1000>>>>>>>>>End_Function
1001>>>>>>>>>
1001>>>>>>>>>//  Take the last key processed by the Key message and return
1001>>>>>>>>>//  its OEM value. Returns 0, if a non-printable character (e.g. F1).
1001>>>>>>>>>//  This should normally only get called within a Key message handler. This is what
1001>>>>>>>>>//  you want if you are comparing this with other data in your proggrams
1001>>>>>>>>>Function OemKey FOR BaseClass Returns integer
1002>>>>>>>>>    Function_Return (ascii(ToOEM(Character(AnsiKey(Current_Object)))))
1003>>>>>>>>>end_function
1004>>>>>>>>>
1004>>>>>>>>>//  Take the last key processed by the Key message and return
1004>>>>>>>>>//  its DF value. If a printable character it returns OEM value. If
1004>>>>>>>>>//  a special key (f1, Key_save, etc.) returns the DF name of this key.
1004>>>>>>>>>//
1004>>>>>>>>>Function DFKey  FOR BaseClass integer iKey Returns integer
1005>>>>>>>>>    Local integer iCh
1006>>>>>>>>>    Get OemKey to iCh
1007>>>>>>>>>    // if non-zero return OEM char value, If zero return the DF value (which is passed)
1007>>>>>>>>>    // first stripping off the shift bits. The passed key would be the key sent by the
1007>>>>>>>>>    // Key message.
1007>>>>>>>>>    Function_Return (if(ich, iCh, (iKey iAND $F1FF))) // $F1FF= Not (Key_Shift+Key_Alt+Key_Ctrl)
1008>>>>>>>>>End_Function
1009>>>>>>>>>
1009>>>>>>>>>
1009>>>>>>>>>//*** Mixin class: Bitmap_Support_Mixin
1009>>>>>>>>>//***
1009>>>>>>>>>//*** 1. Adds support for get Bitmap property to those classes which can
1009>>>>>>>>>//***    already support [set] bitmap.
1009>>>>>>>>>//
1009>>>>>>>>>Class Bitmap_Support_Mixin Is A Mixin
1010>>>>>>>>>
1010>>>>>>>>>    Procedure Define_Bitmap_Support_Mixin
1011>>>>>>>>>        Property String     private.bitmap              Public ""
1012>>>>>>>>>    End_Procedure
1013>>>>>>>>>
1013>>>>>>>>>    Procedure Set Bitmap String sBitmap
1014>>>>>>>>>        set private.bitmap to sBitmap
1015>>>>>>>>>        forward set bitmap to sBitmap
1017>>>>>>>>>    End_Procedure
1018>>>>>>>>>
1018>>>>>>>>>    Function Bitmap Returns string
1019>>>>>>>>>        Function_Return (private.bitmap(current_object))
1020>>>>>>>>>    End_Function
1021>>>>>>>>>
1021>>>>>>>>>End_Class
1022>>>>>>>>>
1022>>>>>>>>>
1022>>>>>>>>>//
1022>>>>>>>>>//  Mixin Classes
1022>>>>>>>>>//
1022>>>>>>>>>
1022>>>>>>>>>Class Label_Mixin Is A Mixin
1023>>>>>>>>>
1023>>>>>>>>>    Procedure Set Label String Val
1024>>>>>>>>>        Set Value Item 0 To Val
1025>>>>>>>>>    End_Procedure
1026>>>>>>>>>
1026>>>>>>>>>    Function Label Returns String
1027>>>>>>>>>        Function_Return (Value(Current_Object,0))
1028>>>>>>>>>    End_Function
1029>>>>>>>>>
1029>>>>>>>>>End_Class
1030>>>>>>>>>
1030>>>>>>>>>//
1030>>>>>>>>>// This mixin is used by single item and no item objects for shadow
1030>>>>>>>>>// support.
1030>>>>>>>>>//
1030>>>>>>>>>// Note that an object supports three levels of shadowing. A single item
1030>>>>>>>>>// can be shadowed (if applicable), an object can be explicitly shadowed
1030>>>>>>>>>// or an object can be indirectly shadowed by a parent.
1030>>>>>>>>>//
1030>>>>>>>>>// Public Interface:
1030>>>>>>>>>//
1030>>>>>>>>>//  Get/Set Object_Shadow_State   Sets the object's explicit SS.
1030>>>>>>>>>//                                Gets object's explicit IOR Implicit SS
1030>>>>>>>>>//  Get/Set Item_Shadow_State     (if items are applicable)
1030>>>>>>>>>//  Get     Implicit_Shadow_State  if shadowed as group by ancestor
1030>>>>>>>>>//  Get     Explicit_Shadow_State  if shadowed by self
1030>>>>>>>>>//  Send    Shadow_Display
1030>>>>>>>>>//
1030>>>>>>>>>//  Get/Set Shadow_State          (if item based, sets item, else object)
1030>>>>>>>>>
1030>>>>>>>>>Class Shadow_Mixin Is A Mixin
1031>>>>>>>>>
1031>>>>>>>>>    Procedure Define_Shadow_Mixin
1032>>>>>>>>>        // Should child objects receive shadow notification?
1032>>>>>>>>>        Property Integer Broadcast_Implicit_Shadow_State public False
1033>>>>>>>>>        Property Integer Private.Explicit_Shadow_State   public False
1034>>>>>>>>>        Property Integer Private.Implicit_Shadow_State   public False
1035>>>>>>>>>        // will be used by objects that have no runtime shadow_state
1035>>>>>>>>>        // item property (edits and containers)
1035>>>>>>>>>        Property Integer Private.Shadow_State            public False
1036>>>>>>>>>    End_Procedure // Construct_Object
1037>>>>>>>>>
1037>>>>>>>>>    Register_Function Object_Shadow_State returns integer
1037>>>>>>>>>
1037>>>>>>>>>    // Returns true if the object is shadowed as part of a group shadow.
1037>>>>>>>>>    Function Implicit_Shadow_State returns integer
1038>>>>>>>>>       Function_Return (Private.Implicit_Shadow_State(Current_Object))
1039>>>>>>>>>    End_Function // Implicit_Shadow_State
1040>>>>>>>>>
1040>>>>>>>>>    // Returns true if the object is explicitly shadowed by self
1040>>>>>>>>>    Function Explicit_Shadow_State returns integer
1041>>>>>>>>>       Function_Return (Private.Explicit_Shadow_State(Current_Object))
1042>>>>>>>>>    End_Function // Explicit_Shadow_State
1043>>>>>>>>>
1043>>>>>>>>>    //  Private: Should only be sent by an ancestor object which is
1043>>>>>>>>>    //  notifying all descendants that they have been shadowed as part
1043>>>>>>>>>    //  of a group
1043>>>>>>>>>    //
1043>>>>>>>>>    Procedure Set Implicit_Shadow_State integer iState
1044>>>>>>>>>       Set Private.Implicit_Shadow_State to iState // store group shadow status
1045>>>>>>>>>       // If the object is explicitly shadowed by the object we don't do anything
1045>>>>>>>>>       // because if state=T it is already shadowed (nothing to do) and if
1045>>>>>>>>>       // state=F we don't want to unshadow this one anyway
1045>>>>>>>>>       If Not (Explicit_Shadow_State(Current_Object)) Begin
1047>>>>>>>>>          Set Current_Shadow_State to iState
1048>>>>>>>>>          Send Shadow_display
1049>>>>>>>>>          if (Broadcast_Implicit_Shadow_State(Current_Object)) ;             Broadcast Set Implicit_Shadow_State to iState
1053>>>>>>>>>       End
1053>>>>>>>>>>
1053>>>>>>>>>    End_Procedure // Set Implicit_Shadow_State
1054>>>>>>>>>
1054>>>>>>>>>    Procedure Set Object_Shadow_State Integer iState
1055>>>>>>>>>       Set Private.Explicit_Shadow_State to iState
1056>>>>>>>>>       If Not (Implicit_Shadow_State(Current_Object)) Begin
1058>>>>>>>>>          Set Current_Shadow_State to iState
1059>>>>>>>>>          Send Shadow_display
1060>>>>>>>>>          if (Broadcast_Implicit_Shadow_State(Current_Object)) ;             Broadcast Set Implicit_Shadow_State to iState
1064>>>>>>>>>       End
1064>>>>>>>>>>
1064>>>>>>>>>    End_Procedure // Set Object_Shadow_State
1065>>>>>>>>>
1065>>>>>>>>>    Procedure Shadow_Display
1066>>>>>>>>>    End_Procedure
1067>>>>>>>>>
1067>>>>>>>>>    // Item_shadow_state always gets the item's SS
1067>>>>>>>>>    Procedure Set Item_Shadow_State integer iItem integer iState
1068>>>>>>>>>       Forward Set Shadow_State item iItem to iState
1070>>>>>>>>>    End_Procedure // Set Item_Shadow_State
1071>>>>>>>>>
1071>>>>>>>>>    Function Item_Shadow_State integer iItem Returns integer
1072>>>>>>>>>       Local integer iState
1073>>>>>>>>>       Forward Get Shadow_State item iItem to iState
1075>>>>>>>>>       Function_Return iState
1076>>>>>>>>>    End_Function // Item_Shadow_State
1077>>>>>>>>>
1077>>>>>>>>>    //  Current_Shadow_State sets the object's true shadow-state
1077>>>>>>>>>    //  With single item objects we use
1077>>>>>>>>>    //  the shadow_state of item 0 (the only item) to let store this
1077>>>>>>>>>    //  information. In multi-item this must be replaced (see multi-item below)
1077>>>>>>>>>    //  This is for the single item model
1077>>>>>>>>>    Procedure Set Current_Shadow_State integer iState
1078>>>>>>>>>        Set Item_Shadow_State item 0 to iState
1079>>>>>>>>>    End_Procedure // Set Current_Shadow_State
1080>>>>>>>>>
1080>>>>>>>>>    // This returns if the object is truly shadowed. In single item we
1080>>>>>>>>>    // use item 0
1080>>>>>>>>>    Function Object_Shadow_State returns integer
1081>>>>>>>>>        Function_Return (Item_shadow_State(Current_Object,0))
1082>>>>>>>>>    End_Function // Object_Shadow_State
1083>>>>>>>>>
1083>>>>>>>>>    //  Enabled_State, for this rev, simply calls Object_Shadow_State but
1083>>>>>>>>>    //  inverts the parameter logic because Enabled_State is "enable centric"
1083>>>>>>>>>    //  vs. Shadow_State which is "disable centric". KCR
1083>>>>>>>>>    //
1083>>>>>>>>>    Procedure Set Enabled_State Integer bState
1084>>>>>>>>>        set Object_Shadow_State to (not(bState))
1085>>>>>>>>>    End_Procedure
1086>>>>>>>>>
1086>>>>>>>>>    //  Again, we're calling upon Object_Shadow_State and simply inverting
1086>>>>>>>>>    //  the return value to match the context of the "enable centric"
1086>>>>>>>>>    //  property. KCR
1086>>>>>>>>>    //
1086>>>>>>>>>    Function Enabled_State returns integer
1087>>>>>>>>>        Function_Return (not(object_shadow_state(current_object)))
1088>>>>>>>>>    End_Function
1089>>>>>>>>>
1089>>>>>>>>>    // Shadow_State can apply either to the object or the item. In single
1089>>>>>>>>>    // item or no item objects it refers to the object. In multi-item it
1089>>>>>>>>>    // refers to the item. This is the single item model
1089>>>>>>>>>    Procedure Set Shadow_State integer iItem integer iState
1090>>>>>>>>>        Set Object_Shadow_State to iState
1091>>>>>>>>>    End_Procedure
1092>>>>>>>>>
1092>>>>>>>>>    Function Shadow_State integer iItem returns Integer
1093>>>>>>>>>        Function_Return (Object_Shadow_State(Current_Object))
1094>>>>>>>>>    End_Function
1095>>>>>>>>>
1095>>>>>>>>>    Function Private.Next_object_id integer fg returns integer
1096>>>>>>>>>        Local integer rVal
1097>>>>>>>>>        Forward Get Next_object_id fg to rVal
1099>>>>>>>>>        Function_Return rVal
1100>>>>>>>>>    End_Function
1101>>>>>>>>>
1101>>>>>>>>>    Function Private.Prior_object_id integer fg returns integer
1102>>>>>>>>>        Local integer rVal
1103>>>>>>>>>        Forward Get Prior_object_id fg to rVal
1105>>>>>>>>>        Function_Return rVal
1106>>>>>>>>>    End_Function
1107>>>>>>>>>
1107>>>>>>>>>    Function Next_object_id integer fg returns integer
1108>>>>>>>>>        Local integer SS rVal FirstObj
1109>>>>>>>>>        // Never descend into shadowed objects...there's no point
1109>>>>>>>>>        If (Fg=0 AND Object_Shadow_State(Current_Object)) ;            Move 1 to Fg
1112>>>>>>>>>        Get Private.Next_object_id fg to rVal
1113>>>>>>>>>        // Keep track of first object we check. This way if we descend into
1113>>>>>>>>>        // a ring we will know it.
1113>>>>>>>>>        Move rVal to FirstObj
1114>>>>>>>>>        // Loop until we find a valid object. Skip shadowed objects
1114>>>>>>>>>        While (rVal<>Current_Object AND rVal=>Desktop AND Object_Shadow_State(rVal))
1118>>>>>>>>>            Get Private.Next_Object_Id of rVal 1 to rVal
1119>>>>>>>>>            // if back to first object...get out
1119>>>>>>>>>            If rVal eq FirstObj Move 0 to rVal
1122>>>>>>>>>        Loop
1123>>>>>>>>>>
1123>>>>>>>>>        Function_Return rVal
1124>>>>>>>>>    End_Function // Next_object_id
1125>>>>>>>>>
1125>>>>>>>>>    Function Prior_object_id integer fg returns integer
1126>>>>>>>>>        Local integer rVal FirstObj
1127>>>>>>>>>        If (Implicit_Shadow_State(Current_Object)) Move 1 to Fg
1130>>>>>>>>>        Get Private.Prior_object_id fg to rVal
1131>>>>>>>>>        // Keep track of first object we check. This way if we descend into
1131>>>>>>>>>        // a ring we will know it.
1131>>>>>>>>>        Move rVal to FirstObj
1132>>>>>>>>>        While (rVal<>Current_Object AND rVal=>Desktop AND Object_Shadow_State(rVal))
1136>>>>>>>>>            If (Implicit_Shadow_State(rVal)) ;                Delegate Get Private.Prior_Object_Id of rVal 0 to rVal
1140>>>>>>>>>            else;                Get Private.Prior_Object_Id of rVal 0 to rVal
1142>>>>>>>>>            // if back to first object...get out
1142>>>>>>>>>            If rVal eq FirstObj Move 0 to rVal
1145>>>>>>>>>        End
1146>>>>>>>>>>
1146>>>>>>>>>        Function_Return rVal
1147>>>>>>>>>    End_Function
1148>>>>>>>>>
1148>>>>>>>>>    Procedure Activate returns integer
1149>>>>>>>>>        Local integer rVal
1150>>>>>>>>>        If (active_state(Current_Object) AND Object_Shadow_State(Current_Object)) ;            Move 1 to rVal
1153>>>>>>>>>        else ;            Forward Get MSG_Activate to rVal
1156>>>>>>>>>        Procedure_Return rVal
1157>>>>>>>>>    End_Procedure // Activate
1158>>>>>>>>>
1158>>>>>>>>>    Procedure Entering Returns Integer
1159>>>>>>>>>        Local Integer rVal
1160>>>>>>>>>        // if entering is ok and single item check shadow state of that item.
1160>>>>>>>>>        Get Object_Shadow_State To rVal
1161>>>>>>>>>        If not rVal ;            Forward Get Msg_Entering To rVal  // Do Normal Entering
1165>>>>>>>>>        Procedure_Return rVal
1166>>>>>>>>>    End_Procedure
1167>>>>>>>>>
1167>>>>>>>>>End_Class
1168>>>>>>>>>
1168>>>>>>>>>// This replaces the message in shadow_mixin. With entry based single item
1168>>>>>>>>>// objects you must set the item options for noenter and noput to make
1168>>>>>>>>>// shadowing work. However, setting noenter, sends shadow_state which will
1168>>>>>>>>>// call this. This allows us to set displayonly fields by sending
1168>>>>>>>>>//
1168>>>>>>>>>//   Set Object_Shadow_State to T|F
1168>>>>>>>>>//
1168>>>>>>>>>Class Entry_Shadow_Mixin is a Mixin
1169>>>>>>>>>
1169>>>>>>>>>    Procedure Set Object_Shadow_State Integer iState
1170>>>>>>>>>       Local integer SS
1171>>>>>>>>>       // if we have an item (we should) we will see if the item
1171>>>>>>>>>       // option NOENTER is correct. If not, we will set it, which will
1171>>>>>>>>>       // in turn, call this handler again - this time with the item set
1171>>>>>>>>>       // correctly. This keeps item options and Shadow_state in synch
1171>>>>>>>>>       If (Item_Count(Current_Object)) Begin
1173>>>>>>>>>          Get Item_Options item 0 to SS
1174>>>>>>>>>          // We must also check skipfound (since this sets shadow_State) if
1174>>>>>>>>>          // this is a skipfound item we assume that it is the skipfound that
1174>>>>>>>>>          // is setting the shadow state and we do not change noenter or noput
1174>>>>>>>>>          // 16 = SkipFound
1174>>>>>>>>>          If ( (SS IAND 16)=0) Begin // only check if skipfound is not used
1176>>>>>>>>>             // 8 = Noenter
1176>>>>>>>>>             Move ( (SS IAND 8)<>0 ) to SS // SS = T if NOENTER not set (yet)
1177>>>>>>>>>             if SS ne iState Begin // if item opt is not what we want, set it
1179>>>>>>>>>                Set Item_Option item 0 NOPUT   to iState // which will call this
1180>>>>>>>>>                Set Item_Option item 0 NOENTER to iState // proc again.
1181>>>>>>>>>                Procedure_Return
1182>>>>>>>>>             End
1182>>>>>>>>>>
1182>>>>>>>>>          End
1182>>>>>>>>>>
1182>>>>>>>>>       End
1182>>>>>>>>>>
1182>>>>>>>>>       //
1182>>>>>>>>>       Set Private.Explicit_Shadow_State to iState
1183>>>>>>>>>       If Not (Implicit_Shadow_State(Current_Object)) Begin
1185>>>>>>>>>          Set Current_Shadow_State to iState
1186>>>>>>>>>          Send Shadow_display
1187>>>>>>>>>          if (Broadcast_Implicit_Shadow_State(Current_Object)) ;             Broadcast Set Implicit_Shadow_State to iState
1191>>>>>>>>>       End
1191>>>>>>>>>>
1191>>>>>>>>>    End_Procedure // Set Object_Shadow_State
1192>>>>>>>>>End_Class
1193>>>>>>>>>
1193>>>>>>>>>
1193>>>>>>>>>//
1193>>>>>>>>>// This mixin is used by multi objects for shadow support.
1193>>>>>>>>>//
1193>>>>>>>>>
1193>>>>>>>>>Class Multi_Item_Shadow_Mixin Is A Mixin
1194>>>>>>>>>
1194>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
1195>>>>>>>>>
1195>>>>>>>>>    Procedure Define_Multi_Item_Shadow_Mixin
1196>>>>>>>>>        Send Define_Shadow_Mixin
1197>>>>>>>>>    End_Procedure
1198>>>>>>>>>
1198>>>>>>>>>    Procedure Set Current_Shadow_State integer iState
1199>>>>>>>>>       Set Private.Shadow_State to iState
1200>>>>>>>>>    End_Procedure // Set Current_Shadow_State
1201>>>>>>>>>
1201>>>>>>>>>    Function Object_Shadow_State returns integer
1202>>>>>>>>>       Function_Return (Private.shadow_State(Current_Object))
1203>>>>>>>>>    End_Function // Object_Shadow_State
1204>>>>>>>>>
1204>>>>>>>>>    Procedure Set Shadow_State integer iItem integer iState
1205>>>>>>>>>       Set Item_Shadow_State item iItem to iState
1206>>>>>>>>>    End_Procedure
1207>>>>>>>>>
1207>>>>>>>>>    Function Shadow_State integer iItem returns Integer
1208>>>>>>>>>       Function_Return (Item_Shadow_State(Current_Object,iItem))
1209>>>>>>>>>    End_Function
1210>>>>>>>>>
1210>>>>>>>>>End_Class
1211>>>>>>>>>
1211>>>>>>>>>
1211>>>>>>>>>Class FormFloatingPopupMenu IS A DFBaseEditPullDown
1212>>>>>>>>>    Procedure PopUp
1213>>>>>>>>>        Local Integer Loc
1214>>>>>>>>>        Get Absolute_Mouse_Location of Desktop to Loc
1215>>>>>>>>>        // set location relative to mouse
1215>>>>>>>>>        Set GuiLocation To (Hi(Loc)) (Low(Loc))
1216>>>>>>>>>        Forward Send Popup
1218>>>>>>>>>    End_Procedure
1219>>>>>>>>>End_Class
1220>>>>>>>>>
1220>>>>>>>>>Class FloatingPopupMenu IS A FormFloatingPopupMenu
1221>>>>>>>>>    Procedure Construct_Object
1222>>>>>>>>>       Forward Send Construct_Object
1224>>>>>>>>>       Send Delete_Data
1225>>>>>>>>>    End_Procedure // Construct_Object
1226>>>>>>>>>End_Class
1227>>>>>>>>>
1227>>>>>>>>>// We use a global default context menu id for speed purposes. Every form
1227>>>>>>>>>// will need to set this and if we do this via delegation it will take
1227>>>>>>>>>// much longer.
1227>>>>>>>>>Integer Default_Form_Floating_Menu_ID
1227>>>>>>>>>
1227>>>>>>>>>Object FormFloatingMenu is a FormFloatingPopupMenu
1229>>>>>>>>>    Move Current_Object to Default_Form_Floating_Menu_Id
1230>>>>>>>>>End_Object
1231>>>>>>>>>
1231>>>>>>>>>Class FloatingPopupMenu_Mixin is a Mixin
1232>>>>>>>>>
1232>>>>>>>>>    Procedure Define_FloatingPopupMenu_Mixin
1233>>>>>>>>>        Property integer Floating_Menu_Object public Default_Form_Floating_Menu_Id
1234>>>>>>>>>    End_Procedure
1235>>>>>>>>>
1235>>>>>>>>>    // augment left mouse down to pop up a floating panel. Only do this if
1235>>>>>>>>>    // the object successfully takes the focus.
1235>>>>>>>>>    Procedure mouse_down2 integer i1 integer i2
1236>>>>>>>>>        local integer obj rval iCur
1237>>>>>>>>>        Forward Send mouse_down2 i1 i2
1239>>>>>>>>>        Get Floating_Menu_object to obj
1240>>>>>>>>>        if obj Begin
1242>>>>>>>>>            If (Focus(Current_Object)<>Current_Object) ;                get msg_Activate to rval
1245>>>>>>>>>            if ( focus(desktop)=Current_Object) Begin
1247>>>>>>>>>                Move (i1-1+Top_Item(Current_Object)) to iCur
1248>>>>>>>>>                If (not(shadow_state(Current_Object,iCur))) Begin
1250>>>>>>>>>                    if ( Item_window(Current_Object)<>i1 ) ;                        Set Current_Item to iCur
1253>>>>>>>>>                    if ( Item_window(Current_Object)=i1) ;                        Send Popup to obj
1256>>>>>>>>>                end
1256>>>>>>>>>>
1256>>>>>>>>>            end
1256>>>>>>>>>>
1256>>>>>>>>>        end
1256>>>>>>>>>>
1256>>>>>>>>>    End_Procedure // mouse_down2
1257>>>>>>>>>
1257>>>>>>>>>End_Class
1258>>>>>>>>>
1258>>>>>>>>>Class RGB_Support_Temp_Mixin Is A Mixin
1259>>>>>>>>>
1259>>>>>>>>>    Procedure Define_RGB_Support_Temp_Mixin
1260>>>>>>>>>        property integer private.Object_Color public 0
1261>>>>>>>>>        // always force a set object_color, by passing 0,0 VDF
1261>>>>>>>>>        // convert these to system colors ($10xx) and pass them on to
1261>>>>>>>>>        // set Dynamic_colors. We will augment Dynamic_colors to set our
1261>>>>>>>>>        // internal object_color. This way we always have object_color set
1261>>>>>>>>>        set object_color to 0 0
1262>>>>>>>>>    End_Procedure
1263>>>>>>>>>
1263>>>>>>>>>    Procedure set Dynamic_colors integer i1 integer i2
1264>>>>>>>>>        // if sent when within init_instance, ignore. Our property is not yet defined.
1264>>>>>>>>>        // Keep track of object_color manually.
1264>>>>>>>>>        if buildingObjectid eq 0 set Private.Object_color to (i1*65536 + i2)
1267>>>>>>>>>
1267>>>>>>>>>        forward set dynamic_colors to i1 i2
1269>>>>>>>>>
1269>>>>>>>>>        // if a system color convert from old DF color to new GetSysColor.
1269>>>>>>>>>        // This way changes in the windows color will get set right away.
1269>>>>>>>>>        // DF system colors are $10xx, New Rgb is $800000xx).
1269>>>>>>>>>        If (i1 iAND $1000) Set TextColor to ((I1 iAND $FF) iOR $80000000)
1272>>>>>>>>>        If (i2 iAND $1000) Set Color      to ((I2 iAND $FF) iOR $80000000)
1275>>>>>>>>>
1275>>>>>>>>>    End_Procedure
1276>>>>>>>>>
1276>>>>>>>>>    Function object_color Returns integer
1277>>>>>>>>>        Function_Return (Private.Object_color(current_object))
1278>>>>>>>>>    End_Function
1279>>>>>>>>>
1279>>>>>>>>>End_Class
1280>>>>>>>>>
1280>>>>>>>>>
1280>>>>>>>>>// Class: Dftextbox
1280>>>>>>>>>//
1280>>>>>>>>>//  1. Support Autosizing (auto_size_state). Default to T.
1280>>>>>>>>>//  2. Set skip_state to true.
1280>>>>>>>>>//  3. Determine color by looking at parent object
1280>>>>>>>>>//  4. Default J_mode is left, vertical centered.
1280>>>>>>>>>//  5. Understands GET/SET Label
1280>>>>>>>>>//
1280>>>>>>>>>Enumeration_List
1280>>>>>>>>>   Define TBSHADOW_ON_NONE
1280>>>>>>>>>   Define TBSHADOW_ON_LOCAL
1280>>>>>>>>>   Define TBSHADOW_ON_GROUP
1280>>>>>>>>>   Define TBSHADOW_ON_ALL
1280>>>>>>>>>End_Enumeration_List
1280>>>>>>>>>
1280>>>>>>>>>Class TextBox Is A DfBaseTextBox
1281>>>>>>>>>
1281>>>>>>>>>    Procedure Construct_Object
1282>>>>>>>>>        Forward Send Construct_Object
1284>>>>>>>>>        Send Define_RGB_Support_Temp_Mixin
1285>>>>>>>>>        Property Integer Auto_Size_State Public True
1286>>>>>>>>>        Property Integer Label_Shadow_Display_Mode public TBSHADOW_ON_GROUP
1287>>>>>>>>>        Set Skip_State To True
1288>>>>>>>>>        Set Justification_Mode To (Jmode_Left+jmode_Vcenter)
1289>>>>>>>>>        // JJT - can't remove this until the Panel problem is fixed!
1289>>>>>>>>>        Send Use_Parent_Color
1290>>>>>>>>>        Send Define_Shadow_Mixin
1291>>>>>>>>>        // JJT - can't use this until the Panel problem is fixed!
1291>>>>>>>>>        //Set Transparent_State to True
1291>>>>>>>>>        Send Define_Bitmap_Support_Mixin
1292>>>>>>>>>    End_Procedure // Construct_Object
1293>>>>>>>>>
1293>>>>>>>>>    Import_Class_Protocol RGB_Support_Temp_Mixin
1294>>>>>>>>>    Import_Class_Protocol Label_Mixin
1295>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
1296>>>>>>>>>    Import_Class_Protocol Bitmap_Support_Mixin
1297>>>>>>>>>
1297>>>>>>>>>    // JJT - can't remove this until the Panel problem is fixed!
1297>>>>>>>>>    Procedure Use_Parent_Color
1298>>>>>>>>>            Local Integer Txtclr Backclr
1299>>>>>>>>>            Delegate Get TextColor To TxtClr
1301>>>>>>>>>            Delegate Get Color To backClr
1303>>>>>>>>>            If Backclr Eq Txtclr Move CLBlack To Txtclr
1306>>>>>>>>>            Set TextColor To TxtClr
1307>>>>>>>>>            Set Color To backClr
1308>>>>>>>>>    End_Procedure
1309>>>>>>>>>
1309>>>>>>>>>    Procedure Set Value Integer Item# String Val
1310>>>>>>>>>        If (Auto_Size_State(Current_Object)) Send Autosize Val
1313>>>>>>>>>        Forward Set Value Item Item# To Val
1315>>>>>>>>>    End_Procedure
1316>>>>>>>>>
1316>>>>>>>>>    Procedure Autosize String Val
1317>>>>>>>>>        Local Integer Ext
1318>>>>>>>>>        // Spy 01/11/98 Find the Extension of the label based on
1318>>>>>>>>>        // the Ansi value of the string. This seems to work right
1318>>>>>>>>>        //Get Text_Extent Val To Ext //The Old Code
1318>>>>>>>>>        Get Text_Extent (ToAnsi(Val)) To Ext
1319>>>>>>>>>        //This Added and cannot be removed till the bug with blank textboxes be fixed
1319>>>>>>>>>        // Spy 11/01/1999
1319>>>>>>>>>        If (Trim(ToAnsi(Val))) eq "" Move 0 to Ext
1322>>>>>>>>>        Set Guisize To (Hi(Ext)+3) (Low(Ext)+2)
1323>>>>>>>>>        Send Adjust_logicals
1324>>>>>>>>>    End_Procedure
1325>>>>>>>>>
1325>>>>>>>>>    Procedure Shadow_Display
1326>>>>>>>>>       Local Integer iMode iEnable
1327>>>>>>>>>       Get Label_Shadow_Display_Mode to iMode
1328>>>>>>>>>       if ( ( (iMode=TBSHADOW_ON_GROUP OR iMode=TBSHADOW_ON_ALL) AND ;              Implicit_Shadow_State(Current_Object) ) OR ;            ( (iMode=TBSHADOW_ON_LOCAL OR iMode=TBSHADOW_ON_ALL) AND ;              Explicit_Shadow_State(Current_Object) ) ) ;                Move 0 to iEnable
1331>>>>>>>>>       else ;                Move 1 to iEnable
1333>>>>>>>>>       Send Enable_Window iEnable
1334>>>>>>>>>    End_Procedure // Shadow_Display
1335>>>>>>>>>
1335>>>>>>>>>    Procedure Enable_Window integer iState
1336>>>>>>>>>        Local integer hWnd
1337>>>>>>>>>        Get Window_Handle to hWnd
1338>>>>>>>>>        If hWnd ;            Move (EnableWindow(hWnd,iState)) To hWnd
1341>>>>>>>>>    End_procedure
1342>>>>>>>>>
1342>>>>>>>>>    Procedure Page_Object integer iState
1343>>>>>>>>>        Local Handle hWnd
1344>>>>>>>>>        Get Window_Handle To hWnd
1345>>>>>>>>>        Forward Send Page_Object iState
1347>>>>>>>>>        If (hWnd=0 and iState) ;            Send Shadow_Display
1350>>>>>>>>>    End_Procedure
1351>>>>>>>>>
1351>>>>>>>>>End_Class
1352>>>>>>>>>
1352>>>>>>>>>Use Dflblmx          // Auto label support for controls
INCLUDING FILE: DFLBLMX.PKG
1352>>>>>>>>>>>// 02/13/98 JJT   Canceled use_parent_color in autolabel. Owner should handle this
1352>>>>>>>>>>>//  1/28/98 JJT   Added rgb color support
1352>>>>>>>>>>>// 08/30/96 JJT - Major revisions. Label is now child of object and is
1352>>>>>>>>>>>//                paged but not added to the focus-tree. Checks window_handle
1352>>>>>>>>>>>//                to see if it is paged.
1352>>>>>>>>>>>// 07/23/96 JJT - New Class names
1352>>>>>>>>>>>// 03/15/96 JJT Many changes to support more dynamic labels.
1352>>>>>>>>>>>//              Add destroy_label_Object
1352>>>>>>>>>>>//              Set Label destroys object if value is ''.
1352>>>>>>>>>>>//              Set Label Activates if required and resizes as needed
1352>>>>>>>>>>>//              Needs_Label_Sizing_State tracks if label info is 'dirty'
1352>>>>>>>>>>>//              If GUISize or Loc changes, sets dirty if change
1352>>>>>>>>>>>//              If Set just-mode or offset is changed, set dirty
1352>>>>>>>>>>>//              When label is paged, it checks asks owner to resize as needed
1352>>>>>>>>>>>//              Support JMODE_TOP - Positive offset moves it up
1352>>>>>>>>>>>//              Adjusted so label centers with form text
1352>>>>>>>>>>>//
1352>>>>>>>>>>>//
1352>>>>>>>>>>>//
1352>>>>>>>>>>>//
1352>>>>>>>>>>>
1352>>>>>>>>>>>Use WIndows
1352>>>>>>>>>>>
1352>>>>>>>>>>>Integer DEFAULT_LABEL_OFFSET
1352>>>>>>>>>>>Move 60 to DEFAULT_LABEL_OFFSET
1353>>>>>>>>>>>
1353>>>>>>>>>>>Integer DEFAULT_LABEL_JMODE
1353>>>>>>>>>>>Move JMODE_LEFT to DEFAULT_LABEL_JMODE
1354>>>>>>>>>>>
1354>>>>>>>>>>>Class AutoLabel is a TextBox
1355>>>>>>>>>>>
1355>>>>>>>>>>>   Procedure Construct_Object
1356>>>>>>>>>>>      Forward Send Construct_Object
1358>>>>>>>>>>>      Property Integer Owner_Object           public 0
1359>>>>>>>>>>>   End_Procedure // Construct_Object
1360>>>>>>>>>>>
1360>>>>>>>>>>>   Procedure Mouse_Down
1361>>>>>>>>>>>      local integer obj rval
1362>>>>>>>>>>>      Get owner_object to obj
1363>>>>>>>>>>>      if (obj AND Focus(Desktop)<>obj) ;            Get Msg_Activate of obj to rval
1366>>>>>>>>>>>      else Forward Send Mouse_Down
1369>>>>>>>>>>>   End_Procedure // Mouse_Down
1370>>>>>>>>>>>
1370>>>>>>>>>>>   //  Augmented to Ask owner to locate itself. Owner will only do this
1370>>>>>>>>>>>   //  if required.
1370>>>>>>>>>>>   Procedure Page_Object integer iState
1371>>>>>>>>>>>      local integer obj
1372>>>>>>>>>>>      Get owner_object to obj
1373>>>>>>>>>>>      If (iState AND Obj) ;         Send Request_Locate_Label to Obj // optimized version
1376>>>>>>>>>>>      Forward Send page_Object iState
1378>>>>>>>>>>>   End_Procedure
1379>>>>>>>>>>>
1379>>>>>>>>>>>   Procedure Shadow_Display
1380>>>>>>>>>>>      Local Integer iMode iEnable
1381>>>>>>>>>>>      local integer obj
1381>>>>>>>>>>>      Get Owner_object to obj
1382>>>>>>>>>>>      If Obj Begin
1384>>>>>>>>>>>         Get Label_Shadow_Display_Mode of Obj to iMode
1385>>>>>>>>>>>         if ( ( (iMode=TBSHADOW_ON_GROUP OR iMode=TBSHADOW_ON_ALL) AND ;             Implicit_Shadow_State(Obj) ) OR ;           ( (iMode=TBSHADOW_ON_LOCAL OR iMode=TBSHADOW_ON_ALL) AND ;             Explicit_shadow_state(Obj) ) ) ;               Move 0 to iEnable
1388>>>>>>>>>>>         else ;               Move 1 to iEnable
1390>>>>>>>>>>>         Send Enable_Window iEnable
1391>>>>>>>>>>>      End
1391>>>>>>>>>>>>
1391>>>>>>>>>>>   End_Procedure // Shadow_Display
1392>>>>>>>>>>>
1392>>>>>>>>>>>   Procedure Set Implicit_Shadow_State integer iState
1393>>>>>>>>>>>   End_procedure
1394>>>>>>>>>>>
1394>>>>>>>>>>>   Procedure Destroy_Object
1395>>>>>>>>>>>     local integer obj
1396>>>>>>>>>>>     Get owner_object to obj         // if we have an owner
1397>>>>>>>>>>>     if obj ;                        // object break the link        Set Label_Object of obj to 0 // This is always called before the
1400>>>>>>>>>>>     Forward Send Destroy_Object     // owner is destroyed!
1402>>>>>>>>>>>   End_Procedure // Destroy_Object
1403>>>>>>>>>>>
1403>>>>>>>>>>>   Procedure Add_Focus integer id
1404>>>>>>>>>>>   End_Procedure // Add_Focus
1405>>>>>>>>>>>
1405>>>>>>>>>>>  // auto-labels should not do this. They will be given their colors
1405>>>>>>>>>>>  // by their owner object. Cancel text box behavior.
1405>>>>>>>>>>>  Procedure Use_parent_color
1406>>>>>>>>>>>  End_Procedure
1407>>>>>>>>>>>
1407>>>>>>>>>>>
1407>>>>>>>>>>>
1407>>>>>>>>>>>End_Class
1408>>>>>>>>>>>
1408>>>>>>>>>>>Class DFLabel_Mixin is a Mixin
1409>>>>>>>>>>>
1409>>>>>>>>>>>  Procedure Define_DFLabel_Mixin
1410>>>>>>>>>>>     Property Integer Label_object                      public 0
1411>>>>>>>>>>>     Property Integer Label_Needs_sizing_State          public true
1412>>>>>>>>>>>     Property Integer Private.Label_Row_Offset          public 0
1413>>>>>>>>>>>     Property Integer Private.Label_Col_Offset          public DEFAULT_LABEL_OFFSET
1414>>>>>>>>>>>     Property Integer Private.Label_Justification_Mode  public DEFAULT_LABEL_JMODE
1415>>>>>>>>>>>     Property Integer Private.Label_Shadow_Display_Mode public TBSHADOW_ON_GROUP
1416>>>>>>>>>>>  End_Procedure
1417>>>>>>>>>>>
1417>>>>>>>>>>>  Procedure Set Label_Shadow_Display_Mode integer mode
1418>>>>>>>>>>>    Local integer obj
1419>>>>>>>>>>>    Set Private.Label_Shadow_Display_Mode to mode
1420>>>>>>>>>>>    If (Window_Handle(Current_Object)) Begin
1422>>>>>>>>>>>       Get Label_object to obj
1423>>>>>>>>>>>       If Obj Send Shadow_Display to obj
1426>>>>>>>>>>>    End
1426>>>>>>>>>>>>
1426>>>>>>>>>>>  end_procedure
1427>>>>>>>>>>>
1427>>>>>>>>>>>  Function Label_Shadow_Display_Mode returns integer
1428>>>>>>>>>>>     function_return (private.label_Shadow_Display_Mode(Current_Object))
1429>>>>>>>>>>>  End_Function // Label_Justification_mode
1430>>>>>>>>>>>
1430>>>>>>>>>>>  Function Create_Label_Object returns integer
1431>>>>>>>>>>>     Local integer id Cobj
1432>>>>>>>>>>>     Get Label_object to id
1433>>>>>>>>>>>     if Id eq 0 Begin
1435>>>>>>>>>>>        Move Current_Object to cObj
1436>>>>>>>>>>>        Object Tb is a AutoLabel
1438>>>>>>>>>>>          Move Current_Object to id
1439>>>>>>>>>>>          Set Owner_Object to cObj
1440>>>>>>>>>>>        End_Object
1441>>>>>>>>>>>        Set Label_object to id
1442>>>>>>>>>>>     end
1442>>>>>>>>>>>>
1442>>>>>>>>>>>     Function_return id
1443>>>>>>>>>>>  End_Function
1444>>>>>>>>>>>
1444>>>>>>>>>>>  // Allow label object to be destroyed. If active, first deactivate
1444>>>>>>>>>>>  // Only destroy if the object is gone,
1444>>>>>>>>>>>  Procedure Destroy_Label_Object
1445>>>>>>>>>>>     Local integer id
1446>>>>>>>>>>>     Get Label_object to id
1447>>>>>>>>>>>//     Showln  (Name(Current_Object))  ' - ' id ' - ' (Name(id))
1447>>>>>>>>>>>     // only if label exists already
1447>>>>>>>>>>>     If id Send Destroy_object to Id    // destroy object and mark it as gone
1450>>>>>>>>>>>  End_Procedure
1451>>>>>>>>>>>
1451>>>>>>>>>>>  Procedure Destroy_Object
1452>>>>>>>>>>>     Send Destroy_Label_Object  // make sure label is destroyed first
1453>>>>>>>>>>>     Forward Send Destroy_Object
1455>>>>>>>>>>>  End_Procedure
1456>>>>>>>>>>>
1456>>>>>>>>>>>  Procedure Set Label_Offset integer i1 integer i2
1457>>>>>>>>>>>     Set Label_Row_Offset to i1
1458>>>>>>>>>>>     Set Label_Col_Offset to i2
1459>>>>>>>>>>>  End_Procedure // SET Label_Offset
1460>>>>>>>>>>>
1460>>>>>>>>>>>  Function Label_Offset Returns Integer
1461>>>>>>>>>>>     Local integer icRow icCol
1462>>>>>>>>>>>     Get Label_Row_Offset to icRow
1463>>>>>>>>>>>     Get Label_Col_Offset to icCol
1464>>>>>>>>>>>     Function_Return (icRow *65536 + icCol)
1465>>>>>>>>>>>  End_Function // GET Label_Offset
1466>>>>>>>>>>>
1466>>>>>>>>>>>  Procedure SET Label_Row_Offset Integer icRow
1467>>>>>>>>>>>    Set Private.Label_Row_Offset to icRow
1468>>>>>>>>>>>    Send ReSize_Label
1469>>>>>>>>>>>  End_Procedure // SET Label_Row_Offset
1470>>>>>>>>>>>
1470>>>>>>>>>>>  Function Label_row_offset returns integer
1471>>>>>>>>>>>     function_return (private.label_row_offset(Current_Object))
1472>>>>>>>>>>>  End_Function // Label_row_offset
1473>>>>>>>>>>>
1473>>>>>>>>>>>  Procedure SET Label_Col_Offset Integer icCol
1474>>>>>>>>>>>    Set Private.Label_Col_Offset to icCol
1475>>>>>>>>>>>    Send ReSize_Label
1476>>>>>>>>>>>  End_Procedure // SET Label_Col_Offset
1477>>>>>>>>>>>
1477>>>>>>>>>>>  Function Label_col_offset returns integer
1478>>>>>>>>>>>     function_return (private.label_col_offset(Current_Object))
1479>>>>>>>>>>>  End_Function // Label_col_offset
1480>>>>>>>>>>>
1480>>>>>>>>>>>  Procedure Set Label_Justification_Mode integer mode
1481>>>>>>>>>>>     Set Private.Label_Justification_mode to mode
1482>>>>>>>>>>>     Send Resize_Label
1483>>>>>>>>>>>  end_procedure
1484>>>>>>>>>>>
1484>>>>>>>>>>>  Function Label_Justification_mode returns integer
1485>>>>>>>>>>>     function_return (private.label_Justification_mode(Current_Object))
1486>>>>>>>>>>>  End_Function // Label_Justification_mode
1487>>>>>>>>>>>
1487>>>>>>>>>>>  // Set label value, if value becomes '' destroy the label object
1487>>>>>>>>>>>  Procedure Set Label String Val
1488>>>>>>>>>>>     Local integer Id
1489>>>>>>>>>>>     If Val ne '' Begin
1491>>>>>>>>>>>        Get Create_Label_Object to Id // force create if needed
1492>>>>>>>>>>>        Set Label of id to val
1493>>>>>>>>>>>        Send Resize_Label
1494>>>>>>>>>>>        If (Window_Handle(Current_Object) and Window_Handle(Id)=0) ;           Send Page_Object to Id True
1497>>>>>>>>>>>     End
1497>>>>>>>>>>>>
1497>>>>>>>>>>>     Else ;        Send Destroy_Label_Object
1499>>>>>>>>>>>  End_Procedure
1500>>>>>>>>>>>
1500>>>>>>>>>>>  Function Label returns string
1501>>>>>>>>>>>    Local integer obj
1502>>>>>>>>>>>    Local String Lbl
1502>>>>>>>>>>>    Get Label_object to obj
1503>>>>>>>>>>>    If Obj Get Label of obj to lbl
1506>>>>>>>>>>>    function_return lbl
1507>>>>>>>>>>>  End_Function // Label
1508>>>>>>>>>>>
1508>>>>>>>>>>>
1508>>>>>>>>>>>  // Marks label info as dirty. If the object is active it
1508>>>>>>>>>>>  // actually makes the change
1508>>>>>>>>>>>  Procedure ReSize_Label
1509>>>>>>>>>>>     Set Label_Needs_Sizing_State to TRUE // dirty label mark
1510>>>>>>>>>>>     // if object is active, we will immediately update the changes
1510>>>>>>>>>>>     If (Window_Handle(Current_Object)) Send Locate_label
1513>>>>>>>>>>>  End_Procedure
1514>>>>>>>>>>>
1514>>>>>>>>>>>  // Optimized locate label. Only does it if needed
1514>>>>>>>>>>>  //
1514>>>>>>>>>>>  Procedure Request_Locate_Label
1515>>>>>>>>>>>     if (Label_Needs_Sizing_State(Current_Object)) ;        Send Locate_label
1518>>>>>>>>>>>  End_Procedure
1519>>>>>>>>>>>
1519>>>>>>>>>>>  Procedure Locate_Label
1520>>>>>>>>>>>      Local Integer loc Roff Coff obj jmode sz Row Col clr1 clr2 ColMode
1521>>>>>>>>>>>      Get Label_object to obj
1522>>>>>>>>>>>      if obj Begin
1524>>>>>>>>>>>         Send Adjust_logicals
1525>>>>>>>>>>>         Get Label_Row_Offset to Roff
1526>>>>>>>>>>>         Subtract 2 from Roff // This forces this down so that it
1527>>>>>>>>>>>                              // properly aligns against text in a form
1527>>>>>>>>>>>         Get Label_Col_Offset to Coff
1528>>>>>>>>>>>         Get Location to loc
1529>>>>>>>>>>>         Get Label_Justification_mode to jMode
1530>>>>>>>>>>>
1530>>>>>>>>>>>         Move (Low(loc)-Coff) to Col
1531>>>>>>>>>>>         If (jMode IAND JMODE_Right) Begin
1533>>>>>>>>>>>            get Size of Obj to Sz
1534>>>>>>>>>>>            Move (Col - Low(Sz)-1) to Col
1535>>>>>>>>>>>         End
1535>>>>>>>>>>>>
1535>>>>>>>>>>>
1535>>>>>>>>>>>         IF (jMode IAND JMODE_TOP) Begin
1537>>>>>>>>>>>            Add (Hi(Size(Obj))+2) to Roff
1538>>>>>>>>>>>            If (jMode IAND JMODE_Right) ;               Add (Low(Size(Current_Object))) to Col
1541>>>>>>>>>>>         End
1541>>>>>>>>>>>>
1541>>>>>>>>>>>
1541>>>>>>>>>>>         Move (Hi(loc)-Roff) to Row
1542>>>>>>>>>>>
1542>>>>>>>>>>>         Set Location of Obj to Row Col
1543>>>>>>>>>>>            Local Integer Txtclr Backclr
1543>>>>>>>>>>>            delegate Get TextColor To TxtClr
1545>>>>>>>>>>>            delegate Get Color To backClr
1547>>>>>>>>>>>            If Backclr Eq Txtclr Move clBtnText To Txtclr
1550>>>>>>>>>>>            Set TextColor of obj To TxtClr
1551>>>>>>>>>>>            Set Color of obj To backClr
1552>>>>>>>>>>>
1552>>>>>>>>>>>         Set Label_Needs_Sizing_state to false
1553>>>>>>>>>>>      End
1553>>>>>>>>>>>>
1553>>>>>>>>>>>  End_Procedure // Locate_label
1554>>>>>>>>>>>
1554>>>>>>>>>>>  Procedure SET GuiSize integer cy integer cx
1555>>>>>>>>>>>      Local integer Sz NewSz
1556>>>>>>>>>>>      Get GuiSize to Sz
1557>>>>>>>>>>>      Forward SET GuiSize To cy cx
1559>>>>>>>>>>>      If (Not(BuildingObjectId)) Begin
1561>>>>>>>>>>>        Get GuiSize to NewSz
1562>>>>>>>>>>>        If NewSz ne Sz ;            Send Resize_Label
1565>>>>>>>>>>>      End
1565>>>>>>>>>>>>
1565>>>>>>>>>>>  End_Procedure
1566>>>>>>>>>>>
1566>>>>>>>>>>>  Procedure SET GUILocation integer y integer x
1567>>>>>>>>>>>      Local integer lc NewLc
1568>>>>>>>>>>>      Get GuiLocation to Lc
1569>>>>>>>>>>>      Forward SET GUILocation To y x
1571>>>>>>>>>>>      Get GuiLocation to NewLc
1572>>>>>>>>>>>      If Lc ne NewLc ;         Send Resize_Label
1575>>>>>>>>>>>  End_Procedure
1576>>>>>>>>>>>
1576>>>>>>>>>>>  Procedure Label_Shadow_Display
1577>>>>>>>>>>>    Local integer obj
1578>>>>>>>>>>>    Get Label_object to obj
1579>>>>>>>>>>>    If Obj Send Shadow_display to Obj
1582>>>>>>>>>>>  End_Procedure
1583>>>>>>>>>>>
1583>>>>>>>>>>>  // Augment to Page Label if required
1583>>>>>>>>>>>  Procedure Page_Object integer iState
1584>>>>>>>>>>>     local integer obj
1585>>>>>>>>>>>     Get Label_object to obj
1586>>>>>>>>>>>     Forward Send Page_Object iState
1588>>>>>>>>>>>     If (Obj AND iState) ;        Send page_Object to Obj iState
1591>>>>>>>>>>>  End_Procedure
1592>>>>>>>>>>>
1592>>>>>>>>>>>  // Augment to remove Page Label if required
1592>>>>>>>>>>>  Procedure Page_Delete
1593>>>>>>>>>>>     local integer obj
1594>>>>>>>>>>>     Get Label_object to obj
1595>>>>>>>>>>>     If (Obj AND Window_Handle(Obj)) ;        Send page_Delete to Obj
1598>>>>>>>>>>>     Forward Send Page_Delete
1600>>>>>>>>>>>  End_Procedure
1601>>>>>>>>>>>
1601>>>>>>>>>>>End_Class
1602>>>>>>>>>
1602>>>>>>>>>Class MenuBar Is A DfBaseActionBar
1603>>>>>>>>>
1603>>>>>>>>>    Register_Procedure Set Shadow_Status_Help
1603>>>>>>>>>
1603>>>>>>>>>    Procedure Construct_Object
1604>>>>>>>>>        Forward Send Construct_Object
1606>>>>>>>>>        Send Define_StatusHelp_Item_mixin
1607>>>>>>>>>    End_Procedure // Construct_Object
1608>>>>>>>>>
1608>>>>>>>>>    Import_Class_Protocol StatusHelp_Item_Mixin
1609>>>>>>>>>
1609>>>>>>>>>    Procedure OnInitMenu
1610>>>>>>>>>    End_Procedure
1611>>>>>>>>>
1611>>>>>>>>>    Procedure Initialize_Menu
1612>>>>>>>>>        Local Integer SbId
1613>>>>>>>>>        Delegate Get Statusbar_Id to SbId
1615>>>>>>>>>        If SbId Send Initialize_Menu to SbId
1618>>>>>>>>>        Send OnInitMenu
1619>>>>>>>>>    End_Procedure
1620>>>>>>>>>
1620>>>>>>>>>    Procedure OnChange
1621>>>>>>>>>    End_Procedure
1622>>>>>>>>>
1622>>>>>>>>>    Procedure change_menu integer item# integer obj integer iFlags
1623>>>>>>>>>        Local Integer SbId
1624>>>>>>>>>        Local String  sStatus_Help
1624>>>>>>>>>        Send OnChange
1625>>>>>>>>>        Delegate Get Statusbar_Id to SbId
1627>>>>>>>>>        If SbId begin
1629>>>>>>>>>            Get Menu_Status_Help of obj item# iFlags To sStatus_Help
1630>>>>>>>>>            Send Show_Status_Help to SbId sStatus_Help
1631>>>>>>>>>        End
1631>>>>>>>>>>
1631>>>>>>>>>    End_Procedure
1632>>>>>>>>>
1632>>>>>>>>>    Procedure Exit_Menu
1633>>>>>>>>>        Local Integer SbId
1634>>>>>>>>>        Delegate Get Statusbar_Id to SbId
1636>>>>>>>>>        If SbId Send Exit_Menu to SbId
1639>>>>>>>>>    End_Procedure
1640>>>>>>>>>
1640>>>>>>>>>End_class // MenuBar
1641>>>>>>>>>
1641>>>>>>>>>// Class: PopupMenu
1641>>>>>>>>>//
1641>>>>>>>>>// 1. Tells KEY to send redirect message. I think we are now doing this
1641>>>>>>>>>//    but I don't have the message names. I expect this will go away.
1641>>>>>>>>>//
1641>>>>>>>>>
1641>>>>>>>>>Class PopupMenu Is A DfBasePullDown
1642>>>>>>>>>
1642>>>>>>>>>    Procedure Construct_Object
1643>>>>>>>>>        Forward Send Construct_Object
1645>>>>>>>>>        Send Define_Statushelp_Item_Mixin
1646>>>>>>>>>    End_Procedure // Construct_Object
1647>>>>>>>>>
1647>>>>>>>>>    Import_Class_Protocol Statushelp_Item_Mixin
1648>>>>>>>>>
1648>>>>>>>>>    // Redirect_Message
1648>>>>>>>>>    //
1648>>>>>>>>>    // If destination object exists send message to destintion else
1648>>>>>>>>>    // send message to the focus object (if a focus object exists).
1648>>>>>>>>>    //
1648>>>>>>>>>    // It expects the current selected item to CURRENT.
1648>>>>>>>>>    //
1648>>>>>>>>>    // This is a good message for augmentation.
1648>>>>>>>>>    //
1648>>>>>>>>>    Procedure Redirect_Message Returns Integer
1649>>>>>>>>>        Local Integer Msg# Aux# Rval
1650>>>>>>>>>        Get Message To Msg#
1651>>>>>>>>>        Get Aux_Value To Aux#
1652>>>>>>>>>        //
1652>>>>>>>>>        If Msg# Begin // Since Menupopup Is 0, This Will Get Skipped
1654>>>>>>>>>            If Aux# Eq 0 Begin       // If No Destination
1656>>>>>>>>>                Get Focus To Aux#     // Try To Send To Focus
1657>>>>>>>>>                If Aux# Le Desktop ;  // As Long As Focus Is Not The Desktop.                    Move 0 To Aux#
1660>>>>>>>>>            End
1660>>>>>>>>>>
1660>>>>>>>>>            If Aux# Get Msg# Of Aux# To Rval
1663>>>>>>>>>            Procedure_Return Rval
1664>>>>>>>>>        End
1664>>>>>>>>>>
1664>>>>>>>>>    End_Procedure // Redirect_Message
1665>>>>>>>>>
1665>>>>>>>>>    //
1665>>>>>>>>>    // Augment Key to send Redirect_Message (which is
1665>>>>>>>>>    // what the old pulldowns did.) Let's keep this private
1665>>>>>>>>>    //
1665>>>>>>>>>    Procedure Key Integer Ky Returns Integer
1666>>>>>>>>>        Local Integer Rval
1667>>>>>>>>>        Get Msg_Redirect_Message To Rval
1668>>>>>>>>>        Procedure_Return Rval
1669>>>>>>>>>    End_Procedure // Key
1670>>>>>>>>>
1670>>>>>>>>>    Procedure Exit_Menu
1671>>>>>>>>>        Delegate Send Exit_Menu
1673>>>>>>>>>    End_Procedure // Exit_Menu
1674>>>>>>>>>
1674>>>>>>>>>    Procedure OnInitMenu
1675>>>>>>>>>    End_Procedure
1676>>>>>>>>>
1676>>>>>>>>>    Procedure OnChange
1677>>>>>>>>>    End_Procedure
1678>>>>>>>>>
1678>>>>>>>>>    Procedure change_menu integer item# integer obj integer iFlags
1679>>>>>>>>>        Delegate Send change_menu item# obj iFlags
1681>>>>>>>>>        Send OnChange
1682>>>>>>>>>    End_Procedure
1683>>>>>>>>>
1683>>>>>>>>>    Procedure Initialize_Menu
1684>>>>>>>>>        Forward Send Initialize_Menu
1686>>>>>>>>>        Send OnInitMenu
1687>>>>>>>>>    End_Procedure
1688>>>>>>>>>
1688>>>>>>>>>End_Class
1689>>>>>>>>>
1689>>>>>>>>>
1689>>>>>>>>>
1689>>>>>>>>>//  Defines supported display styles for ToolBars. Currently Microsoft has has two
1689>>>>>>>>>//  styles, Flat (as seen in Office '97 and Windows 98) and Raised [not flat]. More
1689>>>>>>>>>//  styles are anticipated which is why the Display_Style property is being implemented
1689>>>>>>>>>//  as a "style" rather than a "flat state".
1689>>>>>>>>>//
1689>>>>>>>>>Enumeration_List
1689>>>>>>>>>   Define TOOLBAR_STYLE_FLAT
1689>>>>>>>>>   Define TOOLBAR_STYLE_RAISED
1689>>>>>>>>>End_Enumeration_List
1689>>>>>>>>>
1689>>>>>>>>>Class BasicToolBar Is A DFBaseToolbar
1690>>>>>>>>>
1690>>>>>>>>>    Procedure Construct_Object
1691>>>>>>>>>        Forward Send Construct_Object
1693>>>>>>>>>        Send Define_StatusHelp_Item_mixin
1694>>>>>>>>>
1694>>>>>>>>>        property integer private.Display_Style  public TOOLBAR_STYLE_FLAT
1695>>>>>>>>>
1695>>>>>>>>>        Set Window_Style To CCS_ADJUSTABLE False
1696>>>>>>>>>        Set Display_Style to TOOLBAR_STYLE_FLAT
1697>>>>>>>>>    End_Procedure // Construct_Object
1698>>>>>>>>>
1698>>>>>>>>>    Import_Class_Protocol StatusHelp_Item_Mixin
1699>>>>>>>>>
1699>>>>>>>>>    Procedure Command Integer I1 Integer I2
1700>>>>>>>>>        Send Redirect_Button_Message I1
1701>>>>>>>>>    End_Procedure
1702>>>>>>>>>
1702>>>>>>>>>    Procedure Set Display_Style Integer iStyle
1703>>>>>>>>>        if iStyle eq TOOLBAR_STYLE_FLAT     Set Window_Style To TB_STYLE_FLAT True
1706>>>>>>>>>        if iStyle eq TOOLBAR_STYLE_RAISED   Set Window_Style To TB_STYLE_FLAT False
1709>>>>>>>>>        set private.Display_Style to iStyle
1710>>>>>>>>>    End_Procedure
1711>>>>>>>>>
1711>>>>>>>>>    Function Display_Style Returns Integer
1712>>>>>>>>>        Function_Return (private.Display_Style(Current_Object))
1713>>>>>>>>>    End_Function
1714>>>>>>>>>
1714>>>>>>>>>    Procedure Redirect_Button_Message Integer Itm
1715>>>>>>>>>        Local Integer Msg Obj Rval
1716>>>>>>>>>        If (Shadow_State(Current_Object,Itm)) Procedure_Return
1719>>>>>>>>>        Get Message Item Itm To Msg
1720>>>>>>>>>        Get Aux_Value Item Itm To Obj
1721>>>>>>>>>        If Obj Eq 0 Begin
1723>>>>>>>>>            Get Focus Of Desktop To Obj
1724>>>>>>>>>            If (Msg And Obj) Get Msg Of Obj To Rval
1727>>>>>>>>>        End
1727>>>>>>>>>>
1727>>>>>>>>>        Else Get Msg Of Obj To Rval
1729>>>>>>>>>        Procedure_Return Rval
1730>>>>>>>>>    End_Procedure // Construct_Object
1731>>>>>>>>>
1731>>>>>>>>>    Procedure Add_Button Integer Img# Integer Msg# Integer Obj#
1732>>>>>>>>>        Local Integer Cnt
1733>>>>>>>>>        Get Item_Count To Cnt
1734>>>>>>>>>        Send Add_Item Msg# ''
1735>>>>>>>>>        Set Form_Image_Index Item Cnt To Img#
1736>>>>>>>>>        If Num_Arguments Gt 2 Set Aux_Value Item Cnt To Obj#
1739>>>>>>>>>    End_Procedure
1740>>>>>>>>>
1740>>>>>>>>>    Procedure Add_Button_Type Integer Type#
1741>>>>>>>>>        Local Integer Cnt
1742>>>>>>>>>        Get Item_Count To Cnt
1743>>>>>>>>>        Decrement Cnt
1744>>>>>>>>>        If Cnt Ge 0 Set Button_Style Item Cnt To Type#
1747>>>>>>>>>    End_Procedure // Add_Button_Type
1748>>>>>>>>>
1748>>>>>>>>>    Procedure Add_Tooltip String Tip
1749>>>>>>>>>        Local Integer Itm
1750>>>>>>>>>        Get Item_Count To Itm
1751>>>>>>>>>        Decrement Itm
1752>>>>>>>>>        If Itm Ge 0 Set Tooltip_Value Item Itm To Tip
1755>>>>>>>>>    End_Procedure
1756>>>>>>>>>
1756>>>>>>>>>    Procedure Add_Space
1757>>>>>>>>>        Send Add_Item Msg_None ''
1758>>>>>>>>>    End_Procedure
1759>>>>>>>>>
1759>>>>>>>>>    Function GUISize Returns Integer
1760>>>>>>>>>        Local Handle hWnd
1761>>>>>>>>>        Local Integer x y x1 y1 cy cx iVoid
1761>>>>>>>>>        Local Pointer lpsRect
1761>>>>>>>>>        Local String sRect
1761>>>>>>>>>        Get Window_Handle To hWnd
1762>>>>>>>>>        If hWnd Begin
1764>>>>>>>>>            ZeroType tRECT To sRect
1765>>>>>>>>>            GetAddress of sRect To lpsRect
1766>>>>>>>>>            Move (GetWindowRect(hWnd, lpsRect)) To iVoid
1767>>>>>>>>>
1767>>>>>>>>>            GetBuff From sRect At tRECT.left   To x
1768>>>>>>>>>            GetBuff From sRect At tRECT.top    To y
1769>>>>>>>>>            GetBuff From sRect At tRECT.right  To x1
1770>>>>>>>>>            GetBuff From sRect At tRECT.bottom To y1
1771>>>>>>>>>
1771>>>>>>>>>            Calc (x1-x) To cx
1772>>>>>>>>>>
1772>>>>>>>>>            Calc (y1-y) To cy
1773>>>>>>>>>>
1773>>>>>>>>>        End
1773>>>>>>>>>>
1773>>>>>>>>>        Else Begin
1774>>>>>>>>>            Move 28 to cy
1775>>>>>>>>>            Move 28 to cx
1776>>>>>>>>>        End
1776>>>>>>>>>>
1776>>>>>>>>>        Function_Return ( cy*65536 + cx )
1777>>>>>>>>>    End_Function
1778>>>>>>>>>
1778>>>>>>>>>    Procedure OnShowHint integer iItem
1779>>>>>>>>>    End_Procedure
1780>>>>>>>>>
1780>>>>>>>>>    Procedure OnHideHint integer iItem
1781>>>>>>>>>    End_Procedure
1782>>>>>>>>>
1782>>>>>>>>>    Procedure Notify Integer wParam Integer lParam
1783>>>>>>>>>        Local Integer iVoid iCode
1784>>>>>>>>>        Local Pointer lpsNMHDR
1784>>>>>>>>>        Local String sNMHDR
1784>>>>>>>>>        ZeroType tNMHDR To sNMHDR
1785>>>>>>>>>        GetAddress of sNMHDR To lpsNMHDR
1786>>>>>>>>>        Move (CopyMemory(lpsNMHDR, lParam, tNMHDR_size)) To iVoid
1787>>>>>>>>>
1787>>>>>>>>>        GetBuff FROM sNMHDR at tNMHDR.code To iCode
1788>>>>>>>>>        If (iCode = TTN_SHOW)     Send Initialize_Hint wParam
1791>>>>>>>>>        Else If (iCode = TTN_POP) Send Hide_Hint       wParam
1795>>>>>>>>>    End_Procedure
1796>>>>>>>>>
1796>>>>>>>>>    Procedure Initialize_Hint integer iItem
1797>>>>>>>>>        Local Integer SbId
1798>>>>>>>>>        Local String sStatus_Help
1798>>>>>>>>>        Local String sShadowed
1798>>>>>>>>>        Send OnShowHint iItem
1799>>>>>>>>>        Delegate Get Statusbar_Id to SbId
1801>>>>>>>>>        If SbId Begin
1803>>>>>>>>>           Get Status_Help iItem To sStatus_Help
1804>>>>>>>>>           If ( sStatus_Help<>'' AND Shadow_State(Current_Object,iItem)) Begin
1806>>>>>>>>>              Get Shadow_Status_Help To sShadowed
1807>>>>>>>>>              Append sStatus_Help sShadowed
1808>>>>>>>>>           End
1808>>>>>>>>>>
1808>>>>>>>>>           If sStatus_Help ne '' Begin
1810>>>>>>>>>              Send Initialize_Menu to SbId
1811>>>>>>>>>              Send Show_Status_Help to SbId sStatus_Help
1812>>>>>>>>>           End
1812>>>>>>>>>>
1812>>>>>>>>>        End
1812>>>>>>>>>>
1812>>>>>>>>>     End_Procedure
1813>>>>>>>>>
1813>>>>>>>>>    Procedure Hide_Hint Integer iItem
1814>>>>>>>>>        Local Integer SbId
1815>>>>>>>>>        Delegate Get Statusbar_Id to SbId
1817>>>>>>>>>        If SbId Send Exit_Menu to SbId
1820>>>>>>>>>        Send OnHideHint iItem
1821>>>>>>>>>    End_Procedure
1822>>>>>>>>>
1822>>>>>>>>>End_Class
1823>>>>>>>>>
1823>>>>>>>>>
1823>>>>>>>>>// Mixin-Class: Standard_Object_Mixin
1823>>>>>>>>>//
1823>>>>>>>>>// 1. Define Help interface
1823>>>>>>>>>// 2. Define alternate switch logic
1823>>>>>>>>>// 3. Define Status bar help support
1823>>>>>>>>>//
1823>>>>>>>>>Class Standard_Object_Mixin Is A Mixin
1824>>>>>>>>>
1824>>>>>>>>>    Procedure Define_Standard_Object_Mixin
1825>>>>>>>>>        Send Define_RGB_Support_Temp_Mixin
1826>>>>>>>>>        Property Integer Switch_Skip_State Public False
1827>>>>>>>>>
1827>>>>>>>>>        Property String  Private.Status_Help      Public ''
1828>>>>>>>>>        //Property Integer Simple_Status_Help_State Public False
1828>>>>>>>>>        Property Integer Use_Parent_Status_Help  Public False
1829>>>>>>>>>        Property Integer Disable_Default_Action_Button_state public False
1830>>>>>>>>>        Send Define_Help_Mixin
1831>>>>>>>>>        //Send Define_Modal_Mixin
1831>>>>>>>>>    End_Procedure
1832>>>>>>>>>
1832>>>>>>>>>    Import_Class_Protocol RGB_Support_Temp_Mixin
1833>>>>>>>>>    Import_Class_Protocol Help_Mixin
1834>>>>>>>>>
1834>>>>>>>>>    Procedure Set Status_Help String Item# String Shelp
1835>>>>>>>>>        Set Private.Status_Help To Item#
1836>>>>>>>>>    End_Procedure
1837>>>>>>>>>
1837>>>>>>>>>    Function Status_Help Integer Item# Returns String
1838>>>>>>>>>        Local String Shelp
1839>>>>>>>>>        Get Private.Status_Help To Shelp
1840>>>>>>>>>        If (Shelp Eq '' And Use_Parent_Status_Help(Current_Object)) ;            Delegate Get Status_Help To Shelp
1844>>>>>>>>>        Function_Return Shelp
1845>>>>>>>>>    End_Function
1846>>>>>>>>>
1846>>>>>>>>>    // New Message
1846>>>>>>>>>    Procedure Switch_Next_Area
1847>>>>>>>>>        Send Switch
1848>>>>>>>>>    End_Procedure // Switch_Next_Area
1849>>>>>>>>>
1849>>>>>>>>>    // New Message
1849>>>>>>>>>    Procedure Switch_Prior_Area
1850>>>>>>>>>        Send Switch_Back
1851>>>>>>>>>    End_Procedure // Switch_Prior_Area
1852>>>>>>>>>
1852>>>>>>>>>    Procedure Request_Status_Help Integer Fg
1853>>>>>>>>>        Local String Sstatus_Help
1854>>>>>>>>>        Local Integer Sbid
1854>>>>>>>>>        If Fg Begin
1856>>>>>>>>>            Get Statusbar_Id To Sbid
1857>>>>>>>>>            If Not Sbid Procedure_Return
1860>>>>>>>>>            Get Status_Help To Sstatus_Help
1861>>>>>>>>>            Send Show_Status_Help To Sbid Sstatus_Help
1862>>>>>>>>>        End
1862>>>>>>>>>>
1862>>>>>>>>>    End_Procedure
1863>>>>>>>>>
1863>>>>>>>>>    // when the object takes the focus make sure that the default button, if any
1863>>>>>>>>>    // is highlighted. Note that buttons override this message and handle this
1863>>>>>>>>>    // a bit differently.
1863>>>>>>>>>    Procedure PrivateSetCurrentButton
1864>>>>>>>>>        local integer hoButton
1865>>>>>>>>>        If not (disable_default_action_button_state(current_object)) Begin
1867>>>>>>>>>            get Default_Action_Button to hoButton
1868>>>>>>>>>            if hoButton set CurrentButtonState of hoButton to TRUE
1871>>>>>>>>>        end
1871>>>>>>>>>>
1871>>>>>>>>>    end_Procedure
1872>>>>>>>>>
1872>>>>>>>>>    // when the object loses the focus the default button highlight must
1872>>>>>>>>>    // be removed - it will be restored, as needed, by the next object
1872>>>>>>>>>    // that takes the focus. If we do not do this, the button will not
1872>>>>>>>>>    // lose the highlight when switching between other panels and
1872>>>>>>>>>    // programs (and it should).
1872>>>>>>>>>    Procedure PrivateKillCurrentButton
1873>>>>>>>>>        local integer hoButton
1874>>>>>>>>>        get Current_Action_Button to hoButton
1875>>>>>>>>>        if hoButton set CurrentButtonState of hoButton to FALSE
1878>>>>>>>>>    end_Procedure
1879>>>>>>>>>
1879>>>>>>>>>    // this forces a reset of the default button....This should only be sent to this
1879>>>>>>>>>    // object when it is the focus object since it is the focus that determines
1879>>>>>>>>>    // what should or should not be highlighted.
1879>>>>>>>>>    Procedure doResetCurrentButton
1880>>>>>>>>>        Send PrivateKillCurrentButton
1881>>>>>>>>>        Send PrivateSetCurrentButton
1882>>>>>>>>>    End_Procedure
1883>>>>>>>>>
1883>>>>>>>>>    Procedure Notify_Focus_Change Integer Fg
1884>>>>>>>>>        //***Forward Send Notify_Focus_Change Fg
1884>>>>>>>>>        if Fg begin
1886>>>>>>>>>            Send OnSetFocus
1887>>>>>>>>>            send PrivateSetCurrentButton
1888>>>>>>>>>        end
1888>>>>>>>>>>
1888>>>>>>>>>        Else begin
1889>>>>>>>>>            send PrivateKillCurrentButton
1890>>>>>>>>>            Send OnKillFocus
1891>>>>>>>>>        end
1891>>>>>>>>>>
1891>>>>>>>>>        Send Request_Status_Help Fg
1892>>>>>>>>>    End_Procedure // Notify_Focus_Change
1893>>>>>>>>>
1893>>>>>>>>>    Procedure OnSetFocus
1894>>>>>>>>>    end_Procedure
1895>>>>>>>>>
1895>>>>>>>>>    Procedure OnKillFocus
1896>>>>>>>>>    end_Procedure
1897>>>>>>>>>
1897>>>>>>>>>    // dbLists now send this callback message. By adding this at this low
1897>>>>>>>>>    // level all objects can safely use prompt lists.
1897>>>>>>>>>    Procedure Prompt_Callback integer hPrompt
1898>>>>>>>>>    End_Procedure
1899>>>>>>>>>
1899>>>>>>>>>    // explicitly delegate so that current_object can be passed as a
1899>>>>>>>>>    // parameter without it getting changed. Current_object gets lost
1899>>>>>>>>>    // past 1 level of delegation. Panels that actually support this message will
1899>>>>>>>>>    // override this and make it do something useful.
1899>>>>>>>>>    Procedure Set Default_Action_Button Integer hoButton
1900>>>>>>>>>        delegate set Default_Action_Button to hoButton
1902>>>>>>>>>    End_Procedure
1903>>>>>>>>>
1903>>>>>>>>>
1903>>>>>>>>>End_Class
1904>>>>>>>>>
1904>>>>>>>>>// This is used to determine of Enter should next or nothing. By making
1904>>>>>>>>>// this a global a change will immediately affect all objects. At some
1904>>>>>>>>>// point this may become internal (with a public access).
1904>>>>>>>>>Integer gbKenterNext
1904>>>>>>>>>Move 0 to gbKenterNext
1905>>>>>>>>>
1905>>>>>>>>>// this gets mixed into "panel" classes (views, panels,
1905>>>>>>>>>// modal panels) and defines support for a default button. The only
1905>>>>>>>>>// public interface exposed for default buttons is:
1905>>>>>>>>>//  get/set default_action_button
1905>>>>>>>>>Class DefaultActionButton_Mixin Is A Mixin
1906>>>>>>>>>
1906>>>>>>>>>    Procedure Define_DefaultActionButton_Mixin
1907>>>>>>>>>        property integer private.Default_Action_Button public 0
1908>>>>>>>>>        property integer private.Current_Action_Button   public 0
1909>>>>>>>>>        on_key kEnter send Default_Action // this makes it easy to augment!
1910>>>>>>>>>    End_Procedure
1911>>>>>>>>>
1911>>>>>>>>>    Function Default_Action_Button Returns Integer
1912>>>>>>>>>        // we return object Id in the unlikely case that the object was deleted.
1912>>>>>>>>>        Function_Return (object_id(private.default_action_button(current_object)))
1913>>>>>>>>>    End_Function
1914>>>>>>>>>
1914>>>>>>>>>    Procedure Set Default_Action_Button Integer hoButton
1915>>>>>>>>>        local integer hFoc
1916>>>>>>>>>        set private.default_action_button to hoButton
1917>>>>>>>>>        // anytime the default button changes the highlighted button
1917>>>>>>>>>        // may or may not change. So we reset the action button just in case. This
1917>>>>>>>>>        // means that ALL objects must understand this message (which is mixed into
1917>>>>>>>>>        // standard object mixin).
1917>>>>>>>>>        get focus to hFoc
1918>>>>>>>>>        If hFoc gt desktop ;            send DoResetCurrentButton to hFoc
1921>>>>>>>>>    End_Procedure
1922>>>>>>>>>
1922>>>>>>>>>    // notice there is no Set for this. The set is private
1922>>>>>>>>>    Function Current_Action_Button Returns Integer
1923>>>>>>>>>        // we return object Id in the unlikely case that the object was deleted.
1923>>>>>>>>>        Function_Return (object_id(private.current_action_button(current_object)))
1924>>>>>>>>>    End_Function
1925>>>>>>>>>
1925>>>>>>>>>    Register_Procedure KeyAction
1925>>>>>>>>>    // called by kEnter. By default it should send the message
1925>>>>>>>>>    // KeyAction to the default button. If possible, avoid augmenting
1925>>>>>>>>>    // this ... change the Default_action_button property instead.
1925>>>>>>>>>    Procedure Default_Action
1926>>>>>>>>>        local integer hoButton iRetVal
1927>>>>>>>>>        get Current_Action_Button to hoButton
1928>>>>>>>>>        if hoButton Begin
1930>>>>>>>>>            Get msg_KeyAction of hoButton to iRetVal
1931>>>>>>>>>            Function_Return iRetVal
1932>>>>>>>>>        End
1932>>>>>>>>>>
1932>>>>>>>>>        else if gbKEnterNext ;            Send Next to (focus(current_object))
1936>>>>>>>>>    End_Procedure
1937>>>>>>>>>
1937>>>>>>>>>End_Class
1938>>>>>>>>>
1938>>>>>>>>>
1938>>>>>>>>>// Mixin-Class: Standard_Container_Mixin
1938>>>>>>>>>//
1938>>>>>>>>>//  1. Define standard object stuff
1938>>>>>>>>>//  2. Set default color
1938>>>>>>>>>//  3. Add Get/Set Label support
1938>>>>>>>>>//  (4. Auto-locate capability - not right now - only in deos)
1938>>>>>>>>>//  5. Add Modal object suppport
1938>>>>>>>>>//
1938>>>>>>>>>Class Standard_Container_Mixin Is A Mixin
1939>>>>>>>>>
1939>>>>>>>>>    Procedure Define_Standard_Container_Mixin
1940>>>>>>>>>        Send Define_Standard_Object_Mixin
1941>>>>>>>>>        //property integer Private.Object_color public 0
1941>>>>>>>>>        //Send Define_Modal_Mixin
1941>>>>>>>>>        Send Define_dfAuto_Locate
1942>>>>>>>>>        Set Object_Color To Wincolor_Windowtext Wincolor_Btnface
1943>>>>>>>>>
1943>>>>>>>>>        Send define_Shadow_Mixin
1944>>>>>>>>>        Send Define_Bitmap_Support_Mixin
1945>>>>>>>>>
1945>>>>>>>>>        Set Broadcast_Implicit_Shadow_State to True
1946>>>>>>>>>    End_Procedure
1947>>>>>>>>>
1947>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
1948>>>>>>>>>    //Import_Class_Protocol Modal_Mixin
1948>>>>>>>>>    Import_Class_Protocol Label_Mixin
1949>>>>>>>>>    Import_Class_Protocol dfAuto_Locate_Mixin
1950>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
1951>>>>>>>>>    Import_Class_Protocol Bitmap_Support_Mixin
1952>>>>>>>>>
1952>>>>>>>>>//    Procedure set object_color integer i1 integer i2
1952>>>>>>>>>//        if not (i1=0 and i2=0) set Private.Object_color to (i1*65536 + i2)
1952>>>>>>>>>//        forward set object_color i1 i2
1952>>>>>>>>>//    End_Procedure
1952>>>>>>>>>
1952>>>>>>>>>//    Function object_color Returns integer
1952>>>>>>>>>//        Function_Return (Private.Object_color(current_object))
1952>>>>>>>>>//    End_Function
1952>>>>>>>>>
1952>>>>>>>>>//    Procedure Notify_Focus_Change Integer Fg
1952>>>>>>>>>//        Forward Send Notify_Focus_Change Fg
1952>>>>>>>>>//        Send Request_Status_Help Fg
1952>>>>>>>>>//        if Fg Send Notify_Focus_On
1952>>>>>>>>>//        Else  Send Notify_Focus_Off
1952>>>>>>>>>//    End_Procedure // Notify_Focus_Change
1952>>>>>>>>>
1952>>>>>>>>>//    Procedure notify_focus_on
1952>>>>>>>>>//    end_Procedure
1952>>>>>>>>>
1952>>>>>>>>>//    Procedure notify_focus_off
1952>>>>>>>>>//    end_Procedure
1952>>>>>>>>>
1952>>>>>>>>>    Procedure Set Current_Shadow_State integer iState
1953>>>>>>>>>       Set Private.Shadow_State to iState
1954>>>>>>>>>    End_Procedure // Set Current_Shadow_State
1955>>>>>>>>>
1955>>>>>>>>>    Function Object_Shadow_State returns integer
1956>>>>>>>>>       Function_Return (Private.Shadow_State(Current_Object))
1957>>>>>>>>>    End_Function // Object_Shadow_State
1958>>>>>>>>>
1958>>>>>>>>>    Procedure End_Construct_Object
1959>>>>>>>>>       Forward Send End_Construct_Object
1961>>>>>>>>>       // if already shadowed by parent...do nothing. Else set changed
1961>>>>>>>>>       // state and broadcast to children
1961>>>>>>>>>       If (Explicit_Shadow_State(Current_Object) AND ;           Not(Implicit_Shadow_State(Current_Object)) AND ;           Broadcast_Implicit_Shadow_State(Current_Object) ) ;             Broadcast Set Implicit_Shadow_State to True
1965>>>>>>>>>    End_procedure
1966>>>>>>>>>
1966>>>>>>>>>    //Procedure Activating Returns Integer
1966>>>>>>>>>    //  local integer InvokingId RVal
1966>>>>>>>>>    //  Get Focus to InvokingId
1966>>>>>>>>>    //  forward get MSG_activating to rVal   //  This is the standard
1966>>>>>>>>>    //  If rVal Procedure_Return rVal        //  actionbr activating
1966>>>>>>>>>    //  If (Auto_Locate_State(Current_Object) ) ;
1966>>>>>>>>>    //     Send Auto_Locate InvokingId
1966>>>>>>>>>    //End_Procedure
1966>>>>>>>>>
1966>>>>>>>>>End_Class
1967>>>>>>>>>
1967>>>>>>>>>Class NonVisual_Container_Mixin is a Mixin
1968>>>>>>>>>
1968>>>>>>>>>   Function Object_Color returns integer
1969>>>>>>>>>     local integer rval
1970>>>>>>>>>     Delegate Get Object_color to rval
1972>>>>>>>>>     function_return rval
1973>>>>>>>>>   End_Function
1974>>>>>>>>>
1974>>>>>>>>>        Function Color Returns Integer
1975>>>>>>>>>            local integer rval
1976>>>>>>>>>            Delegate Get Color to rval
1978>>>>>>>>>            function_return rval
1979>>>>>>>>>        End_Function
1980>>>>>>>>>
1980>>>>>>>>>        Function TextColor Returns Integer
1981>>>>>>>>>            local integer rval
1982>>>>>>>>>            Delegate Get TextColor to rval
1984>>>>>>>>>            function_return rval
1985>>>>>>>>>        End_Function
1986>>>>>>>>>
1986>>>>>>>>>   Function Container_Handle Returns integer
1987>>>>>>>>>      Local Integer rVal
1988>>>>>>>>>      Delegate Get Container_Handle to rVal
1990>>>>>>>>>      Function_Return rVal
1991>>>>>>>>>   End_Function // Function
1992>>>>>>>>>
1992>>>>>>>>>   Procedure Page integer state
1993>>>>>>>>>   End_Procedure // Page
1994>>>>>>>>>
1994>>>>>>>>>   Procedure Page_Delete
1995>>>>>>>>>   End_Procedure // Page_Delete
1996>>>>>>>>>
1996>>>>>>>>>End_Class // NonVisual_Container_Mixin
1997>>>>>>>>>
1997>>>>>>>>>Class Panel_Mixin is a Mixin
1998>>>>>>>>>
1998>>>>>>>>>  Procedure Define_Panel_Mixin
1999>>>>>>>>>     Send Define_Modal_Mixin
2000>>>>>>>>>     Send Define_DefaultActionButton_Mixin
2001>>>>>>>>>  End_Procedure
2002>>>>>>>>>
2002>>>>>>>>>  Import_Class_Protocol Modal_Mixin
2003>>>>>>>>>  Import_Class_Protocol DefaultActionButton_Mixin
2004>>>>>>>>>
2004>>>>>>>>>  Procedure Exit_Application
2005>>>>>>>>>     If (Exit_Application_Local_State(Current_Object)) ;        Send Close_Panel
2008>>>>>>>>>     Else ;        Forward Send Exit_Application
2011>>>>>>>>>  End_Procedure // Exit_Application
2012>>>>>>>>>
2012>>>>>>>>>  Procedure Close_Panel
2013>>>>>>>>>     Send Deactivate
2014>>>>>>>>>  End_Procedure
2015>>>>>>>>>
2015>>>>>>>>>  Procedure OnResize
2016>>>>>>>>>  End_Procedure
2017>>>>>>>>>
2017>>>>>>>>>  Procedure OnPaint
2018>>>>>>>>>  End_Procedure
2019>>>>>>>>>
2019>>>>>>>>>  Procedure Set GuiSize Integer cy Integer cx
2020>>>>>>>>>      Local Integer cxy
2021>>>>>>>>>      Get GuiSize To cxy
2022>>>>>>>>>      Forward Set GuiSize to cy cx
2024>>>>>>>>>      If (BuildingObjectId=0 AND ;          Window_Handle(current_object) AND ;          ( Hi(cxy)<>cy or Low(cxy)<>cx) ) ;             Send OnResize
2027>>>>>>>>>  End_Procedure
2028>>>>>>>>>
2028>>>>>>>>>  Procedure Paint
2029>>>>>>>>>      Forward Send Paint
2031>>>>>>>>>      Send OnPaint
2032>>>>>>>>>  End_Procedure
2033>>>>>>>>>
2033>>>>>>>>>  Procedure Page Integer iState
2034>>>>>>>>>     Forward Send Page iState
2036>>>>>>>>>     If (iState =1) Send OnResize
2039>>>>>>>>>  End_Procedure
2040>>>>>>>>>
2040>>>>>>>>>End_Class
2041>>>>>>>>>
2041>>>>>>>>>//
2041>>>>>>>>>// Mixin-Class: Mask_Form_Mixin
2041>>>>>>>>>//
2041>>>>>>>>>String  Default_Currency_Mask Default_Numeric_Mask Default_Date_Mask
2041>>>>>>>>>Integer Default_Date_Window
2041>>>>>>>>>
2041>>>>>>>>>
2041>>>>>>>>>External_Function GetLocaleInfo "GetLocaleInfoA" Kernel32.dll ;    DWORD LCID DWORD LCTYPE POINTER lpLCDATA Integer cchData Returns Integer
2042>>>>>>>>>
2042>>>>>>>>>// get currency symbol from Windows
2042>>>>>>>>>Function Default_Currency_Symbol GLOBAL returns string
2043>>>>>>>>>    Local String sCurrency
2044>>>>>>>>>    Local Pointer lpCurrency
2044>>>>>>>>>    Local Integer iVal
2044>>>>>>>>>    Move (Repeat(character(0),20)) to sCurrency
2045>>>>>>>>>    GetAddress of sCurrency To lpCurrency
2046>>>>>>>>>    Move (GetLocaleInfo(LOCALE_USER_DEFAULT,LOCALE_SCURRENCY,lpCurrency,20)) to iVal
2047>>>>>>>>>    // currently our currency symbols do not handle periods ".", they should not
2047>>>>>>>>>    // be used in currency symbols. We will strip any periods that came through the
2047>>>>>>>>>    // windows currency symbol. This way the symbol will always be valid for VDF
2047>>>>>>>>>    function_return (replaces(".", CString(sCurrency), ""))
2048>>>>>>>>>end_Function
2049>>>>>>>>>
2049>>>>>>>>>Get Default_Currency_Symbol to Default_Currency_Mask
2050>>>>>>>>>// create default currency mask using windows currency symbol
2050>>>>>>>>>Move (Default_Currency_Mask + ",*;(" + Default_Currency_Mask + ",*)") to Default_Currency_Mask
2051>>>>>>>>>Move "*"         to Default_Numeric_Mask
2052>>>>>>>>>Move ''          to Default_Date_Mask
2053>>>>>>>>>Move DATE_WINDOW to Default_Date_Window
2054>>>>>>>>>
2054>>>>>>>>>Function Number_Default_Mask GLOBAL integer ldigits integer rpoints String DfltMask Returns string
2055>>>>>>>>>   local string MaskStr NumStr
2056>>>>>>>>>   If lDigits gt 0 ;      Move (Repeat("#",lDigits-1)+"0") to NumStr
2059>>>>>>>>>   If rPoints gt 0 ;      Move (NumStr+"."+(Repeat("0",rPoints))) to NumStr
2062>>>>>>>>>   Move (Replaces("*",DfltMask,NumStr)) to MaskStr
2063>>>>>>>>>   Function_Return MaskStr
2064>>>>>>>>>End_Function // Currency_Default_Mask
2065>>>>>>>>>
2065>>>>>>>>>Function Field_Number_Default_Mask GLOBAL integer file# integer field# string DfltMask
2066>>>>>>>>>   Local integer lDigit rDigit
2067>>>>>>>>>   Local string sMask
2067>>>>>>>>>   Get_Attribute DF_Field_Length of file# field# to lDigit
2070>>>>>>>>>   Get_Attribute DF_Field_Precision of file# field# to rDigit
2073>>>>>>>>>   If rDigit gt 0 Subtract rDigit from lDigit
2076>>>>>>>>>   Get Number_Default_Mask lDigit rDigit DfltMask to sMask
2077>>>>>>>>>   Function_return sMask
2078>>>>>>>>>End_Function
2079>>>>>>>>>
2079>>>>>>>>>Class Mask_Form_Mixin Is A Mixin
2080>>>>>>>>>
2080>>>>>>>>>// Must be in runtime!!!!
2080>>>>>>>>>//   Procedure Define_Mask_Form_Mixin
2080>>>>>>>>>//     Property Integer Form_Mask_Value_state public False
2080>>>>>>>>>//   End_Procedure
2080>>>>>>>>>
2080>>>>>>>>>
2080>>>>>>>>>   Procedure Set Private.Numeric_Mask integer item# integer MaskType ;                                      integer RightDigit integer leftDigit ;                                      string  DfltMask
2081>>>>>>>>>      Set Form_DataType item item# to MaskType
2082>>>>>>>>>      Set Form_Mask     item item# to ;                    (Number_Default_Mask(RightDigit,LeftDigit,DfltMask))
2083>>>>>>>>>      If LeftDigit gt 0 increment Leftdigit
2086>>>>>>>>>      Set Form_Margin item item# to (Rightdigit+LeftDigit)
2087>>>>>>>>>   End_procedure
2088>>>>>>>>>
2088>>>>>>>>>   Procedure Set Currency_Mask integer item# ;                               integer RightDigit integer leftDigit ;                               String  DfltMask
2089>>>>>>>>>      Local String sMask
2090>>>>>>>>>      If Num_Arguments Gt 3 ;         Move DfltMask to sMask
2093>>>>>>>>>      Else ;         Move Default_Currency_Mask to sMask
2095>>>>>>>>>      Set Private.Numeric_Mask item# to MASK_CURRENCY_WINDOW ;                                rightdigit leftdigit sMask
2096>>>>>>>>>   End_procedure
2097>>>>>>>>>
2097>>>>>>>>>   Procedure Set Numeric_Mask integer item# ;                              integer RightDigit integer leftDigit ;                              string  DfltMask
2098>>>>>>>>>      Local String sMask
2099>>>>>>>>>      If Num_Arguments Gt 3 ;         Move DfltMask to sMask
2102>>>>>>>>>      Else ;         Move Default_Numeric_Mask to sMask
2104>>>>>>>>>      Set Private.Numeric_Mask item# to MASK_NUMERIC_WINDOW ;                                rightdigit leftdigit sMask
2105>>>>>>>>>   End_procedure
2106>>>>>>>>>
2106>>>>>>>>>//   Procedure Set Form_DataType integer item# integer Type#
2106>>>>>>>>>//      If Type# eq Date_Window Begin
2106>>>>>>>>>//         Move Default_Date_Window  to type#
2106>>>>>>>>>//         If Type# ne Date_Window ;
2106>>>>>>>>>//            Set  Form_Mask item item# to Default_date_mask
2106>>>>>>>>>//      End
2106>>>>>>>>>//      Forward Set Form_DataType item item# to Type#
2106>>>>>>>>>//   End_Procedure
2106>>>>>>>>>
2106>>>>>>>>>// This must be in the runtime!!!!
2106>>>>>>>>>//     Function UnMasked_Value integer item# returns string
2106>>>>>>>>>//        Local string sVal
2106>>>>>>>>>//        Forward Get Value item item# to sVal
2106>>>>>>>>>//        Function_Return sVal
2106>>>>>>>>>//     End_Function
2106>>>>>>>>>//
2106>>>>>>>>>//     Function Value integer item# Returns String
2106>>>>>>>>>//        Local string sVal
2106>>>>>>>>>//        If (Form_Mask_Value_State(Current_Object,Item)) ;
2106>>>>>>>>>//          Get Masked_Value item item# to sVal
2106>>>>>>>>>//        Else ;
2106>>>>>>>>>//           Get UnMasked_Value item item# to sVal
2106>>>>>>>>>//        Function_Return sVal
2106>>>>>>>>>//     End_Function
2106>>>>>>>>>
2106>>>>>>>>>End_Class
2107>>>>>>>>>
2107>>>>>>>>>// Mixin-Class: Single_item_Navigate_Mixin
2107>>>>>>>>>//
2107>>>>>>>>>// This used by form and entry classes to handle the differences that
2107>>>>>>>>>// occur because DF thinks as a multi-item object and these are single item
2107>>>>>>>>>//
2107>>>>>>>>>//
2107>>>>>>>>>// 1. define alternate switch behavior for single items form and entry
2107>>>>>>>>>//
2107>>>>>>>>>Class Single_Item_Navigate_Mixin Is A Mixin
2108>>>>>>>>>
2108>>>>>>>>>    Procedure Define_Single_Item_Form_Navigation
2109>>>>>>>>>        On_Key Kswitch            Send Switch_Next_Area   Private
2110>>>>>>>>>        On_Key Kswitch_Back       Send Switch_Prior_Area  Private
2111>>>>>>>>>
2111>>>>>>>>>        // This will tell the object that it should switch/switch_back
2111>>>>>>>>>        // by skipping other dfentry_forms. The reason we made this a
2111>>>>>>>>>        // property is so it can be overridden. Switch_Next_area and
2111>>>>>>>>>        // Switch_Prior_area uses this.
2111>>>>>>>>>        //
2111>>>>>>>>>        Set Switch_Skip_State To True
2112>>>>>>>>>        Send Define_Shadow_Mixin
2113>>>>>>>>>    End_Procedure
2114>>>>>>>>>
2114>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
2115>>>>>>>>>
2115>>>>>>>>>    // The switch_next_area and switch_Prior_area messages are sent by the
2115>>>>>>>>>    // F6/Shift+F6 keys. Changes are made here to make a switch do something
2115>>>>>>>>>    // useful in entry_forms. The current goal is to make it act like the
2115>>>>>>>>>    // character mode product. We do this by making the switch skip all
2115>>>>>>>>>    // dfentry_forms until it hits a DEO that is not an entry-form. This
2115>>>>>>>>>    // changed behavior only occurs when switching FROM a dfentry_form
2115>>>>>>>>>    // TO another dfentry_form.
2115>>>>>>>>>    //
2115>>>>>>>>>    Procedure Switch_Next_Area
2116>>>>>>>>>        Local Integer Obj Ef Rval
2117>>>>>>>>>        // if there are multiple items in the form, treat it like a normal
2117>>>>>>>>>        // entry-form and do the normal switch message.
2117>>>>>>>>>        If (Item_Count(Current_Object)>1) Send Switch
2120>>>>>>>>>        Else Begin
2121>>>>>>>>>            Move Current_Object To Obj
2122>>>>>>>>>            Repeat
2122>>>>>>>>>>
2122>>>>>>>>>                Get Next_Object_Id Of Obj 0 To Obj // Normal Switch Behavior
2123>>>>>>>>>                // if no next object or we are back to this object....exit
2123>>>>>>>>>                If (Obj=0 Or Obj=current_Object) Procedure_Return
2126>>>>>>>>>                // Normally only dfentry_forms set skip_state true. So if we are
2126>>>>>>>>>                            // switching to another entry_form we will keep switching.
2126>>>>>>>>>                Get Switch_Skip_State Of Obj To Ef // If Ef False We Should Skip
2127>>>>>>>>>            Until Not Ef
2129>>>>>>>>>            Get Msg_Activate Of Obj To Rval // Try To Activate Object
2130>>>>>>>>>            // if we fail activation we want to do what switch normally does
2130>>>>>>>>>            // which is to keep trying to switch.
2130>>>>>>>>>            If Rval Send Switch To Obj // Send To Object That Didn'T Activate
2133>>>>>>>>>        End
2133>>>>>>>>>>
2133>>>>>>>>>
2133>>>>>>>>>    End_Procedure // Switch_Next_Area
2134>>>>>>>>>
2134>>>>>>>>>    Procedure Switch_Prior_Area  // See Comments In Switch_Next_Area
2135>>>>>>>>>        Local Integer Obj Ef Rval
2136>>>>>>>>>        If (Item_Count(Current_Object)>1) Send Switch_Back
2139>>>>>>>>>        Else Begin
2140>>>>>>>>>            Move Current_Object To Obj
2141>>>>>>>>>            Repeat
2141>>>>>>>>>>
2141>>>>>>>>>                Get Prior_Object_Id Of Obj 0 To Obj
2142>>>>>>>>>                If (Obj=0 Or Obj=current_Object) Procedure_Return
2145>>>>>>>>>                Get Switch_Skip_State Of Obj To Ef
2146>>>>>>>>>            Until Not Ef
2148>>>>>>>>>            Get Msg_Activate Of Obj To Rval
2149>>>>>>>>>            If Rval Send Switch_Back To Obj
2152>>>>>>>>>        End
2152>>>>>>>>>>
2152>>>>>>>>>    End_Procedure // Switch_Prior_Area
2153>>>>>>>>>
2153>>>>>>>>>    //  Navigational work-around. In single item objects previous does not
2153>>>>>>>>>    //  work when the previous item is displayonly (any shadow-state condition).
2153>>>>>>>>>    //  The previous key remains where it is. While next works, it does not
2153>>>>>>>>>    //  work well in that the NEXT is sent recursively - place enough display
2153>>>>>>>>>    //  only object together and the stack would overflow. Switch/Switch_back
2153>>>>>>>>>    //  will continue searching if the object's activation fails (activate,
2153>>>>>>>>>    //  entering or exiting). We will trigger entering to return a non-zero
2153>>>>>>>>>    //  value if 1) it was already going to do that, or 2) we've got a single
2153>>>>>>>>>    //  item object and that single item's shadow-state is set. This seems to
2153>>>>>>>>>    //  work.
2153>>>>>>>>>    //
2153>>>>>>>>>    Procedure Entering Returns Integer
2154>>>>>>>>>        Local Integer Rval
2155>>>>>>>>>        Forward Get Msg_Entering To Rval  // Do Normal Entering
2157>>>>>>>>>        // if entering is ok and single item check shadow state of that item.
2157>>>>>>>>>        If (Rval=0 And Item_Count(Current_Object)=1) ;            Get Shadow_State Item 0 To Rval
2160>>>>>>>>>        Procedure_Return Rval
2161>>>>>>>>>    End_Procedure
2162>>>>>>>>>
2162>>>>>>>>>End_Class
2163>>>>>>>>>
2163>>>>>>>>>
2163>>>>>>>>>
2163>>>>>>>>>// Mixin-Class: Standard_Form_Mixin - single item form mixin
2163>>>>>>>>>//
2163>>>>>>>>>//  1. Define standard object stuff
2163>>>>>>>>>//  2. Set default border to entry_field
2163>>>>>>>>>//  3. Add "Set Label" auto-label support
2163>>>>>>>>>//
2163>>>>>>>>>Class Standard_Form_Mixin Is A Mixin
2164>>>>>>>>>
2164>>>>>>>>>    Procedure Define_Standard_Form_Mixin
2165>>>>>>>>>        Send Define_Standard_Object_Mixin
2166>>>>>>>>>        Send Define_Dflabel_Mixin
2167>>>>>>>>>        Send Define_Single_Item_Form_Navigation
2168>>>>>>>>>        Send Define_FloatingPopupMenu_Mixin
2169>>>>>>>>>        //Send Define_Mask_form_Mixin
2169>>>>>>>>>    End_Procedure // Construct_Object
2170>>>>>>>>>
2170>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
2171>>>>>>>>>    Import_Class_Protocol Dflabel_Mixin
2172>>>>>>>>>    Import_Class_Protocol Single_Item_Navigate_Mixin
2173>>>>>>>>>    Import_Class_Protocol Mask_form_Mixin
2174>>>>>>>>>    Import_Class_Protocol FloatingPopupMenu_Mixin
2175>>>>>>>>>
2175>>>>>>>>>    Procedure Shadow_Display
2176>>>>>>>>>        Local Integer Clr Brdr State
2177>>>>>>>>>        Get Shadow_State to State
2178>>>>>>>>>            If State ;                Delegate Get Color To Clr
2182>>>>>>>>>            Else ;                Move clWindow To Clr
2184>>>>>>>>>            Set Color To Clr
2185>>>>>>>>>        Send Label_Shadow_Display
2186>>>>>>>>>    End_Procedure // Shadow_Display
2187>>>>>>>>>
2187>>>>>>>>>    Procedure OnMaxText
2188>>>>>>>>>    End_Procedure
2189>>>>>>>>>    Procedure OnChange
2190>>>>>>>>>    End_Procedure
2191>>>>>>>>>
2191>>>>>>>>>    Procedure Command Integer wParam Integer lParam
2192>>>>>>>>>        Forward Send Command wParam lParam
2194>>>>>>>>>        If (Hi(wParam)) eq EN_CHANGE Begin
2196>>>>>>>>>            Send OnChange
2197>>>>>>>>>        End
2197>>>>>>>>>>
2197>>>>>>>>>        Else If (Hi(wParam)) eq EN_MAXTEXT Begin
2200>>>>>>>>>            Send OnMaxText
2201>>>>>>>>>        End
2201>>>>>>>>>>
2201>>>>>>>>>    End_Procedure
2202>>>>>>>>>
2202>>>>>>>>>    Procedure Set Value Integer iItem String sValue
2203>>>>>>>>>        Forward Set Value item iItem To sValue
2205>>>>>>>>>        Send OnChange
2206>>>>>>>>>    End_Procedure
2207>>>>>>>>>
2207>>>>>>>>>End_Class
2208>>>>>>>>>
2208>>>>>>>>>
2208>>>>>>>>>
2208>>>>>>>>>// Mixin-Class: Standard_Grid_Mixin
2208>>>>>>>>>//
2208>>>>>>>>>//  1. Define standard object stuff
2208>>>>>>>>>//  2. Set default border to entry_field
2208>>>>>>>>>//  3. Add "Set formLabel" auto-label support
2208>>>>>>>>>//
2208>>>>>>>>>Class Standard_Grid_Mixin Is A Mixin
2209>>>>>>>>>
2209>>>>>>>>>    Procedure Define_Standard_Grid_Mixin
2210>>>>>>>>>        Send Define_Standard_Object_Mixin
2211>>>>>>>>>        Send Define_Multi_Item_Shadow_Mixin
2212>>>>>>>>>        Send Define_FloatingPopupMenu_Mixin
2213>>>>>>>>>        //Send Define_Mask_form_Mixin
2213>>>>>>>>>        Set Border_Style To Border_Clientedge
2214>>>>>>>>>
2214>>>>>>>>>        //Send Default_Color Set_Highlight_Row_Color Default_Highlight_Row_Color
2214>>>>>>>>>        //Send Default_Color Set_Current_Item_Color  Default_Current_Item_Color
2214>>>>>>>>>
2214>>>>>>>>>        // These are default RGB colors
2214>>>>>>>>>        Set Highlight_Row_Color to Default_Highlight_Row_Color
2215>>>>>>>>>        Set Current_Item_Color  to Default_Current_Item_Color
2216>>>>>>>>>
2216>>>>>>>>>        Set Gridline_Mode to Default_Table_Grid
2217>>>>>>>>>        Object Statushelp_Array Is An Array
2219>>>>>>>>>        End_Object
2220>>>>>>>>>        Set Line_Width to 1 0
2221>>>>>>>>>        Set Header_Label Item 0 to ""
2222>>>>>>>>>
2222>>>>>>>>>        // This should be of standard grid support.
2222>>>>>>>>>        on_key kBegin_of_Data Send Beginning_of_Data
2223>>>>>>>>>        on_key kEnd_of_Data   Send End_of_Data
2224>>>>>>>>>
2224>>>>>>>>>        // All in all, this probably is the best default
2224>>>>>>>>>        Set Auto_Top_Item_State to False
2225>>>>>>>>>    End_Procedure
2226>>>>>>>>>
2226>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
2227>>>>>>>>>    Import_Class_Protocol Multi_Item_Shadow_Mixin
2228>>>>>>>>>    Import_Class_Protocol Mask_form_Mixin
2229>>>>>>>>>    Import_Class_Protocol FloatingPopupMenu_Mixin
2230>>>>>>>>>    Import_Class_Protocol Auto_Setup_Mixin
2231>>>>>>>>>
2231>>>>>>>>>    Procedure Activate_Item Integer Item# Returns Integer
2232>>>>>>>>>        Local Integer Irval
2233>>>>>>>>>        Local Integer Ioldst
2233>>>>>>>>>        Get Auto_Top_Item_State To Ioldst
2234>>>>>>>>>        Set Auto_Top_Item_State To False
2235>>>>>>>>>        If (Focus(Desktop)<>current_Object) ;            Get Msg_Activate To Irval
2238>>>>>>>>>        Set Auto_Top_Item_State To Ioldst
2239>>>>>>>>>        If (Irval=0 And Current_Item(Current_Object)<>item#) Begin
2241>>>>>>>>>            Set Current_Item To Item#
2242>>>>>>>>>            Move (Current_Item(Current_Object)<>item#) To Irval
2243>>>>>>>>>        End
2243>>>>>>>>>>
2243>>>>>>>>>        Procedure_Return Irval
2244>>>>>>>>>    End_Procedure
2245>>>>>>>>>
2245>>>>>>>>>    Procedure Activate_Column Integer Item# Returns Integer
2246>>>>>>>>>        Local Integer Irval Citem Lwidth
2247>>>>>>>>>        Get Line_Size To Lwidth
2248>>>>>>>>>        Get Current_Item To Citem
2249>>>>>>>>>        // integer math will return first column of crnt row
2249>>>>>>>>>        Add (Citem/Lwidth*Lwidth) To Item#
2250>>>>>>>>>        Get Msg_Activate_Item Item# To Irval
2251>>>>>>>>>        Procedure_Return Irval
2252>>>>>>>>>    End_Procedure
2253>>>>>>>>>
2253>>>>>>>>>    Procedure Header_Mouse_Click Integer Item#
2254>>>>>>>>>        Local Integer Irval
2255>>>>>>>>>        Get Msg_Activate_Column Item# To Irval
2256>>>>>>>>>    End_Procedure
2257>>>>>>>>>
2257>>>>>>>>>    Procedure Header_Mouse_Double_Click Integer Item#
2258>>>>>>>>>    End_Procedure
2259>>>>>>>>>
2259>>>>>>>>>
2259>>>>>>>>>    Procedure Header_Notification Integer Mode Integer Item#
2260>>>>>>>>>        // This will force the button to pop out. This way it is right
2260>>>>>>>>>        // before a modal popup freezes it
2260>>>>>>>>>        Send release_mouse_capture
2261>>>>>>>>>
2261>>>>>>>>>        // This forces a new paint just on the header
2261>>>>>>>>>        set header_label item item# to (header_label(Current_Object,item#))
2262>>>>>>>>>
2262>>>>>>>>>        If Mode Eq Hd_Notify_Mouse_Click ;            Send Header_Mouse_Click Item#
2265>>>>>>>>>        If Mode Eq Hd_Notify_Mouse_Dblclick ;            Send Header_Mouse_Double_Click Item#
2268>>>>>>>>>    End_Procedure
2269>>>>>>>>>
2269>>>>>>>>>    Procedure Set Status_Help String Item# String Shelp
2270>>>>>>>>>        Set Value Of (Statushelp_Array(Current_Object)) Item Item# To Shelp
2271>>>>>>>>>    End_Procedure
2272>>>>>>>>>
2272>>>>>>>>>    Function Status_Help Integer Item# Returns String
2273>>>>>>>>>        Local String Shelp
2274>>>>>>>>>        Local Integer Lwidth
2274>>>>>>>>>        Local Integer Obj
2274>>>>>>>>>        Get Line_Size To Lwidth
2275>>>>>>>>>        // Integer Math Will Return First Column Of Crnt Row
2275>>>>>>>>>        If Lwidth Move (Mod(Item#,Lwidth)) To Item#
2278>>>>>>>>>        Move (Statushelp_Array(Current_Object)) To Obj
2279>>>>>>>>>        If (Item#<item_Count(Obj)) ;            Get Value Of Obj Item Item# To Shelp
2282>>>>>>>>>        If (Shelp Eq '' And Use_Parent_Status_Help(Current_Object)) ;            Delegate Get Status_Help To Shelp
2286>>>>>>>>>        Function_Return Shelp
2287>>>>>>>>>    End_Function
2288>>>>>>>>>
2288>>>>>>>>>    Procedure Request_Status_Help Integer Fg
2289>>>>>>>>>        Local String Sstatus_Help
2290>>>>>>>>>        Local Integer Sbid
2290>>>>>>>>>        If Fg Begin
2292>>>>>>>>>            Get Statusbar_Id To Sbid
2293>>>>>>>>>            If Not Sbid Procedure_Return
2296>>>>>>>>>            Get Status_Help Item (Current_Item(Current_Object)) To Sstatus_Help
2297>>>>>>>>>            Send Show_Status_Help To Sbid Sstatus_Help
2298>>>>>>>>>        End
2298>>>>>>>>>>
2298>>>>>>>>>    End_Procedure
2299>>>>>>>>>
2299>>>>>>>>>    Procedure OnChange integer iIitem
2300>>>>>>>>>    End_Procedure
2301>>>>>>>>>    Procedure OnMaxText
2302>>>>>>>>>    End_Procedure
2303>>>>>>>>>
2303>>>>>>>>>    Procedure Command Integer wParam Integer lParam
2304>>>>>>>>>        Forward Send Command wParam lParam
2306>>>>>>>>>        If (Hi(wParam)) eq EN_CHANGE Begin
2308>>>>>>>>>            Send OnChange (Current_Item(Current_Object))
2309>>>>>>>>>        End
2309>>>>>>>>>>
2309>>>>>>>>>        Else If (Hi(wParam)) eq EN_MAXTEXT Begin
2312>>>>>>>>>            Send OnMaxText
2313>>>>>>>>>        End
2313>>>>>>>>>>
2313>>>>>>>>>    End_Procedure
2314>>>>>>>>>
2314>>>>>>>>>    Procedure Set Value Integer iItem String sValue
2315>>>>>>>>>        Forward Set Value item iItem To sValue
2317>>>>>>>>>        Send OnChange iItem
2318>>>>>>>>>    End_Procedure
2319>>>>>>>>>
2319>>>>>>>>>    Procedure Set Form_Label integer iItem string svalue
2320>>>>>>>>>       Set Header_Label item iItem to sValue
2321>>>>>>>>>    End_Procedure // Set Form_Label
2322>>>>>>>>>
2322>>>>>>>>>
2322>>>>>>>>>    //  Set Current_Item / Set New_Item
2322>>>>>>>>>    //
2322>>>>>>>>>    // 1. Modified to optimize painting and make scrolling work properly
2322>>>>>>>>>    // 2. Add Request_Status_Help for item changes.
2322>>>>>>>>>    Procedure Set Current_Item Integer Itm
2323>>>>>>>>>       Local Integer IsFoc
2324>>>>>>>>>       local integer oldst oldtop
2324>>>>>>>>>       Move (Focus(Desktop)=Current_Object) to IsFoc
2325>>>>>>>>>       If IsFoc Send Request_Status_Help False
2328>>>>>>>>>       get dynamic_update_state to oldst
2329>>>>>>>>>       Set Dynamic_Update_State to False
2330>>>>>>>>>       get top_item             to oldtop // we need to know if to-item changes
2331>>>>>>>>>       Forward Set Current_Item to Itm
2333>>>>>>>>>       // If dyn had been on, we pass 1 (refresh all) if we scrolled and a
2333>>>>>>>>>       // 2 (refresh dirty cells) if we did not scroll. Note that other
2333>>>>>>>>>       // processes might have dirtied the cells so that a "2" becomes
2333>>>>>>>>>       // equivalent to a "1"
2333>>>>>>>>>       if oldst ; // if top_Item changed we scrolled!          Move (If(Top_Item(Current_Object)<>OldTop,1,2)) to OldSt
2336>>>>>>>>>       Set dynamic_update_State to OldSt
2337>>>>>>>>>       if IsFoc Send Request_Status_Help True
2340>>>>>>>>>    End_Procedure // Set Current_Item
2341>>>>>>>>>
2341>>>>>>>>>    Procedure Set New_Item Integer Itm
2342>>>>>>>>>       Local Integer IsFoc
2343>>>>>>>>>       local integer oldst oldtop
2343>>>>>>>>>       Move (Focus(Desktop)=Current_Object) to IsFoc
2344>>>>>>>>>       If IsFoc Send Request_Status_Help False
2347>>>>>>>>>       get dynamic_update_state to oldst
2348>>>>>>>>>       Set Dynamic_Update_State to False
2349>>>>>>>>>       get top_item             to oldtop // we need to know if to-item changes
2350>>>>>>>>>       Forward Set New_Item to Itm
2352>>>>>>>>>       // If dyn had been on, we pass 1 (refresh all) if we scrolled and a
2352>>>>>>>>>       // 2 (refresh dirty cells) if we did not scroll. Note that other
2352>>>>>>>>>       // processes might have dirtied the cells so that a "2" becomes
2352>>>>>>>>>       // equivalent to a "1"
2352>>>>>>>>>       if oldst ; // if top_Item changed we scrolled!          Move (If(Top_Item(Current_Object)<>OldTop,1,2)) to OldSt
2355>>>>>>>>>       Set dynamic_update_State to OldSt
2356>>>>>>>>>       if IsFoc Send Request_Status_Help True
2359>>>>>>>>>    End_Procedure // Set New_Item
2360>>>>>>>>>
2360>>>>>>>>>    // when active a grid does not repaint new items on the screen
2360>>>>>>>>>    // This forces a repaint when an item is added.
2360>>>>>>>>>    procedure add_item integer iMsg string sValue
2361>>>>>>>>>        local integer bOld
2362>>>>>>>>>        get dynamic_update_state to bOld
2363>>>>>>>>>        Set Dynamic_Update_State to False
2364>>>>>>>>>        forward send add_item iMsg sValue
2366>>>>>>>>>        Set dynamic_update_State to bOld
2367>>>>>>>>>    end_procedure
2368>>>>>>>>>
2368>>>>>>>>>    // Set Dynamic_Update_State
2368>>>>>>>>>    //
2368>>>>>>>>>    //  Modified to works as follows:
2368>>>>>>>>>    //     If 0, turn DUS off
2368>>>>>>>>>    //     If 1, Invalidate all cells and make it "2"
2368>>>>>>>>>    //     If 2, repaint only invalid cells plus scroll bars. Not Header
2368>>>>>>>>>    //     If 3, repaint everything (including headers)
2368>>>>>>>>>    //  When complete a 1,2 or 3 will set this property to 1.
2368>>>>>>>>>    //
2368>>>>>>>>>    Procedure Set Dynamic_Update_State integer st
2369>>>>>>>>>       If St eq 1 Begin
2371>>>>>>>>>          Send Scroll_Paint // this invalidates all cells
2372>>>>>>>>>          Move 2 to st      // Change state to only paint invalid cells
2373>>>>>>>>>       End                  // plus scroll bars
2373>>>>>>>>>>
2373>>>>>>>>>       else ;          If St eq 3 Move 1 to st // if 3, repaint EVERYTHING
2377>>>>>>>>>       // runtime understands 0,1,2. If 2, final prop value will be 1
2377>>>>>>>>>       Forward Set Dynamic_Update_State to st
2379>>>>>>>>>    End_Procedure // Set Dynamic_Update_State
2380>>>>>>>>>
2380>>>>>>>>>    // Return the column of the passed item
2380>>>>>>>>>    Function Column Integer Item# returns Integer
2381>>>>>>>>>       Function_Return (Mod(Item#,Line_Size(Current_Object)))
2382>>>>>>>>>    End_Function
2383>>>>>>>>>
2383>>>>>>>>>    // Return the column of the current-item
2383>>>>>>>>>    Function Current_Col Returns Integer
2384>>>>>>>>>      Function_Return (Column(Current_Object,Current_Item(Current_Object)))
2385>>>>>>>>>    End_Function
2386>>>>>>>>>
2386>>>>>>>>>    // Support for Beginning_of_Data and End_of_Data
2386>>>>>>>>>    // Note that these messsages are Column sensitive. They do not
2386>>>>>>>>>    // switch columns.
2386>>>>>>>>>
2386>>>>>>>>>
2386>>>>>>>>>    // Jump to the first column
2386>>>>>>>>>    Procedure beginning_of_Data
2387>>>>>>>>>       set current_item to (Current_Col(Current_Object))
2388>>>>>>>>>    End_Procedure // beginning_of_Data
2389>>>>>>>>>
2389>>>>>>>>>    // jump to the last column
2389>>>>>>>>>    Procedure end_of_data
2390>>>>>>>>>       local integer col cols itmCnt
2391>>>>>>>>>       get line_size   to cols        // columns in a row
2392>>>>>>>>>       Get Current_col to col         // the current column of the item
2393>>>>>>>>>       get item_count  to itmCnt
2394>>>>>>>>>       decrement ItmCnt
2395>>>>>>>>>       // Integer math at work.
2395>>>>>>>>>       move ( (ItmCnt/cols)*cols+col) to col // column in last row
2396>>>>>>>>>       // if we had a case where the last item was not in the last column
2396>>>>>>>>>       // we could get an error. While unlikely we we check for this.
2396>>>>>>>>>       set current_item to (itmCnt min col)
2397>>>>>>>>>    End_Procedure // end_of_data
2398>>>>>>>>>
2398>>>>>>>>>    // Scroll
2398>>>>>>>>>    // 1. Is column sensitive. It will never scroll out of the
2398>>>>>>>>>    //    current column
2398>>>>>>>>>    // 2. Painting fixes and optimizations - no flickering
2398>>>>>>>>>    procedure scroll integer dir integer dist
2399>>>>>>>>>       local integer oldst oldtop itm cols col col2 st items
2400>>>>>>>>>       Get Current_Item     to Itm       // current item
2401>>>>>>>>>       Get Line_Size        to cols      // number of columns
2402>>>>>>>>>       If Dist eq 0 ;                    // if dist is not passed,          Get Displayable_Rows to Items  // use # displayable rows
2405>>>>>>>>>       Else Move Dist to Items
2407>>>>>>>>>       Move (Items * Cols) to Items      // number of items we are scrolling
2408>>>>>>>>>
2408>>>>>>>>>       // If we are at the end of the list jump to the last column
2408>>>>>>>>>       // Else if we are at the top of the list, jump to the first column
2408>>>>>>>>>       // Else do a normal scroll
2408>>>>>>>>>
2408>>>>>>>>>       // We do this because the runtime scroll at the end of a page
2408>>>>>>>>>       // may change columns which forces a complete repaint.
2408>>>>>>>>>       if (dir=DOWNWARD_DIRECTION AND (Itm+Items>Item_Count(Current_Object)) ) ;          Send end_of_data
2411>>>>>>>>>       Else If (dir=UPWARD_DIRECTION AND (Itm-Items<0) ) ;          Send Beginning_of_data
2415>>>>>>>>>       Else Begin
2416>>>>>>>>>          // This will always involve a top_item change. So we will shut
2416>>>>>>>>>          // off dynamic update and turn it back on with a 1 (which means
2416>>>>>>>>>          // first invalidate all cells)
2416>>>>>>>>>          get dynamic_update_state to oldst
2417>>>>>>>>>          Set Dynamic_Update_State to false
2418>>>>>>>>>          Forward Send scroll dir dist       // normal scroll
2420>>>>>>>>>          Set dynamic_update_State to OldSt
2421>>>>>>>>>       End
2421>>>>>>>>>>
2421>>>>>>>>>    End_Procedure
2422>>>>>>>>>
2422>>>>>>>>>    // Bug Fix. Focus change to object does not send notify_focus_change.
2422>>>>>>>>>    // This will force this (which also forces onSetFocus)
2422>>>>>>>>>    //
2422>>>>>>>>>    Procedure set focus integer hwNewFoc integer hwOldFoc
2423>>>>>>>>>       Forward Set focus to hwNewFoc hwOldFoc
2425>>>>>>>>>       Send Notify_Focus_Change True
2426>>>>>>>>>    end_procedure
2427>>>>>>>>>
2427>>>>>>>>>    // This fixes a bug in grids where activating a grid whose
2427>>>>>>>>>    // item's entry_state is false does not display the dotted outline
2427>>>>>>>>>    // if the item is not changed (set current_item not called). This is
2427>>>>>>>>>    // a temporary workaround that should be removed as soon as this is
2427>>>>>>>>>    // fixed in the runtime. We want to use base class new_item message
2427>>>>>>>>>    // which paints the rectangle but does little else. Note the use of
2427>>>>>>>>>    // forward send (a technique which is only used as a low level bug
2427>>>>>>>>>    // fix.
2427>>>>>>>>>    // NOTE: This replaces the activate in Shadow_mixin. When this is fixed
2427>>>>>>>>>    //       this can be removed. (it duplicates the shadow activate purpose)
2427>>>>>>>>>    Procedure Activate returns integer
2428>>>>>>>>>       Local integer rVal itm
2429>>>>>>>>>       If (active_state(Current_Object) AND Object_Shadow_State(Current_Object)) ;           Move 1 to rVal
2432>>>>>>>>>       Else Begin
2433>>>>>>>>>           Forward Get MSG_Activate to rVal
2435>>>>>>>>>           If (Rval=0 and item_count(Current_Object)) Begin
2437>>>>>>>>>               // if activate is ok and we've got items and entry-state
2437>>>>>>>>>               // of the current item is false, force the repaint.
2437>>>>>>>>>               get current_item to itm
2438>>>>>>>>>               if not (entry_state(current_object,itm)) ;                  FORWARD set new_item to itm // !!!!!!! FORWARD !!!!!!!!!
2442>>>>>>>>>           End
2442>>>>>>>>>>
2442>>>>>>>>>       End
2442>>>>>>>>>>
2442>>>>>>>>>       Procedure_Return rVal
2443>>>>>>>>>    End_Procedure // Activate
2444>>>>>>>>>
2444>>>>>>>>>    // Thsis stops unneeded focus change and item change
2444>>>>>>>>>    // cascades. If dragging within an item, just let
2444>>>>>>>>>    // windows do all the work. This reduces flickering.
2444>>>>>>>>>    procedure mouse_drag integer iWin integer i2
2445>>>>>>>>>        local integer iItem
2446>>>>>>>>>        // get actual item
2446>>>>>>>>>        Move (top_item(Current_object)+iWin-1) to iItem
2447>>>>>>>>>        // if focus changed or item change needed, do standard drag
2447>>>>>>>>>        if (focus(desktop)<>Current_object OR current_item(Current_object)<>iItem) ;            forward send mouse_drag iWin i2
2451>>>>>>>>>        else ; // else just let windows do the work            set windows_override_state to false
2453>>>>>>>>>    end_procedure
2454>>>>>>>>>
2454>>>>>>>>>End_Class
2455>>>>>>>>>
2455>>>>>>>>>Class Select_Mixin Is A Mixin
2456>>>>>>>>>
2456>>>>>>>>>    Procedure Define_Select_Mixin
2457>>>>>>>>>        Property Integer Auto_Size_State Public True
2458>>>>>>>>>    End_Procedure
2459>>>>>>>>>
2459>>>>>>>>>    //***
2459>>>>>>>>>    //*** Property: Label
2459>>>>>>>>>    //*** Purpose : Compatibility DAF
2459>>>>>>>>>    //***
2459>>>>>>>>>    Procedure Set Label String Val
2460>>>>>>>>>        If (Auto_Size_State(Current_Object)) Send Autosize Val
2463>>>>>>>>>        Set Value Item 0 To Val
2464>>>>>>>>>    End_Procedure // Set Label
2465>>>>>>>>>
2465>>>>>>>>>    Function Label Returns String
2466>>>>>>>>>        Function_Return (Value(Current_Object,0))
2467>>>>>>>>>    End_Function // Label
2468>>>>>>>>>
2468>>>>>>>>>    //***
2468>>>>>>>>>    //*** Procedure: AutoSize
2468>>>>>>>>>    //*** Purpose  : This procedure will calculate the size needed to display
2468>>>>>>>>>    //***            the label of the object. It will set the size accordingly.
2468>>>>>>>>>    //***
2468>>>>>>>>>
2468>>>>>>>>>    Procedure Autosize String Val
2469>>>>>>>>>        Local Integer Label_Size
2470>>>>>>>>>        If Val ne  "" Begin
2472>>>>>>>>>            // Spy 01/11/98 Find the Extension of the label based on
2472>>>>>>>>>            // the Ansi value of the string. This seems to work right
2472>>>>>>>>>            //Get Text_Extent Val To Label_Size //The Old Code
2472>>>>>>>>>            Get Text_Extent (ToAnsi(Val)) To Label_Size
2473>>>>>>>>>            Set Guisize To (Hi(Label_Size) + 3) (Low(Label_Size) + 25)
2474>>>>>>>>>            Send Adjust_logicals
2475>>>>>>>>>        End
2475>>>>>>>>>>
2475>>>>>>>>>    End_Procedure // Autosize
2476>>>>>>>>>
2476>>>>>>>>>    Procedure OnChange
2477>>>>>>>>>    End_Procedure
2478>>>>>>>>>
2478>>>>>>>>>    Function Checked_State Returns Integer
2479>>>>>>>>>        Function_Return (Select_State(current_object,0))
2480>>>>>>>>>    End_Function
2481>>>>>>>>>
2481>>>>>>>>>    Procedure Set Checked_State Integer bCheck
2482>>>>>>>>>        Set Select_State item 0 To bCheck
2483>>>>>>>>>    End_Procedure
2484>>>>>>>>>
2484>>>>>>>>>    Procedure Set Select_State Integer iItem Integer bSelect
2485>>>>>>>>>        Forward Set Select_State item iItem To bSelect
2487>>>>>>>>>        Send OnChange
2488>>>>>>>>>    End_Procedure
2489>>>>>>>>>
2489>>>>>>>>>End_Class // Select_Mixin
2490>>>>>>>>>
2490>>>>>>>>>
2490>>>>>>>>>//*** Mixin class: Standard_select_mixin
2490>>>>>>>>>//***
2490>>>>>>>>>//*** 1. Standard messages used by select type objects (radios & checkboxes)
2490>>>>>>>>>//
2490>>>>>>>>>Class Standard_Select_Mixin Is A Mixin
2491>>>>>>>>>
2491>>>>>>>>>    Procedure Define_Standard_Select_Mixin
2492>>>>>>>>>        Send Define_Standard_Object_Mixin
2493>>>>>>>>>        Send Define_Single_Item_Form_Navigation
2494>>>>>>>>>        Send Define_Select_Mixin
2495>>>>>>>>>        Set Object_Color To 0 Wincolor_Btnface
2496>>>>>>>>>    End_Procedure
2497>>>>>>>>>
2497>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
2498>>>>>>>>>    Import_Class_Protocol Single_Item_Navigate_Mixin
2499>>>>>>>>>    Import_Class_Protocol Select_Mixin
2500>>>>>>>>>
2500>>>>>>>>>End_Class // Standard_Select_Mixin
2501>>>>>>>>>
2501>>>>>>>>>
2501>>>>>>>>>// Class: Edit
2501>>>>>>>>>//
2501>>>>>>>>>//  1. Add Standard entry support
2501>>>>>>>>>//
2501>>>>>>>>>Class Edit Is A DfBaseEdit
2502>>>>>>>>>
2502>>>>>>>>>    Procedure Construct_Object
2503>>>>>>>>>        Forward Send Construct_Object
2505>>>>>>>>>        Send Define_Standard_Object_Mixin
2506>>>>>>>>>        Send Define_Dflabel_Mixin
2507>>>>>>>>>        Set Label_Offset To 1 0
2508>>>>>>>>>        Set Label_Justification_Mode To Jmode_Top
2509>>>>>>>>>        // should edit wrap or not
2509>>>>>>>>>        Property Integer Private.Wrap_state Public True
2510>>>>>>>>>        Property Integer m_Capslock_state Public False
2511>>>>>>>>>        On_key key_Ctrl+Key_W Send Toggle_Wrap
2512>>>>>>>>>
2512>>>>>>>>>        Send Define_Shadow_Mixin
2513>>>>>>>>>        on_key kenter send default_key
2514>>>>>>>>>        Set Disable_default_action_button_state to True
2515>>>>>>>>>        set file_name to ""
2516>>>>>>>>>    End_Procedure // Construct_Object
2517>>>>>>>>>
2517>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
2518>>>>>>>>>    Import_Class_Protocol Dflabel_Mixin
2519>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
2520>>>>>>>>>
2520>>>>>>>>>    procedure Set Wrap_State Integer State
2521>>>>>>>>>        Local integer hndl Foc
2522>>>>>>>>>        Set Private.Wrap_State to State
2523>>>>>>>>>        Get Window_Handle to Hndl
2524>>>>>>>>>        If Hndl Begin
2526>>>>>>>>>          Get Focus to Foc
2527>>>>>>>>>          Send Page_Object False
2528>>>>>>>>>          Set window_style to ws_hscroll (not(state))
2529>>>>>>>>>          Send Page_Object True
2530>>>>>>>>>          If Foc eq Current_Object Send Activate
2533>>>>>>>>>        End
2533>>>>>>>>>>
2533>>>>>>>>>        Else ;          Set window_style to ws_hscroll (not(state))
2535>>>>>>>>>    End_procedure
2536>>>>>>>>>
2536>>>>>>>>>    Function Wrap_State returns integer
2537>>>>>>>>>       Function_Return (Private.Wrap_State(Current_Object))
2538>>>>>>>>>    End_Function // Wrap_State
2539>>>>>>>>>
2539>>>>>>>>>    Procedure Toggle_Wrap
2540>>>>>>>>>       Set Wrap_State to (Not(Wrap_state(Current_Object)))
2541>>>>>>>>>    End_Procedure
2542>>>>>>>>>
2542>>>>>>>>>    // If font changes the edit size stays the same. This make the most
2542>>>>>>>>>    // sense.
2542>>>>>>>>>    Function Parent_ratios returns integer
2543>>>>>>>>>       Function_return (map_ratios(parent(Current_Object)))
2544>>>>>>>>>    End_Function // Parent_ratios
2545>>>>>>>>>
2545>>>>>>>>>    Procedure Set Current_Shadow_State integer iState
2546>>>>>>>>>       Set Private.Shadow_State to iState
2547>>>>>>>>>    End_Procedure // Set Object_Shadow_State
2548>>>>>>>>>
2548>>>>>>>>>    Function Object_Shadow_State returns integer
2549>>>>>>>>>       Function_Return (Private.Shadow_State(Current_Object))
2550>>>>>>>>>    End_Function // Object_Shadow_State
2551>>>>>>>>>
2551>>>>>>>>>    Procedure Shadow_Display
2552>>>>>>>>>        Local Integer Clr Brdr State
2553>>>>>>>>>        Get Object_Shadow_State to State
2554>>>>>>>>>            If State ;                Delegate Get Color To Clr
2558>>>>>>>>>            Else ;                Move clWindow To Clr
2560>>>>>>>>>            Set Color To Clr
2561>>>>>>>>>        Send Label_Shadow_Display
2562>>>>>>>>>    End_Procedure // Shadow_Display
2563>>>>>>>>>
2563>>>>>>>>>    Procedure Set Item_Shadow_State integer iItem integer iState
2564>>>>>>>>>    End_Procedure // Set Item_Shadow_State
2565>>>>>>>>>
2565>>>>>>>>>    Function Item_Shadow_State integer iItem Returns integer
2566>>>>>>>>>    End_Function // Item_Shadow_State
2567>>>>>>>>>
2567>>>>>>>>>    Procedure OnChange
2568>>>>>>>>>    End_Procedure
2569>>>>>>>>>
2569>>>>>>>>>    Procedure OnMaxText
2570>>>>>>>>>    End_Procedure
2571>>>>>>>>>
2571>>>>>>>>>    Procedure Command Integer wParam Integer lParam
2572>>>>>>>>>        Forward Send Command wParam lParam
2574>>>>>>>>>        If (Hi(wParam)) eq EN_CHANGE Begin
2576>>>>>>>>>            Send OnChange
2577>>>>>>>>>        End
2577>>>>>>>>>>
2577>>>>>>>>>        If (Hi(wParam)) eq EN_MAXTEXT Begin
2579>>>>>>>>>            Send OnMaxText
2580>>>>>>>>>        End
2580>>>>>>>>>>
2580>>>>>>>>>    End_Procedure
2581>>>>>>>>>
2581>>>>>>>>>    Procedure Set Value Integer iItem String sValue
2582>>>>>>>>>        Forward Set Value item iItem To sValue
2584>>>>>>>>>        Send OnChange
2585>>>>>>>>>    End_Procedure
2586>>>>>>>>>
2586>>>>>>>>>    // Get and Set capslock and set windows style to make it work
2586>>>>>>>>>    procedure Set Capslock_State Integer bState
2587>>>>>>>>>        Set m_CapsLock_State to bState
2588>>>>>>>>>        Set window_style to ES_UPPERCASE bState
2589>>>>>>>>>    End_procedure
2590>>>>>>>>>
2590>>>>>>>>>    Function CapsLock_State returns integer
2591>>>>>>>>>       Function_Return (m_Capslock_State(Current_Object))
2592>>>>>>>>>    End_Function // Wrap_State
2593>>>>>>>>>
2593>>>>>>>>>    Procedure set read_only_state integer bState
2594>>>>>>>>>        if (bState<>read_only_state(current_object)) Begin
2596>>>>>>>>>          if not bState on_key kenter send default_key
2599>>>>>>>>>          else          on_key kEnter send default_action
2601>>>>>>>>>          Set disable_default_action_button_state to (not(bState))
2602>>>>>>>>>       end
2602>>>>>>>>>>
2602>>>>>>>>>       forward set read_only_state to bstate
2604>>>>>>>>>       // Must set windows style. (s/b moved to C at some point)
2604>>>>>>>>>       Set Window_Style To ES_READONLY bState
2605>>>>>>>>>    End_Procedure
2606>>>>>>>>>
2606>>>>>>>>>    // Base class does not clear changed_state. Also augment to send OnChange
2606>>>>>>>>>    procedure delete_data
2607>>>>>>>>>        forward send delete_data
2609>>>>>>>>>        set changed_state to false
2610>>>>>>>>>        Send OnChange
2611>>>>>>>>>    end_procedure
2612>>>>>>>>>
2612>>>>>>>>>End_Class
2613>>>>>>>>>
2613>>>>>>>>>// Class: List
2613>>>>>>>>>//
2613>>>>>>>>>//  1. Add Standard entry support
2613>>>>>>>>>//
2613>>>>>>>>>Class List Is A DFBaseListBox
2614>>>>>>>>>
2614>>>>>>>>>    Procedure Construct_Object
2615>>>>>>>>>        Forward Send Construct_Object
2617>>>>>>>>>        Send Define_Standard_Object_Mixin
2618>>>>>>>>>        Send Define_Dflabel_Mixin
2619>>>>>>>>>        Set Border_Style To Border_Clientedge
2620>>>>>>>>>        Send Define_Multi_Item_Shadow_Mixin
2621>>>>>>>>>    End_Procedure // Construct_Object
2622>>>>>>>>>
2622>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
2623>>>>>>>>>    Import_Class_Protocol Dflabel_Mixin
2624>>>>>>>>>    Import_Class_Protocol Multi_Item_Shadow_Mixin
2625>>>>>>>>>
2625>>>>>>>>>    Procedure OnChange
2626>>>>>>>>>    End_Procedure
2627>>>>>>>>>
2627>>>>>>>>>    Procedure Set Current_Item Integer iItem
2628>>>>>>>>>        Local Integer iLastItem
2629>>>>>>>>>        Get Current_Item To iLastItem
2630>>>>>>>>>        Forward Set Current_Item To iItem
2632>>>>>>>>>        If (iItem <> iLastItem) Send OnChange
2635>>>>>>>>>    End_Procedure
2636>>>>>>>>>
2636>>>>>>>>>    // The following procedures should be moved to C code. This resolves
2636>>>>>>>>>    // certain issues with mapping DF list controls to windows controls.
2636>>>>>>>>>    // Users are encouraged to only use two modes of list selection:
2636>>>>>>>>>    //     select_mode = MULTI_SELECT | SINGLE_SELECT
2636>>>>>>>>>    // DO NOT use NO_Select - it won't work right.
2636>>>>>>>>>    //
2636>>>>>>>>>    // Special functionality to Note:
2636>>>>>>>>>    //
2636>>>>>>>>>    // 1.  Set Select_Count to TRUE : If multi-select sets all select-states to TRUE
2636>>>>>>>>>    //                            if single-select sets current item to TRUE
2636>>>>>>>>>    //   Set Select_Count to FALSE: Sets all items to false
2636>>>>>>>>>    //
2636>>>>>>>>>    // 2. Space bar no Longer toggles select state. If you want this. Create the following:
2636>>>>>>>>>    //      on_key key_space send toggle_Current_item
2636>>>>>>>>>    //
2636>>>>>>>>>    // 3. There is no message that is fired every time the select-state changes.
2636>>>>>>>>>    //
2636>>>>>>>>>    // 4. There is no message that ALWAYS gets sent when an object's select_state is
2636>>>>>>>>>    //    toggled (e.g. marking range via shift+mouse). Do not use set select_state or
2636>>>>>>>>>    //    item_changed_state for multi-select augmentations. With single select lists
2636>>>>>>>>>    //    you CAN use set current_item or set Select_State
2636>>>>>>>>>
2636>>>>>>>>>    // when paging non-multi lists the select-state item is lost. This fixes this
2636>>>>>>>>>    procedure page integer bState
2637>>>>>>>>>        local integer iCur bSel
2638>>>>>>>>>        get current_item to iCur
2639>>>>>>>>>        If (item_count(current_object)) begin
2641>>>>>>>>>            get select_state item iCur to bSel   // remember what it was
2642>>>>>>>>>            forward send page bState // if single select, select state will be lost
2644>>>>>>>>>            // if paged, and non multi-select and the current item was selected, then
2644>>>>>>>>>            // set select_state again to force it to be correct.
2644>>>>>>>>>            If (bSel and window_handle(Current_object) AND select_mode(Current_object)<>MULTI_SELECT) ;                set select_state item iCur to TRUE // reinstae what was
2647>>>>>>>>>        end
2647>>>>>>>>>>
2647>>>>>>>>>        else forward send page bState
2650>>>>>>>>>    end_procedure
2651>>>>>>>>>
2651>>>>>>>>>    // Set Select_Count is supposed to clear or select all items. This fixes
2651>>>>>>>>>    // it to do the following:
2651>>>>>>>>>    //   If F               - clear all selected items
2651>>>>>>>>>    //   if T and Multi     - Select all items
2651>>>>>>>>>    //   If T and not Multi - Set select-state of current item to True
2651>>>>>>>>>    //
2651>>>>>>>>>    Procedure set select_count integer bState
2652>>>>>>>>>        local integer i iCnt
2653>>>>>>>>>        get item_count to iCnt
2654>>>>>>>>>        // if true and single item. Just set the one item
2654>>>>>>>>>        if (bState and iCnt and select_mode(Current_object)<>MULTI_SELECT) ;           set select_state item (current_item(Current_object)) to true
2657>>>>>>>>>        else begin
2658>>>>>>>>>            decrement iCnt
2659>>>>>>>>>            For i from 0 to iCnt
2665>>>>>>>>>>
2665>>>>>>>>>                set select_state item i to bState
2666>>>>>>>>>            loop
2667>>>>>>>>>>
2667>>>>>>>>>        end
2667>>>>>>>>>>
2667>>>>>>>>>    end_procedure
2668>>>>>>>>>
2668>>>>>>>>>    // The internal Select_Count gets hopelessly out of synch with the
2668>>>>>>>>>    // select count in the windows control. Here is what we must do:
2668>>>>>>>>>    // 1. If no-window control -find the count the hard way. Count them!
2668>>>>>>>>>    // 2. If window control and Multi select: Forward get count
2668>>>>>>>>>    //                 this works because when paged, DF just gets the LB_SELCOUNT property
2668>>>>>>>>>    //                 which is right)
2668>>>>>>>>>    // 3. If window control and not multi: Will either be 0 or 1. Check current_item to
2668>>>>>>>>>    //                 see if it is selected. We can't use LB_SELCOUNT because it returns -1
2668>>>>>>>>>    function Select_count returns integer
2669>>>>>>>>>        local integer iCnt i iSel
2670>>>>>>>>>        get item_count to iCnt
2671>>>>>>>>>        if (window_handle(Current_object)) begin
2673>>>>>>>>>            if (select_mode(Current_object)=MULTI_SELECT) ;                forward get select_count to iSel
2677>>>>>>>>>            else if iCnt ;                Move (if(Select_state(Current_object,current_item(Current_object)),1,0)) to iSel
2681>>>>>>>>>        end
2681>>>>>>>>>>
2681>>>>>>>>>        else Begin
2682>>>>>>>>>            decrement iCnt
2683>>>>>>>>>            For i from 0 to iCnt
2689>>>>>>>>>>
2689>>>>>>>>>                If (select_state(Current_object,i)) increment iSel
2692>>>>>>>>>            loop
2693>>>>>>>>>>
2693>>>>>>>>>        end
2693>>>>>>>>>>
2693>>>>>>>>>        function_return iSel
2694>>>>>>>>>    end_function
2695>>>>>>>>>
2695>>>>>>>>>    // Select-state is somewhat flawed when using single select lists.
2695>>>>>>>>>    // When the list is not paged or it is multi select it is fine.
2695>>>>>>>>>    // When single, the only way to get the item selected is to set
2695>>>>>>>>>    // its current_item. The only way to clear a selected item is to
2695>>>>>>>>>    // send the windows message LB_SERCURSEL
2695>>>>>>>>>    //
2695>>>>>>>>>    procedure set select_state integer iItm integer bSt
2696>>>>>>>>>        local integer cnt i sc
2697>>>>>>>>>        // if not paged, or multi select, we are ok, just forward
2697>>>>>>>>>        if (window_handle(Current_object)=0 or select_mode(Current_object)=MULTI_SELECT) ;            forward set select_state item iItm to bSt
2701>>>>>>>>>        else If (Select_State(current_object,iItm)<>bSt)  Begin // if paged, single item.
2704>>>>>>>>>            If bSt ;                 // if setting, we must set current_item                send windows_message LB_SETCURSEL iItm 0
2707>>>>>>>>>            else ;                   // if clearing, send windows message                send windows_message LB_SETCURSEL -1 0
2709>>>>>>>>>        end
2709>>>>>>>>>>
2709>>>>>>>>>    end_procedure
2710>>>>>>>>>
2710>>>>>>>>>    procedure toggle_Current_item
2711>>>>>>>>>        local integer iCur
2712>>>>>>>>>        Get current_item to iCur
2713>>>>>>>>>        set select_state item iCur to (not(select_state(current_object,iCur)))
2714>>>>>>>>>    end_procedure
2715>>>>>>>>>
2715>>>>>>>>>
2715>>>>>>>>>End_Class
2716>>>>>>>>>
2716>>>>>>>>>Use PrmpBtMx.pkg  // Prompt Button Support
INCLUDING FILE: PRMPBTMX.PKG
2716>>>>>>>>>>>//************************************************************************
2716>>>>>>>>>>>// Confidential Trade Secret.
2716>>>>>>>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
2716>>>>>>>>>>>// as an unpublished work.  All rights reserved.
2716>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
2716>>>>>>>>>>>//
2716>>>>>>>>>>>//************************************************************************
2716>>>>>>>>>>>//************************************************************************
2716>>>>>>>>>>>//
2716>>>>>>>>>>>// $File name  : PrmpBtMx.Pkg
2716>>>>>>>>>>>// $File title : Prompt buttom mixin class
2716>>>>>>>>>>>// Notice      :
2716>>>>>>>>>>>// $Author(s)  : John Tuohy
2716>>>>>>>>>>>//
2716>>>>>>>>>>>// $Rev History
2716>>>>>>>>>>>//
2716>>>>>>>>>>>// 12/19/97 JJT - changed order of setting form_button_Value and form_button so value
2716>>>>>>>>>>>//                is set first. After button is paged, value does not change (fixed IDE problem)
2716>>>>>>>>>>>// 8/13/97  JJT - Changed interface for prompt button
2716>>>>>>>>>>>// ?/??/??  JJT - File Created
2716>>>>>>>>>>>//************************************************************************
2716>>>>>>>>>>>
2716>>>>>>>>>>>// Public mixin interface:
2716>>>>>>>>>>>//
2716>>>>>>>>>>>// Get/Set Prompt_Button_Mode to PB_PromptAuto | PB_PromptOn | PB_PromptOff
2716>>>>>>>>>>>// Get/Set Prompt_Button_Value to String default="..."
2716>>>>>>>>>>>// Get/Set Prompt_Button_Bitmap to BitmapName
2716>>>>>>>>>>>
2716>>>>>>>>>>>Enumeration_list
2716>>>>>>>>>>>    define PB_PromptAuto for 0
2716>>>>>>>>>>>    define PB_PromptOn   for 1
2716>>>>>>>>>>>    define PB_PromptOff  for 2
2716>>>>>>>>>>>End_enumeration_list
2716>>>>>>>>>>>
2716>>>>>>>>>>>Class Prompt_Button_Mixin is a Mixin
2717>>>>>>>>>>>
2717>>>>>>>>>>>     Procedure Define_Prompt_Button_Mixin
2718>>>>>>>>>>>        Property String Prompt_Button_Value        Public '...'
2719>>>>>>>>>>>        Property String Prompt_Button_BitMap       Public ''
2720>>>>>>>>>>>        Property Integer m_Prompt_Button_Mode      Public PB_PromptOff
2721>>>>>>>>>>>     End_Procedure // Define_Prompt_Button_Mixin
2722>>>>>>>>>>>
2722>>>>>>>>>>>     Procedure Set Prompt_Button_Mode integer iMode
2723>>>>>>>>>>>        Set m_prompt_Button_mode to iMode
2724>>>>>>>>>>>        If (iPrompt<>PB_PromptAuto OR Active_State(Current_Object)) ;            Send Create_Prompt_Button iMode
2727>>>>>>>>>>>     End_Procedure
2728>>>>>>>>>>>
2728>>>>>>>>>>>     Function Prompt_Button_Mode Returns integer
2729>>>>>>>>>>>        Function_Return (m_prompt_button_mode(current_object))
2730>>>>>>>>>>>     End_Function
2731>>>>>>>>>>>
2731>>>>>>>>>>>     // These two messages are maintained for backwards compatibility. Avoid
2731>>>>>>>>>>>     // using these. Use Prompt_Button_Mode instead
2731>>>>>>>>>>>     Procedure Set Auto_Create_Prompt_Button integer bState
2732>>>>>>>>>>>        Set Prompt_Button_Mode to (if(bstate,PB_PromptAuto,PB_PromptOff))
2733>>>>>>>>>>>     End_Procedure
2734>>>>>>>>>>>
2734>>>>>>>>>>>     Function Auto_Create_Prompt_Button Returns integer
2735>>>>>>>>>>>        Function_Return (Prompt_Button_Mode(Current_object)=PB_PromptAuto)
2736>>>>>>>>>>>     End_Function
2737>>>>>>>>>>>
2737>>>>>>>>>>>     // Create a prompt Button. This was created so the process of creating
2737>>>>>>>>>>>     // a prompt button object can be augmented. This will normally get
2737>>>>>>>>>>>     // called if a prompt object id exists for this object. However, you
2737>>>>>>>>>>>     // can send this message yourself.
2737>>>>>>>>>>>     // Avoid using this message - use the property Prompt_Button_Mode
2737>>>>>>>>>>>     Procedure Create_Prompt_Button Integer CreateMode // 0=auto, 1=make, 2=remove
2738>>>>>>>>>>>        Local Integer Obj
2739>>>>>>>>>>>        Local Integer Fg tsz sz Create
2739>>>>>>>>>>>        If Num_Arguments eq 0 Move 1 to Create
2742>>>>>>>>>>>        Else                  Move CreateMode to Create
2744>>>>>>>>>>>        If CreateMode eq PB_PromptAuto begin // 0 = if auto-create and prompt object
2746>>>>>>>>>>>//           If Not (Auto_Create_Prompt_Button(Current_Object)) ;
2746>>>>>>>>>>>//              Procedure_Return
2746>>>>>>>>>>>           Move (Prompt_Object(Current_Object,0) AND ;                 Shadow_State(Current_Object,0)=0 ) to Fg
2747>>>>>>>>>>>//           If Fg Begin
2747>>>>>>>>>>>//              Get text_extent (prompt_button_Value(Current_Object)) to tsz
2747>>>>>>>>>>>//              Get GuiSize to sz
2747>>>>>>>>>>>//              Set GuiSize to (Hi(sz)) (low(sz)+(Low(tsz)*2))
2747>>>>>>>>>>>//              Send Adjust_logicals
2747>>>>>>>>>>>//           End
2747>>>>>>>>>>>        end
2747>>>>>>>>>>>>
2747>>>>>>>>>>>        Else ;                  // 1 = make an object, 2= remove object           Move (Create=PB_PromptOn) to fg
2749>>>>>>>>>>>        If Fg Begin
2751>>>>>>>>>>>           Set Form_Button_Value item 0 To (Prompt_Button_Value(Current_Object))
2752>>>>>>>>>>>           Set Form_Button item 0 To FORM_BUTTON_PROMPT
2753>>>>>>>>>>>        End
2753>>>>>>>>>>>>
2753>>>>>>>>>>>        Else ;           Set Form_Button item 0 To FORM_BUTTON_NONE
2755>>>>>>>>>>>     End_Procedure // Create_Prompt_Button
2756>>>>>>>>>>>
2756>>>>>>>>>>>     //  Send prompt if object can be made the focus (or is the focus)
2756>>>>>>>>>>>     //
2756>>>>>>>>>>>     Procedure Form_Button_Notification integer Item# integer Dummy
2757>>>>>>>>>>>        local integer rval
2758>>>>>>>>>>>        If (Focus(Current_Object)<>Current_Object) ;            get msg_Activate to rval
2761>>>>>>>>>>>        If (Focus(Current_Object)=Current_Object) ;            Send Prompt
2764>>>>>>>>>>>     End_Procedure
2765>>>>>>>>>>>
2765>>>>>>>>>>>     Procedure Activating returns integer
2766>>>>>>>>>>>         Local integer iMode iRet
2767>>>>>>>>>>>         Get Prompt_Button_Mode to iMode
2768>>>>>>>>>>>         If iMode eq PB_PromptAuto ;            Send Create_Prompt_Button iMode
2771>>>>>>>>>>>         Forward get msg_Activating to iRet
2773>>>>>>>>>>>         Procedure_return iRet
2774>>>>>>>>>>>     End_Procedure
2775>>>>>>>>>>>
2775>>>>>>>>>>>
2775>>>>>>>>>>>End_Class
2776>>>>>>>>>
2776>>>>>>>>>// Class: Form
2776>>>>>>>>>//
2776>>>>>>>>>//  1. Add Standard entry support
2776>>>>>>>>>//  2. Support color change when shadowed (right now this is done in flex -
2776>>>>>>>>>//     should we try to make this automatic?)
2776>>>>>>>>>//  3. Single item switch behavior
2776>>>>>>>>>//
2776>>>>>>>>>Class Form is a DFBaseForm
2777>>>>>>>>>    Procedure Construct_Object
2778>>>>>>>>>        Forward Send Construct_Object
2780>>>>>>>>>        Send Define_Standard_Form_Mixin
2781>>>>>>>>>        Send Define_Prompt_Button_Mixin
2782>>>>>>>>>        Property integer m_Prompt_object public 0
2783>>>>>>>>>        on_key kPrompt send Prompt
2784>>>>>>>>>    End_Procedure // Construct_Object
2785>>>>>>>>>
2785>>>>>>>>>    Import_Class_Protocol Standard_Form_Mixin
2786>>>>>>>>>    Import_Class_Protocol Prompt_Button_Mixin
2787>>>>>>>>>
2787>>>>>>>>>    Procedure Set Prompt_object integer iItem integer hoPrompt
2788>>>>>>>>>        Set m_prompt_object to hoPrompt
2789>>>>>>>>>    end_Procedure
2790>>>>>>>>>
2790>>>>>>>>>    Function Prompt_object integer iItem returns integer
2791>>>>>>>>>        Function_Return (m_prompt_object(Current_Object))
2792>>>>>>>>>    end_function
2793>>>>>>>>>
2793>>>>>>>>>    Procedure Prompt
2794>>>>>>>>>        local integer hoPrompt
2795>>>>>>>>>        Get prompt_object to hoPrompt
2796>>>>>>>>>        If hoPrompt Send Popup to hoPrompt
2799>>>>>>>>>    End_Procedure
2800>>>>>>>>>
2800>>>>>>>>>    // With form based objects we can set capslock by setting
2800>>>>>>>>>    // the right bit in forms_options. We use the
2800>>>>>>>>>    // options message instead of the option message because
2800>>>>>>>>>    // form_option doesn't seem to work right.
2800>>>>>>>>>    procedure Set Capslock_State Integer bState
2801>>>>>>>>>        local integer iOptions
2802>>>>>>>>>        Get Form_Options item 0 to iOptions
2803>>>>>>>>>        if bState ;           Move (AddBitValue(Capslock_Bit_Value, iOptions)) To iOptions
2806>>>>>>>>>        else ;           Move (RemoveBitValue(Capslock_bit_Value, iOptions)) to iOptions
2808>>>>>>>>>        set form_Options item 0 to iOptions
2809>>>>>>>>>    End_procedure
2810>>>>>>>>>
2810>>>>>>>>>    // check capslock bit for capslock_state
2810>>>>>>>>>    Function CapsLock_State returns integer
2811>>>>>>>>>       local integer iOptions
2812>>>>>>>>>       get form_Options item 0 to iOptions
2813>>>>>>>>>       Function_Return ( (iOptions IAND CAPSLOCK_BIT_VALUE)<>0 )
2814>>>>>>>>>    End_Function
2815>>>>>>>>>
2815>>>>>>>>>//    Procedure End_Construct_Object
2815>>>>>>>>>//        If ( Item_Count(Current_Object)=1) ;
2815>>>>>>>>>//            Send Create_Prompt_Button 0 // zero means - conditional
2815>>>>>>>>>//        Forward Send End_Construct_Object
2815>>>>>>>>>//    End_Procedure // End_Construct_Object
2815>>>>>>>>>
2815>>>>>>>>>End_Class
2816>>>>>>>>>
2816>>>>>>>>>
2816>>>>>>>>>// Class: Entry
2816>>>>>>>>>//
2816>>>>>>>>>//  1. Add Standard entry support
2816>>>>>>>>>//  2. Support color change when shadowed (right now this is done in flex -
2816>>>>>>>>>//     should we try to make this automatic?)
2816>>>>>>>>>//  3. Help_DataFile support
2816>>>>>>>>>//  4. Single item switch behavior
2816>>>>>>>>>//  5. Auto margin, type setting
2816>>>>>>>>>//
2816>>>>>>>>>Class Entry Is A DfBaseEntry
2817>>>>>>>>>
2817>>>>>>>>>    Procedure Construct_Object
2818>>>>>>>>>        Forward Send Construct_Object
2820>>>>>>>>>        Send Define_Standard_Form_Mixin
2821>>>>>>>>>        Send Define_Prompt_Button_Mixin
2822>>>>>>>>>        on_key kPrompt send Prompt
2823>>>>>>>>>    End_Procedure // Construct_Object
2824>>>>>>>>>
2824>>>>>>>>>    Import_Class_Protocol Standard_Form_Mixin
2825>>>>>>>>>    Import_Class_Protocol Auto_Setup_Mixin
2826>>>>>>>>>    Import_Class_Protocol Datafile_Help_Mixin
2827>>>>>>>>>    Import_Class_Protocol Entry_Shadow_Mixin
2828>>>>>>>>>    Import_Class_Protocol Prompt_Button_Mixin
2829>>>>>>>>>
2829>>>>>>>>>    // With entry based objects we can set capslock by setting
2829>>>>>>>>>    // the right bit in item_options AND form_Options. We use the
2829>>>>>>>>>    // options message instead of the option message because form_
2829>>>>>>>>>    // option doesn't seem to work right.
2829>>>>>>>>>    procedure Set Capslock_State Integer bState
2830>>>>>>>>>        local integer iOptions
2831>>>>>>>>>        Get Item_Options item 0 to iOptions
2832>>>>>>>>>        if bState ;           Move (AddBitValue(CAPSLOCK_BIT_VALUE, iOptions)) To iOptions
2835>>>>>>>>>        else ;           Move (RemoveBitValue(CAPSLOCK_BIT_VALUE, iOptions)) to iOptions
2837>>>>>>>>>        set Item_Options item 0 to iOptions
2838>>>>>>>>>        // must also set form_options. We assume that item and form options
2838>>>>>>>>>        // should always be the same and the item_options are the boss. This
2838>>>>>>>>>        // is the way the DD handles it.
2838>>>>>>>>>        set form_Options item 0 to iOptions
2839>>>>>>>>>    End_procedure
2840>>>>>>>>>
2840>>>>>>>>>    // check capslock bit for capslock_state
2840>>>>>>>>>    Function CapsLock_State returns integer
2841>>>>>>>>>       local integer iOptions
2842>>>>>>>>>       get Item_Options item 0 to iOptions
2843>>>>>>>>>       Function_Return ( (iOptions IAND CAPSLOCK_BIT_VALUE)<>0 )
2844>>>>>>>>>    End_Function // Wrap_State
2845>>>>>>>>>
2845>>>>>>>>>    Procedure End_Construct_Object
2846>>>>>>>>>        Send Define_Form_Margins
2847>>>>>>>>>//        If ( Item_Count(Current_Object)=1) ;
2847>>>>>>>>>//            Send Create_Prompt_Button 0 // zero means - conditional
2847>>>>>>>>>        Forward Send End_Construct_Object
2849>>>>>>>>>    End_Procedure // End_Construct_Object
2850>>>>>>>>>
2850>>>>>>>>>End_Class
2851>>>>>>>>>
2851>>>>>>>>>
2851>>>>>>>>>// Class: Grid
2851>>>>>>>>>//
2851>>>>>>>>>//  1. Add Standard entry support
2851>>>>>>>>>//  2. Support color change when shadowed
2851>>>>>>>>>//
2851>>>>>>>>>Class Grid is a DfBaseFormList
2852>>>>>>>>>
2852>>>>>>>>>    Procedure Construct_Object
2853>>>>>>>>>        Forward Send Construct_Object
2855>>>>>>>>>        Send Define_Standard_Grid_Mixin
2856>>>>>>>>>    End_Procedure // Construct_Object
2857>>>>>>>>>
2857>>>>>>>>>    Import_Class_Protocol Standard_Grid_Mixin
2858>>>>>>>>>
2858>>>>>>>>>    Procedure End_Construct_Object
2859>>>>>>>>>        Send Define_List_Form_Columns
2860>>>>>>>>>        Forward Send End_Construct_Object
2862>>>>>>>>>    End_Procedure // End_Construct_Object
2863>>>>>>>>>
2863>>>>>>>>>End_Class
2864>>>>>>>>>
2864>>>>>>>>>// Class: EntryList
2864>>>>>>>>>//
2864>>>>>>>>>//  1. Add Standard entry support
2864>>>>>>>>>//  2. Support color change when shadowed
2864>>>>>>>>>//  3. Help_DataFile support
2864>>>>>>>>>//  4. Auto margin, type setting
2864>>>>>>>>>//
2864>>>>>>>>>Class EntryList is a DFBaseEntryList
2865>>>>>>>>>
2865>>>>>>>>>    Procedure Construct_Object
2866>>>>>>>>>        Forward Send Construct_Object
2868>>>>>>>>>        Send Define_Standard_Grid_Mixin
2869>>>>>>>>>    End_Procedure // Construct_Object
2870>>>>>>>>>
2870>>>>>>>>>    Import_Class_Protocol Standard_Grid_Mixin
2871>>>>>>>>>    Import_Class_Protocol Datafile_Help_Mixin
2872>>>>>>>>>
2872>>>>>>>>>    //  This replace Set Current_Item in standard grid mixin. It is
2872>>>>>>>>>    //  identical except that it checks for noenter fields and it
2872>>>>>>>>>    //  handles scroll requests from the thumb.
2872>>>>>>>>>    //
2872>>>>>>>>>    // 1. Modified to optimize painting and make scrolling work properly
2872>>>>>>>>>    // 2. Add Request_Status_Help for item changes.
2872>>>>>>>>>    Procedure Set Current_Item Integer Itm
2873>>>>>>>>>       Local Integer IsFoc
2874>>>>>>>>>       Local integer oldst oldtop
2874>>>>>>>>>       Local integer opt CrntCol NumCols
2874>>>>>>>>>       Get Line_Size to NumCols
2875>>>>>>>>>       // Currently the C entrylist class returns a big number if the
2875>>>>>>>>>       // thumb is moved to top. It passes -1 (65535)* # cols + cur col.
2875>>>>>>>>>       // This will be value of 65535*#cols or greater!
2875>>>>>>>>>       // If the end of bar is thumbed it will return displayable-rows+1
2875>>>>>>>>>       // * number of cols. This will always be greater than item count.
2875>>>>>>>>>       If (Itm>=65535*NumCols or Itm<0) ;          Send beginning_of_Data
2878>>>>>>>>>       else If (Itm>=item_count(Current_Object)) ;          Send End_of_Data
2882>>>>>>>>>       else begin
2883>>>>>>>>>          // if the target is NoEnter (or expression or displayonly) then
2883>>>>>>>>>          // we will move to the selected row but stay in the current column.
2883>>>>>>>>>          get item_option item Itm NoEnter to opt
2884>>>>>>>>>          if Opt Begin
2886>>>>>>>>>             Get current_Col to CrntCol
2887>>>>>>>>>             Move (itm/NumCols*NumCols+CrntCol) to itm
2888>>>>>>>>>             get item_option item itm NoEnter to opt // if still Noenter
2889>>>>>>>>>             if Opt procedure_return                 // do nothing
2892>>>>>>>>>          End
2892>>>>>>>>>>
2892>>>>>>>>>          //
2892>>>>>>>>>          Move (Focus(Desktop)=Current_Object) to IsFoc
2893>>>>>>>>>          If IsFoc Send Request_Status_Help False
2896>>>>>>>>>          get dynamic_update_state to oldst
2897>>>>>>>>>          Set Dynamic_Update_State to False
2898>>>>>>>>>          get top_item             to oldtop // we need to know if to-item changes
2899>>>>>>>>>          Forward Set Current_Item to Itm
2901>>>>>>>>>          // If dyn had been on, we pass 1 (refresh all) if we scrolled and a
2901>>>>>>>>>          // 2 (refresh dirty cells) if we did not scroll. Note that other
2901>>>>>>>>>          // processes might have dirtied the cells so that a "2" becomes
2901>>>>>>>>>          // equivalent to a "1"
2901>>>>>>>>>          if oldst ; // if top_Item changed we scrolled!             Move (If(Top_Item(Current_Object)<>OldTop,1,2)) to OldSt
2904>>>>>>>>>          Set dynamic_update_State to OldSt
2905>>>>>>>>>          if IsFoc Send Request_Status_Help True
2908>>>>>>>>>       End
2908>>>>>>>>>>
2908>>>>>>>>>    End_Procedure // Set Current_Item
2909>>>>>>>>>
2909>>>>>>>>>
2909>>>>>>>>>    Procedure End_Construct_Object
2910>>>>>>>>>        Send Define_Form_Margins
2911>>>>>>>>>        Send Define_List_Form_Columns
2912>>>>>>>>>        Forward Send End_Construct_Object
2914>>>>>>>>>    End_Procedure // End_Construct_Object
2915>>>>>>>>>
2915>>>>>>>>>End_Class
2916>>>>>>>>>
2916>>>>>>>>>//-----------Container Classes---------
2916>>>>>>>>>
2916>>>>>>>>>// Class: Panel
2916>>>>>>>>>//
2916>>>>>>>>>//  1. Define Standard container behaviors
2916>>>>>>>>>//
2916>>>>>>>>>
2916>>>>>>>>>Class BasicPanel Is A DFBasePanel
2917>>>>>>>>>
2917>>>>>>>>>    Procedure Construct_Object
2918>>>>>>>>>        Forward Send Construct_Object
2920>>>>>>>>>
2920>>>>>>>>>        Send Define_Standard_Container_Mixin
2921>>>>>>>>>        Send Define_Panel_Mixin
2922>>>>>>>>>
2922>>>>>>>>>        // Support A Tool Bar, A Status Bar, A Client Area. We Will Assume That
2922>>>>>>>>>        // All Objects At Least Understand This Protocol.
2922>>>>>>>>>        Property Integer Toolbar_Id      Public 0
2923>>>>>>>>>        Property Integer Statusbar_Id    Public 0
2924>>>>>>>>>        Property Integer Client_Id       Public 0 // Current_Object
2925>>>>>>>>>        Set Locate_Mode to SMART_LOCATE
2926>>>>>>>>>    End_Procedure // Construct_Object
2927>>>>>>>>>
2927>>>>>>>>>    // This Will Never Get Sent To, But It Keeps The Compiler Content.
2927>>>>>>>>>    Procedure Show_Status_Help String Shelp
2928>>>>>>>>>    End_Procedure
2929>>>>>>>>>
2929>>>>>>>>>    // This Allows Children To Find The Parent Panel. This Seems Like A
2929>>>>>>>>>    // Pretty Basic Requirement.
2929>>>>>>>>>    Function Main_Panel_Id Returns Integer
2930>>>>>>>>>        Function_Return Current_Object
2931>>>>>>>>>    End_Function
2932>>>>>>>>>
2932>>>>>>>>>    Import_Class_Protocol Standard_Container_Mixin
2933>>>>>>>>>    Import_Class_Protocol Panel_Mixin
2934>>>>>>>>>
2934>>>>>>>>>    Function Verify_Exit_Application Returns Integer
2935>>>>>>>>>    End_Function
2936>>>>>>>>>
2936>>>>>>>>>    Procedure Notify_Exit_Application
2937>>>>>>>>>    End_Procedure // Notify_Exit_Application
2938>>>>>>>>>
2938>>>>>>>>>    Procedure Broadcast_Notify_Exit_Application
2939>>>>>>>>>        Set Delegation_Mode To Delegate_To_Parent
2940>>>>>>>>>        Send Notify_Exit_Application
2941>>>>>>>>>    End_Procedure // Notify_Exit_Application
2942>>>>>>>>>
2942>>>>>>>>>    Function Broadcast_Verify_Exit_Application Returns Integer
2943>>>>>>>>>        Set Delegation_Mode To Delegate_To_Parent
2944>>>>>>>>>        Function_Return (Verify_Exit_Application(Current_Object))
2945>>>>>>>>>    End_Function
2946>>>>>>>>>
2946>>>>>>>>>    Procedure OnActivateApp
2947>>>>>>>>>    End_Procedure
2948>>>>>>>>>
2948>>>>>>>>>    Procedure OnDeactivateApp
2949>>>>>>>>>    End_Procedure
2950>>>>>>>>>
2950>>>>>>>>>    Procedure Notify_Application_Activation Integer bActivate
2951>>>>>>>>>        local integer hMain
2952>>>>>>>>>        Get Main_Window to hMain
2953>>>>>>>>>        // if main window exists send event to main window, else just send
2953>>>>>>>>>        // the event to itself. Normally a main window will (should) exist
2953>>>>>>>>>        If hMain eq 0 Move current_object to hMain
2956>>>>>>>>>        forward send Notify_Application_Activation bActivate
2958>>>>>>>>>        If bActivate Send OnActivateApp   to hMain
2961>>>>>>>>>        Else         Send OnDeactivateApp to hMain
2963>>>>>>>>>    End_Procedure
2964>>>>>>>>>
2964>>>>>>>>>    //Procedure OnResize
2964>>>>>>>>>    //End_Procedure
2964>>>>>>>>>    //
2964>>>>>>>>>    //Procedure OnPaint
2964>>>>>>>>>    //End_Procedure
2964>>>>>>>>>    //
2964>>>>>>>>>    //Procedure Set GuiSize Integer cy Integer cx
2964>>>>>>>>>    //    Local Integer cxy
2964>>>>>>>>>    //    Get GuiSize To cxy
2964>>>>>>>>>    //    Forward Set GuiSize cy cx
2964>>>>>>>>>    //    If (BuildingObjectId=0 AND ;
2964>>>>>>>>>    //        Window_Handle(current_object) AND ;
2964>>>>>>>>>    //        ( Hi(cxy)<>cy or Low(cxy)<>cx) ) ;
2964>>>>>>>>>    //           Send OnResize
2964>>>>>>>>>    //End_Procedure
2964>>>>>>>>>    //
2964>>>>>>>>>    //Procedure Paint
2964>>>>>>>>>    //    Forward Send Paint
2964>>>>>>>>>    //    Send OnPaint
2964>>>>>>>>>    //End_Procedure
2964>>>>>>>>>    //
2964>>>>>>>>>    //Procedure Page Integer iState
2964>>>>>>>>>    //    Forward Send Page iState
2964>>>>>>>>>    //    If (iState =1) Send OnResize
2964>>>>>>>>>    //End_Procedure
2964>>>>>>>>>
2964>>>>>>>>>End_Class
2965>>>>>>>>>
2965>>>>>>>>>// Class: ToolPanel
2965>>>>>>>>>//
2965>>>>>>>>>//  1. Define Standard container behaviors
2965>>>>>>>>>//
2965>>>>>>>>>Class ToolPanel is a DFBaseToolpanel
2966>>>>>>>>>
2966>>>>>>>>>    Procedure Construct_Object
2967>>>>>>>>>        Forward Send Construct_Object
2969>>>>>>>>>
2969>>>>>>>>>        Send Define_Standard_Container_Mixin
2970>>>>>>>>>        Send Define_Panel_Mixin
2971>>>>>>>>>        // Support A Tool Bar, A Status Bar, A Client Area. We Will Assume That
2971>>>>>>>>>        // All Objects At Least Understand This Protocol.
2971>>>>>>>>>        Property Integer Toolbar_Id      Public 0
2972>>>>>>>>>        Property Integer Statusbar_Id    Public 0
2973>>>>>>>>>        Property Integer Client_Id       Public Current_Object
2974>>>>>>>>>        Set Locate_Mode to SMART_LOCATE
2975>>>>>>>>>        On_Key kClose_Panel Send Close_Panel
2976>>>>>>>>>    End_Procedure // Construct_Object
2977>>>>>>>>>
2977>>>>>>>>>    Import_Class_Protocol Standard_Container_Mixin
2978>>>>>>>>>    Import_Class_Protocol Panel_Mixin
2979>>>>>>>>>
2979>>>>>>>>>    //Procedure OnResize
2979>>>>>>>>>    //End_Procedure
2979>>>>>>>>>    //
2979>>>>>>>>>    //Procedure Set GuiSize Integer cy Integer cx
2979>>>>>>>>>    //    Local Integer cxy
2979>>>>>>>>>    //    Get GuiSize To cxy
2979>>>>>>>>>    //    Forward Set GuiSize cy cx
2979>>>>>>>>>    //    If (BuildingObjectId=0 AND ;
2979>>>>>>>>>    //        Window_Handle(current_object) AND ;
2979>>>>>>>>>    //        ( Hi(cxy)<>cy or Low(cxy)<>cx) ) ;
2979>>>>>>>>>    //           Send OnResize
2979>>>>>>>>>    //End_Procedure
2979>>>>>>>>>    //
2979>>>>>>>>>    //Procedure Page Integer iState
2979>>>>>>>>>    //    Forward Send Page iState
2979>>>>>>>>>    //    If (iState =1) Send OnResize
2979>>>>>>>>>    //End_Procedure
2979>>>>>>>>>
2979>>>>>>>>>    Procedure OnActivateApp
2980>>>>>>>>>    End_Procedure
2981>>>>>>>>>
2981>>>>>>>>>    Procedure OnDeactivateApp
2982>>>>>>>>>    End_Procedure
2983>>>>>>>>>
2983>>>>>>>>>    Procedure Notify_Application_Activation Integer bActivate
2984>>>>>>>>>        local integer hMain
2985>>>>>>>>>        Get Main_Window to hMain
2986>>>>>>>>>        // if main window exists send event to main window, else just send
2986>>>>>>>>>        // the event to itself. Normally a main window will (should) exist
2986>>>>>>>>>        If hMain eq 0 Move current_object to hMain
2989>>>>>>>>>        forward send Notify_Application_Activation bActivate
2991>>>>>>>>>        If bActivate Send OnActivateApp   to hMain
2994>>>>>>>>>        Else         Send OnDeactivateApp to hMain
2996>>>>>>>>>    End_Procedure
2997>>>>>>>>>
2997>>>>>>>>>End_Class
2998>>>>>>>>>
2998>>>>>>>>>Class ModalPanel is a ToolPanel
2999>>>>>>>>>
2999>>>>>>>>>  Procedure Construct_Object
3000>>>>>>>>>     Forward Send Construct_Object
3002>>>>>>>>>     Set Caption_bar   to TRUE
3003>>>>>>>>>     Set Border_Style  to Border_Dialog
3004>>>>>>>>>     Set Minimize_Icon to FALSE
3005>>>>>>>>>     Set Maximize_Icon to FALSE
3006>>>>>>>>>     Set SysMenu_Icon  to TRUE
3007>>>>>>>>>     Set Modal_State to TRUE
3008>>>>>>>>>  End_Procedure // Construct_Object
3009>>>>>>>>>
3009>>>>>>>>>End_Class
3010>>>>>>>>>
3010>>>>>>>>>
3010>>>>>>>>>Class Container3d is a DFBaseDialog
3011>>>>>>>>>
3011>>>>>>>>>    Procedure Construct_Object
3012>>>>>>>>>        Forward Send Construct_Object
3014>>>>>>>>>        Send Define_Standard_Container_Mixin
3015>>>>>>>>>        Set Ring_State to False // containers should not default as rings
3016>>>>>>>>>    End_Procedure // Construct_Object
3017>>>>>>>>>
3017>>>>>>>>>    Import_Class_Protocol Standard_Container_Mixin
3018>>>>>>>>>
3018>>>>>>>>>End_Class
3019>>>>>>>>>
3019>>>>>>>>>Class Dialog is a Container3d
3020>>>>>>>>>
3020>>>>>>>>>    Procedure Construct_Object
3021>>>>>>>>>        Forward Send Construct_Object
3023>>>>>>>>>        Send Define_Panel_Mixin
3024>>>>>>>>>        Set Caption_Bar  To TRUE
3025>>>>>>>>>        Set SysMenu_Icon To TRUE
3026>>>>>>>>>        Set Ring_State to True // Panels should ring
3027>>>>>>>>>    End_Procedure // Construct_Object
3028>>>>>>>>>
3028>>>>>>>>>    Import_Class_Protocol Panel_Mixin
3029>>>>>>>>>
3029>>>>>>>>>    //Procedure OnResize
3029>>>>>>>>>    //End_Procedure
3029>>>>>>>>>    //
3029>>>>>>>>>    //Procedure OnPaint
3029>>>>>>>>>    //End_Procedure
3029>>>>>>>>>    //
3029>>>>>>>>>    //Procedure Set GuiSize Integer cy Integer cx
3029>>>>>>>>>    //    Local Integer cxy
3029>>>>>>>>>    //    Get GuiSize To cxy
3029>>>>>>>>>    //    Forward Set GuiSize cy cx
3029>>>>>>>>>    //    If (BuildingObjectId=0 AND ;
3029>>>>>>>>>    //        Window_Handle(current_object) AND ;
3029>>>>>>>>>    //        ( Hi(cxy)<>cy or Low(cxy)<>cx)) ;
3029>>>>>>>>>    //                Send OnResize
3029>>>>>>>>>    //End_Procedure
3029>>>>>>>>>    //
3029>>>>>>>>>    //Procedure Page Integer iState
3029>>>>>>>>>    //    Forward Send Page iState
3029>>>>>>>>>    //    If (iState =1) Send OnResize
3029>>>>>>>>>    //End_Procedure
3029>>>>>>>>>    //
3029>>>>>>>>>    //Procedure Paint
3029>>>>>>>>>    //    Forward Send Paint
3029>>>>>>>>>    //    Send OnPaint
3029>>>>>>>>>    //End_Procedure
3029>>>>>>>>>
3029>>>>>>>>>
3029>>>>>>>>>End_Class
3030>>>>>>>>>
3030>>>>>>>>>
3030>>>>>>>>>// Class: Group
3030>>>>>>>>>//
3030>>>>>>>>>//  1. Define Standard container behaviors
3030>>>>>>>>>//
3030>>>>>>>>>Class Group Is a DFBaseGroup
3031>>>>>>>>>
3031>>>>>>>>>    Procedure Construct_Object
3032>>>>>>>>>        Forward Send Construct_Object
3034>>>>>>>>>        Send Define_Standard_Container_Mixin
3035>>>>>>>>>    End_Procedure // Construct_Object
3036>>>>>>>>>
3036>>>>>>>>>    Import_Class_Protocol Standard_Container_Mixin
3037>>>>>>>>>
3037>>>>>>>>>    Procedure Enable_Window integer iState
3038>>>>>>>>>      Local integer hWnd
3039>>>>>>>>>      Get Window_Handle to hWnd
3040>>>>>>>>>      If hWnd ;         Move (EnableWindow(hWnd,iState)) To hWnd
3043>>>>>>>>>    End_procedure
3044>>>>>>>>>
3044>>>>>>>>>    Procedure Page_Object integer iState
3045>>>>>>>>>      Local Handle hWnd
3046>>>>>>>>>      Get Window_Handle To hWnd
3047>>>>>>>>>       Forward Send Page_Object iState
3049>>>>>>>>>      If (hWnd=0 and iState) ;         Send Shadow_Display
3052>>>>>>>>>    End_Procedure
3053>>>>>>>>>
3053>>>>>>>>>    Procedure Shadow_Display
3054>>>>>>>>>      Send Enable_Window (Not(Object_Shadow_State(Current_Object)))
3055>>>>>>>>>    End_Procedure
3056>>>>>>>>>
3056>>>>>>>>>End_Class
3057>>>>>>>>>
3057>>>>>>>>>
3057>>>>>>>>>//Class Container is a Client
3057>>>>>>>>>//
3057>>>>>>>>>//   Procedure Construct_Object
3057>>>>>>>>>//      Forward Send Construct_Object No_Image
3057>>>>>>>>>//      Send Define_Standard_Object_Mixin
3057>>>>>>>>>//      Send define_Shadow_Mixin
3057>>>>>>>>>//      Set Broadcast_Implicit_Shadow_State to True
3057>>>>>>>>>//      Set Ring_State to False
3057>>>>>>>>>//   End_Procedure // Construct_Object
3057>>>>>>>>>//
3057>>>>>>>>>//   Import_Class_Protocol Standard_Object_Mixin
3057>>>>>>>>>//   Import_Class_Protocol Shadow_Mixin
3057>>>>>>>>>//
3057>>>>>>>>>//   Function Object_Color returns integer
3057>>>>>>>>>//     local integer rval
3057>>>>>>>>>//     Delegate Get Object_color to rval
3057>>>>>>>>>//     function_return rval
3057>>>>>>>>>//   End_Function
3057>>>>>>>>>//
3057>>>>>>>>>//   Procedure Set Current_Shadow_State integer iState
3057>>>>>>>>>//      Set Private.Shadow_State to iState
3057>>>>>>>>>//   End_Procedure // Set Current_Shadow_State
3057>>>>>>>>>//
3057>>>>>>>>>//   Function Object_Shadow_State returns integer
3057>>>>>>>>>//     Function_Return (Private.Shadow_State(Current_Object))
3057>>>>>>>>>//   End_Function // Object_Shadow_State
3057>>>>>>>>>//
3057>>>>>>>>>//   Procedure End_Construct_Object
3057>>>>>>>>>//     Forward Send End_Construct_Object
3057>>>>>>>>>//     // if already shadowed by parent...do nothing. Else set changed
3057>>>>>>>>>//     // state and broadcast to children
3057>>>>>>>>>//     If (Explicit_Shadow_State(Current_Object) AND ;
3057>>>>>>>>>//         Not(Implicit_Shadow_State(Current_Object)) AND ;
3057>>>>>>>>>//         Broadcast_Implicit_Shadow_State(Current_Object) ) ;
3057>>>>>>>>>//             Broadcast Set Implicit_Shadow_State to True
3057>>>>>>>>>//   End_procedure
3057>>>>>>>>>
3057>>>>>>>>>Class Container is a Container3d
3058>>>>>>>>>  Import_Class_Protocol NonVisual_Container_Mixin
3059>>>>>>>>>End_Class
3060>>>>>>>>>
3060>>>>>>>>>// Class: Button
3060>>>>>>>>>//
3060>>>>>>>>>//  1. Set Default Size to 14 50 // (the win95 standard)
3060>>>>>>>>>//  2. Standard Object
3060>>>>>>>>>//  3. Label Support
3060>>>>>>>>>//  4. Shadow_state support
3060>>>>>>>>>//
3060>>>>>>>>>Class Button Is A DfBasepushbutton
3061>>>>>>>>>
3061>>>>>>>>>    Procedure OnClick
3062>>>>>>>>>    End_Procedure
3063>>>>>>>>>
3063>>>>>>>>>    Procedure Construct_Object
3064>>>>>>>>>        Forward Send Construct_Object
3066>>>>>>>>>        Property Integer    private.CurrentButtonState  Public FALSE
3067>>>>>>>>>
3067>>>>>>>>>        Send Define_Standard_Object_Mixin
3068>>>>>>>>>        Send Define_Shadow_Mixin
3069>>>>>>>>>        Send Define_Bitmap_Support_Mixin
3070>>>>>>>>>
3070>>>>>>>>>        Set Size To 14 50 // 50 is the same size as MS DLUs buttons
3071>>>>>>>>>        Set Message item 0 To msg_OnClick
3072>>>>>>>>>
3072>>>>>>>>>
3072>>>>>>>>>        // Enter should execute the button function without a visual "push".
3072>>>>>>>>>        // Space-bar should execute the button function while "pressing" the
3072>>>>>>>>>        // button visually.
3072>>>>>>>>>        //
3072>>>>>>>>>        On_Key kEnter    Send Default_Key
3073>>>>>>>>>        On_Key Key_Space Send Mouse_Down
3074>>>>>>>>>    End_Procedure // Construct_Object
3075>>>>>>>>>
3075>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
3076>>>>>>>>>    Import_Class_Protocol Label_Mixin
3077>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
3078>>>>>>>>>    Import_Class_Protocol Bitmap_Support_Mixin
3079>>>>>>>>>
3079>>>>>>>>>    //  KeyAction is the message that should be sent to a button via
3079>>>>>>>>>    //  an on_key in support of an underlined hot-key indicator. For
3079>>>>>>>>>    //  example, setting a button label to "&Close" will create an
3079>>>>>>>>>    //  underlined "C", indicating to a user that Alt+C should also
3079>>>>>>>>>    //  be usable for "close". To support that, simply setup an on_key
3079>>>>>>>>>    //  message: On_Key Key_Alt+Key_C Send KeyAction to (closebutton(current_object))
3079>>>>>>>>>    //  JJT: this was modified to not send OnClick but to send Message to Aux_value.
3079>>>>>>>>>    //  Normally, this will be the same as onCLick (onClick will be the message and
3079>>>>>>>>>    //  there will be no aux_value).
3079>>>>>>>>>    Procedure KeyAction
3080>>>>>>>>>        local integer bActive bShadow iRetVal
3081>>>>>>>>>        local integer hmMsg hObj
3081>>>>>>>>>        get Active_state to bActive
3082>>>>>>>>>        get Object_shadow_state to bShadow
3083>>>>>>>>>        get Message item 0 to hmMsg
3084>>>>>>>>>        Move 0 to iRetVal                // non-inititalized int can stop the UI!
3085>>>>>>>>>        if (bActive and (not(bShadow)) and hmMsg) Begin
3087>>>>>>>>>            get aux_value item 0 to hObj
3088>>>>>>>>>            if hObj eq 0 Move current_object to hObj
3091>>>>>>>>>            get hmMsg of hObj to iRetVal
3092>>>>>>>>>        end
3092>>>>>>>>>>
3092>>>>>>>>>        Procedure_Return iRetVal         // should we. (e.g., to stop the ui)
3093>>>>>>>>>    End_Procedure
3094>>>>>>>>>
3094>>>>>>>>>    Function CurrentButtonState Returns Integer
3095>>>>>>>>>        Function_Return (private.CurrentButtonState(Current_Object))
3096>>>>>>>>>    End_Function
3097>>>>>>>>>
3097>>>>>>>>>    //  Set CurrentButtonState to FALSE/TRUE will cause the button to display
3097>>>>>>>>>    //  the "thick" border seen on "default" buttons. By Default, buttons will
3097>>>>>>>>>    //  now set this property to true when ever they take the focus, and false
3097>>>>>>>>>    //  when they lose the focus. Logic exists in "panel" objects to set a default
3097>>>>>>>>>    //  button which will be highlighted when needed. Note that all highlighting
3097>>>>>>>>>    //  is handled by calling this one message.
3097>>>>>>>>>    //  Get/Set CurrentButtonState is private, system maintained and dynamic.
3097>>>>>>>>>    //  Do not set this as part of an object's attributes.
3097>>>>>>>>>    //
3097>>>>>>>>>    Procedure Set CurrentButtonState Integer bState
3098>>>>>>>>>        Local Handle hWnd hObj
3099>>>>>>>>>        Local Integer iStyle cxy iTemp
3099>>>>>>>>>        // cannot make a shadowed button the default
3099>>>>>>>>>        If (object_shadow_state(current_object) AND bState) ;           procedure_return
3102>>>>>>>>>        Get Form_Window_Handle Item 0 To hWnd
3103>>>>>>>>>        if (hWnd and (CurrentButtonState(current_object)<>bState)) begin
3105>>>>>>>>>            set private.CurrentButtonState to bState
3106>>>>>>>>>            Move (if(bState,current_object,0)) to hObj
3107>>>>>>>>>            // very private message! Do not send from anywhere else!!!!!
3107>>>>>>>>>            delegate set private.Current_Action_Button to hObj // delegate to panel
3109>>>>>>>>>            Get GuiSize To cxy
3110>>>>>>>>>            Move (GetWindowLong(hWnd, GWL_STYLE)) To iStyle
3111>>>>>>>>>            If bState Begin
3113>>>>>>>>>                Move (SetWindowLong(hWnd, GWL_STYLE, iStyle IOR 1)) To iTemp
3114>>>>>>>>>                Set GuiSize To (Hi(cxy)) (Low(cxy)+1)
3115>>>>>>>>>            end
3115>>>>>>>>>>
3115>>>>>>>>>            else begin
3116>>>>>>>>>                Move (SetWindowLong(hWnd, GWL_STYLE, iStyle IAND $FFFFFFFE)) To iTemp
3117>>>>>>>>>                Set GuiSize To (Hi(cxy)) (Low(cxy)-1)
3118>>>>>>>>>            end
3118>>>>>>>>>>
3118>>>>>>>>>        end
3118>>>>>>>>>>
3118>>>>>>>>>    End_Procedure
3119>>>>>>>>>
3119>>>>>>>>>
3119>>>>>>>>>    //  Default_State is the public interface for setting the Default
3119>>>>>>>>>    //  Action Button at the button itself. The message CurrentButtonState
3119>>>>>>>>>    //  is implementation of part of the mechanism and should not be used
3119>>>>>>>>>    //  directly.
3119>>>>>>>>>    //
3119>>>>>>>>>    Procedure Set Default_State Integer bState
3120>>>>>>>>>        set Default_Action_Button to (if(bState,current_object,0))
3121>>>>>>>>>    End_Procedure
3122>>>>>>>>>
3122>>>>>>>>>    Function Default_State Returns Integer
3123>>>>>>>>>        Function_Return (Default_action_Button(current_object)=current_object)
3124>>>>>>>>>    End_Function
3125>>>>>>>>>
3125>>>>>>>>>    Procedure remove_object
3126>>>>>>>>>        // we must make sure that the button is normal before removing it. Otherwise
3126>>>>>>>>>        // it will be the wrong size when repaged.
3126>>>>>>>>>        set CurrentButtonState to False
3127>>>>>>>>>        forward send remove_object
3129>>>>>>>>>    End_Procedure
3130>>>>>>>>>
3130>>>>>>>>>    // This is called by notify_focus_change (in std obj mixin). With buttons
3130>>>>>>>>>    // we must make sure that they are always highlighted when the focus and
3130>>>>>>>>>    // not highlighted when the focus is list
3130>>>>>>>>>    //
3130>>>>>>>>>    Procedure PrivateSetCurrentButton
3131>>>>>>>>>        set CurrentButtonState to TRUE
3132>>>>>>>>>    end_Procedure
3133>>>>>>>>>
3133>>>>>>>>>    // if a button is shadowed it should not be highlighted
3133>>>>>>>>>    Procedure Shadow_Display
3134>>>>>>>>>        If (Object_shadow_state(current_object)) ;            set CurrentButtonState to False
3137>>>>>>>>>    End_procedure
3138>>>>>>>>>
3138>>>>>>>>>End_Class
3139>>>>>>>>>
3139>>>>>>>>>
3139>>>>>>>>>
3139>>>>>>>>>
3139>>>>>>>>>//*** Class: Checkbox
3139>>>>>>>>>//***
3139>>>>>>>>>//*** Assumption:
3139>>>>>>>>>//***   Must be one-item object.
3139>>>>>>>>>//***
3139>>>>>>>>>//*** 1. Label support.
3139>>>>>>>>>//*** 2. Will autosize based on setting of label if auto_size_state is True.
3139>>>>>>>>>//*** 3. Standard object mixin behaviors (help, etc.)
3139>>>>>>>>>//*** 4. Single Item behaviors for switching
3139>>>>>>>>>//
3139>>>>>>>>>Class CheckBox is a DFBaseCheckBox
3140>>>>>>>>>
3140>>>>>>>>>    Procedure Construct_Object
3141>>>>>>>>>        Forward Send Construct_Object
3143>>>>>>>>>
3143>>>>>>>>>        Send Define_Standard_Select_Mixin
3144>>>>>>>>>        Send Define_Bitmap_Support_Mixin
3145>>>>>>>>>
3145>>>>>>>>>        Set Select_Mode To Multi_Select
3146>>>>>>>>>    End_Procedure // Construct_Object
3147>>>>>>>>>
3147>>>>>>>>>    Import_Class_Protocol Standard_Select_Mixin
3148>>>>>>>>>    Import_Class_Protocol Bitmap_Support_Mixin
3149>>>>>>>>>
3149>>>>>>>>>End_Class // CheckBox
3150>>>>>>>>>
3150>>>>>>>>>
3150>>>>>>>>>//*** Class: Radiobutton (useful classes are in dfradio.pkg
3150>>>>>>>>>//***
3150>>>>>>>>>//*** Assumption:
3150>>>>>>>>>//***   Must be one-item object.
3150>>>>>>>>>//***
3150>>>>>>>>>//*** 1. Label support.
3150>>>>>>>>>//*** 2. Will autosize based on setting of label.
3150>>>>>>>>>//
3150>>>>>>>>>Class RadioButton Is A DfBaseRadioButton
3151>>>>>>>>>
3151>>>>>>>>>    Procedure Construct_Object
3152>>>>>>>>>        Forward Send Construct_Object
3154>>>>>>>>>
3154>>>>>>>>>        Send Define_Standard_Select_Mixin
3155>>>>>>>>>        Send Define_Bitmap_Support_Mixin
3156>>>>>>>>>
3156>>>>>>>>>        Set Select_Mode  To Single_Select
3157>>>>>>>>>    End_Procedure // Construct_Object
3158>>>>>>>>>
3158>>>>>>>>>    Import_Class_Protocol Standard_Select_Mixin
3159>>>>>>>>>    Import_Class_Protocol Bitmap_Support_Mixin
3160>>>>>>>>>
3160>>>>>>>>>    Procedure Private.Notify_Select_State Integer ObjId Integer Item#
3161>>>>>>>>>    End_Procedure // Private.Notify_Select_State
3162>>>>>>>>>
3162>>>>>>>>>End_Class // RadioButton
3163>>>>>>>>>
3163>>>>>>>>>// Class: MdiClientArea
3163>>>>>>>>>//
3163>>>>>>>>>// 1. Set default properties
3163>>>>>>>>>//
3163>>>>>>>>>Class MdiClientArea Is A DfBaseMdiClient
3164>>>>>>>>>
3164>>>>>>>>>    Procedure Construct_Object
3165>>>>>>>>>        Forward Send Construct_Object
3167>>>>>>>>>        Send Define_RGB_Support_Temp_Mixin
3168>>>>>>>>>        Set Scope_State   To True
3169>>>>>>>>>        Set Attach_Parent_State To True
3170>>>>>>>>>        Set Caption_Bar   To False
3171>>>>>>>>>        Set Maximize_Icon To False
3172>>>>>>>>>        Set Sysmenu_Icon  To False
3173>>>>>>>>>        Set Scroll_Bar_Visible_State To True
3174>>>>>>>>>        Set Border_Style  To BORDER_CLIENTEDGE
3175>>>>>>>>>        Set Object_Color  To WINCOLOR_APPWORKSPACE WINCOLOR_APPWORKSPACE
3176>>>>>>>>>        Set Client_Area_State to False // 05/02/96 -JJT
3177>>>>>>>>>
3177>>>>>>>>>        Send Define_Bitmap_Support_Mixin
3178>>>>>>>>>
3178>>>>>>>>>    End_Procedure
3179>>>>>>>>>
3179>>>>>>>>>    Import_Class_Protocol RGB_Support_Temp_Mixin
3180>>>>>>>>>    Import_Class_Protocol Bitmap_Support_Mixin
3181>>>>>>>>>
3181>>>>>>>>>    Procedure Notify_Focus_Change Integer Fg
3182>>>>>>>>>        //**Forward Send Notify_Focus_Change Fg
3182>>>>>>>>>        if Fg Send OnSetFocus
3185>>>>>>>>>        Else  Send OnKillFocus
3187>>>>>>>>>    End_Procedure // Notify_Focus_Change
3188>>>>>>>>>
3188>>>>>>>>>    Procedure OnSetFocus
3189>>>>>>>>>    end_Procedure
3190>>>>>>>>>
3190>>>>>>>>>    Procedure OnKillFocus
3191>>>>>>>>>    end_Procedure
3192>>>>>>>>>
3192>>>>>>>>>
3192>>>>>>>>>End_Class
3193>>>>>>>>>
3193>>>>>>>>>Define kSwitch_Panel      FOR KEY_ALT+KEY_F6
3193>>>>>>>>>Define kSwitch_Panel_Back FOR KEY_CTRL+KEY_F6
3193>>>>>>>>>
3193>>>>>>>>>// Class: MdiDialog
3193>>>>>>>>>//
3193>>>>>>>>>//  1. Define standard MDI properties
3193>>>>>>>>>//       caption bar, sysmenu, minimize, no-maximize
3193>>>>>>>>>//       attach-prnt-st=T, Scope=T, Ring=T, Popup=T
3193>>>>>>>>>//  2. Define Ctrl+F4 - Close_client (deactivate view)
3193>>>>>>>>>//            Ctrl+F6 - previous view
3193>>>>>>>>>//            Alt+F6  - next view
3193>>>>>>>>>//  3. Define procedures for:
3193>>>>>>>>>//            Switch_next_View, Switch_Prior_View, Close_Client
3193>>>>>>>>>//  4. redefine exit_appication to close_client so sysmenu works.
3193>>>>>>>>>//
3193>>>>>>>>>//
3193>>>>>>>>>Class MdiDialog Is A Container3d
3194>>>>>>>>>
3194>>>>>>>>>    Procedure Construct_Object
3195>>>>>>>>>        Forward Send Construct_Object
3197>>>>>>>>>        Send Define_Panel_Mixin
3198>>>>>>>>>        Set Mdi_State           To True
3199>>>>>>>>>        Set Minimize_Icon       To True
3200>>>>>>>>>        Set Maximize_Icon       To False
3201>>>>>>>>>        Set Sysmenu_Icon        To True
3202>>>>>>>>>        Set Caption_Bar         To True
3203>>>>>>>>>        Set Attach_Parent_State To True
3204>>>>>>>>>        Set Scope_State         To True
3205>>>>>>>>>        Set Ring_State          To True
3206>>>>>>>>>        Set Popup_State         To True
3207>>>>>>>>>
3207>>>>>>>>>        On_Key Kclose_Panel       Send Close_Panel
3208>>>>>>>>>        On_Key Kswitch_Panel      Send Switch_Next_View
3209>>>>>>>>>        On_Key Kswitch_Panel_Back Send Switch_Prior_View
3210>>>>>>>>>
3210>>>>>>>>>    End_Procedure // Construct_Object
3211>>>>>>>>>
3211>>>>>>>>>    Import_Class_protocol Panel_Mixin
3212>>>>>>>>>
3212>>>>>>>>>//    Procedure Exit_Application
3212>>>>>>>>>//        Send Close_Client
3212>>>>>>>>>//    End_Procedure // Exit_Application
3212>>>>>>>>>//
3212>>>>>>>>>//    Procedure Close_Client
3212>>>>>>>>>//        If (Active_State(Current_Object)) ;
3212>>>>>>>>>//            Send Deactivate
3212>>>>>>>>>//    End_Procedure // Close_Client
3212>>>>>>>>>
3212>>>>>>>>>//**   Procedure Switch_Next_View
3212>>>>>>>>>//**     Local Integer Obj
3212>>>>>>>>>//**     Get Next_Focus To Obj
3212>>>>>>>>>//**     If (Obj And Obj<>current_Object) ;
3212>>>>>>>>>//**        Set Current_Scope To Obj
3212>>>>>>>>>//**   End_Procedure // Switch_Next_View
3212>>>>>>>>>//**
3212>>>>>>>>>//**   //  Message To Switch To The Prior View
3212>>>>>>>>>//**   //
3212>>>>>>>>>//**   Procedure Switch_Prior_View
3212>>>>>>>>>//**     Local Integer Obj
3212>>>>>>>>>//**     Get Prior_Focus To Obj
3212>>>>>>>>>//**     If (Obj And Obj<>current_Object) ;
3212>>>>>>>>>//**        Set Current_Scope To Obj
3212>>>>>>>>>//**   End_Procedure // Switch_Prior_View
3212>>>>>>>>>
3212>>>>>>>>>    Procedure Exiting_Scope Integer Whereto Returns Integer
3213>>>>>>>>>        Local Integer Rval Sbid
3214>>>>>>>>>        Forward Get Msg_Exiting_Scope Whereto To Rval
3216>>>>>>>>>        If Not Rval Begin
3218>>>>>>>>>            Get Statusbar_Id To Sbid
3219>>>>>>>>>            If Sbid Send Show_Status_Help To Sbid ''
3222>>>>>>>>>        End
3222>>>>>>>>>>
3222>>>>>>>>>    End_Procedure
3223>>>>>>>>>
3223>>>>>>>>>    //Procedure OnResize
3223>>>>>>>>>    //End_Procedure
3223>>>>>>>>>    //
3223>>>>>>>>>    //Procedure OnPaint
3223>>>>>>>>>    //End_Procedure
3223>>>>>>>>>    //
3223>>>>>>>>>    //Procedure Set GuiSize Integer cy Integer cx
3223>>>>>>>>>    //    Local Integer cxy
3223>>>>>>>>>    //    Get GuiSize To cxy
3223>>>>>>>>>    //    Forward Set GuiSize cy cx
3223>>>>>>>>>    //    If (BuildingObjectId=0 AND ;
3223>>>>>>>>>    //        Window_Handle(current_object) AND ;
3223>>>>>>>>>    //        ( Hi(cxy)<>cy or Low(cxy)<>cx) ) ;
3223>>>>>>>>>    //            Send OnResize
3223>>>>>>>>>    //End_Procedure
3223>>>>>>>>>    //
3223>>>>>>>>>    //Procedure Paint
3223>>>>>>>>>    //    Forward Send Paint
3223>>>>>>>>>    //    Send OnPaint
3223>>>>>>>>>    //End_Procedure
3223>>>>>>>>>
3223>>>>>>>>>End_Class
3224>>>>>>>>>
3224>>>>>>>>>Use dfRadio.pkg  // Radio controls and container support
INCLUDING FILE: DFRADIO.PKG
3224>>>>>>>>>>>// multi object Radio support
3224>>>>>>>>>>>//
3224>>>>>>>>>>>// Class Radio                (control)
3224>>>>>>>>>>>// Class RadioGroup           (group container)
3224>>>>>>>>>>>// Class RadioContainer       (non-visual container)
3224>>>>>>>>>>>
3224>>>>>>>>>>>Use Winbase
3224>>>>>>>>>>>Use DfBase
3224>>>>>>>>>>>Use DFRad_Mx // dfradio_group_mixin class
INCLUDING FILE: DFRAD_MX.PKG
3224>>>>>>>>>>>>>//  Define Mixin group Class
3224>>>>>>>>>>>>>//      DfRadio_group_Mixin
3224>>>>>>>>>>>>>//
3224>>>>>>>>>>>>>// Group Interface
3224>>>>>>>>>>>>>//   Get/Set Current_Radio
3224>>>>>>>>>>>>>//   Get/Set Radio_Value
3224>>>>>>>>>>>>>//   Get/Set Radio_Shadow_State  item# to state
3224>>>>>>>>>>>>>//   Get     Radio_Object        item# to Obj#
3224>>>>>>>>>>>>>//   Get     Radio_Object_Item   Obj#  to item#
3224>>>>>>>>>>>>>//   Get     Radio_Count               to #items
3224>>>>>>>>>>>>>//   Get/Set Current_Radio_Object      to obj#
3224>>>>>>>>>>>>>//   Get/Set Changed_State             to state
3224>>>>>>>>>>>>>//   Set     Shadow_Sta                to state
3224>>>>>>>>>>>>>//
3224>>>>>>>>>>>>>//   Send Notify_Select_State (only for augmentation - do not send)
3224>>>>>>>>>>>>>//   
3224>>>>>>>>>>>>>// Button Interface
3224>>>>>>>>>>>>>//   Set Location
3224>>>>>>>>>>>>>//   Set Size (it autosizes)
3224>>>>>>>>>>>>>//   Set Label (can also use parent's Radio_Label)
3224>>>>>>>>>>>>>//   Set Status_Help
3224>>>>>>>>>>>>>//   Set Select_State 
3224>>>>>>>>>>>>>//   Set Shadow_State (can also use parent's Radio_Shadow_State)
3224>>>>>>>>>>>>>//   Note: Status help for radios will use parent if no help is provided
3224>>>>>>>>>>>>>//         for the radio object
3224>>>>>>>>>>>>>// 
3224>>>>>>>>>>>>>
3224>>>>>>>>>>>>>Class DFRadio_Group_Mixin is a Mixin
3225>>>>>>>>>>>>>  
3225>>>>>>>>>>>>>  Procedure Define_DfRadio_Group_Mixin
3226>>>>>>>>>>>>>     Property Integer Private.Current_Radio_Object public 0
3227>>>>>>>>>>>>>     Property Integer Private.Current_Radio   public -1
3228>>>>>>>>>>>>>     Property Integer In_Group_State public false
3229>>>>>>>>>>>>>     Property Integer Changed_State  public false
3230>>>>>>>>>>>>>     //
3230>>>>>>>>>>>>>     Object Radio_Objects is an Array
3232>>>>>>>>>>>>>     End_Object                           
3233>>>>>>>>>>>>>     //
3233>>>>>>>>>>>>>     Set Client_Area_State to False
3234>>>>>>>>>>>>>     Set Ring_State to TRUE
3235>>>>>>>>>>>>>  End_Procedure // 
3236>>>>>>>>>>>>>
3236>>>>>>>>>>>>>  Procedure Private.notify_select_state integer Newobj integer itemNo
3237>>>>>>>>>>>>>     Local Integer NewItem OldItem OldObj
3238>>>>>>>>>>>>>     Get Current_Radio to OldItem
3239>>>>>>>>>>>>>     Get Radio_Object_Item NewObj to NewItem
3240>>>>>>>>>>>>>     If NewItem ne OldItem Begin
3242>>>>>>>>>>>>>        Get Current_Radio_Object to OldObj
3243>>>>>>>>>>>>>        If OldObj ;           Set Select_State of OldObj item 0 to FALSE
3246>>>>>>>>>>>>>        Set Private.Current_Radio_Object to NewObj
3247>>>>>>>>>>>>>        Set Private.Current_Radio   to NewItem
3248>>>>>>>>>>>>>        Send Notify_select_State NewItem OldItem
3249>>>>>>>>>>>>>     End
3249>>>>>>>>>>>>>>
3249>>>>>>>>>>>>>  End_procedure
3250>>>>>>>>>>>>>
3250>>>>>>>>>>>>>  Procedure notify_select_state integer NewId  integer OldId
3251>>>>>>>>>>>>>  End_procedure
3252>>>>>>>>>>>>>
3252>>>>>>>>>>>>>  Procedure Set Current_Radio integer Item#
3253>>>>>>>>>>>>>     Local integer Obj
3254>>>>>>>>>>>>>     Get Radio_Object item Item# to Obj
3255>>>>>>>>>>>>>     If Obj ;        Set Current_Radio_Object to Obj
3258>>>>>>>>>>>>>  End_procedure
3259>>>>>>>>>>>>>
3259>>>>>>>>>>>>>  Procedure Set Current_Radio_Object integer Obj#
3260>>>>>>>>>>>>>     Local integer OldObj
3261>>>>>>>>>>>>>     Get Current_Radio_Object to OldObj
3262>>>>>>>>>>>>>     Set Select_State of Obj# item 0 to True
3263>>>>>>>>>>>>>     If (focus(desktop)=OldObj) ;        Send Activate
3266>>>>>>>>>>>>>  End_procedure
3267>>>>>>>>>>>>>
3267>>>>>>>>>>>>>  Function Current_Radio returns Integer
3268>>>>>>>>>>>>>     Function_Return (Private.Current_Radio(Current_Object))
3269>>>>>>>>>>>>>  End_Function
3270>>>>>>>>>>>>>
3270>>>>>>>>>>>>>  Function Current_Radio_Object returns Integer
3271>>>>>>>>>>>>>     Function_Return (Private.Current_Radio_Object(Current_Object))
3272>>>>>>>>>>>>>  End_Function
3273>>>>>>>>>>>>>
3273>>>>>>>>>>>>>  
3273>>>>>>>>>>>>>  Procedure Register_Radio_Object Integer Obj#
3274>>>>>>>>>>>>>    Local Integer ArrObj Itm
3275>>>>>>>>>>>>>    Move (Radio_Objects(Current_Object)) to ArrObj
3276>>>>>>>>>>>>>    Get Item_Count  of ArrObj to Itm
3277>>>>>>>>>>>>>    Set array_value of ArrObj item itm to Obj#
3278>>>>>>>>>>>>>  End_Procedure
3279>>>>>>>>>>>>>
3279>>>>>>>>>>>>>  Function Radio_Count Returns integer
3280>>>>>>>>>>>>>    Local Integer Itm
3281>>>>>>>>>>>>>    Get Item_Count of (Radio_Objects(Current_Object)) to Itm
3282>>>>>>>>>>>>>    Function_return Itm
3283>>>>>>>>>>>>>  End_Function
3284>>>>>>>>>>>>>
3284>>>>>>>>>>>>>  Function Radio_Object_Item integer RObj returns integer
3285>>>>>>>>>>>>>     Local integer item# ItmCnt
3286>>>>>>>>>>>>>     Local Integer Obj
3286>>>>>>>>>>>>>     If Robj Begin
3288>>>>>>>>>>>>>        Move (Radio_Objects(Current_Object)) to Obj
3289>>>>>>>>>>>>>        Get Item_Count of Obj to ItmCnt
3290>>>>>>>>>>>>>        Decrement ItmCnt
3291>>>>>>>>>>>>>        For Item# from 0 to ItmCnt
3297>>>>>>>>>>>>>>
3297>>>>>>>>>>>>>            If (Integer_Value(Obj,Item#)=RObj) ;                Function_return Item#
3300>>>>>>>>>>>>>        Loop
3301>>>>>>>>>>>>>>
3301>>>>>>>>>>>>>     End
3301>>>>>>>>>>>>>>
3301>>>>>>>>>>>>>     Function_Return -1
3302>>>>>>>>>>>>>  End_Function
3303>>>>>>>>>>>>>
3303>>>>>>>>>>>>>  Function Radio_Object integer Item# Returns Integer
3304>>>>>>>>>>>>>    Local Integer RObj
3305>>>>>>>>>>>>>    Get Integer_Value of (Radio_Objects(Current_Object)) item Item# to RObj
3306>>>>>>>>>>>>>    Function_Return RObj
3307>>>>>>>>>>>>>  End_Function    
3308>>>>>>>>>>>>>
3308>>>>>>>>>>>>>  Function Radio_Value integer Item# Returns String
3309>>>>>>>>>>>>>    Local Integer RObj
3310>>>>>>>>>>>>>    Local String  RValue
3310>>>>>>>>>>>>>    Get Radio_Object item Item# to rObj
3311>>>>>>>>>>>>>    If Robj ;       Get Label of RObj to RValue
3314>>>>>>>>>>>>>    Function_Return RValue
3315>>>>>>>>>>>>>  End_Function
3316>>>>>>>>>>>>>
3316>>>>>>>>>>>>>  Procedure Set Radio_Value integer Item# String RValue
3317>>>>>>>>>>>>>    Local Integer RObj
3318>>>>>>>>>>>>>    Get Radio_Object item Item# to rObj
3319>>>>>>>>>>>>>    If Robj ;       Set Label of RObj to RValue
3322>>>>>>>>>>>>>  End_Procedure
3323>>>>>>>>>>>>>
3323>>>>>>>>>>>>>  Function Radio_Value integer Item# Returns String
3324>>>>>>>>>>>>>    Local Integer RObj
3325>>>>>>>>>>>>>    Get Radio_Object item Item# to rObj
3326>>>>>>>>>>>>>    If Robj ;       Function_Return (Label(Robj))
3329>>>>>>>>>>>>>  End_Function
3330>>>>>>>>>>>>>
3330>>>>>>>>>>>>>  Procedure Set Radio_Shadow_State integer Item# Integer iState
3331>>>>>>>>>>>>>    Local Integer RObj
3332>>>>>>>>>>>>>    Get Radio_Object item Item# to rObj
3333>>>>>>>>>>>>>    If Robj ;       Set Object_Shadow_State of RObj to iState
3336>>>>>>>>>>>>>  End_Procedure
3337>>>>>>>>>>>>>
3337>>>>>>>>>>>>>  Function Radio_Shadow_State integer Item# Returns Integer
3338>>>>>>>>>>>>>    Local Integer RObj
3339>>>>>>>>>>>>>    Get Radio_Object item Item# to rObj
3340>>>>>>>>>>>>>    If Robj ;       Function_Return (Object_Shadow_State(Robj))
3343>>>>>>>>>>>>>  End_Function
3344>>>>>>>>>>>>>
3344>>>>>>>>>>>>>  Procedure Add_Focus integer RootObj returns integer
3345>>>>>>>>>>>>>     Local integer rVal
3346>>>>>>>>>>>>>     Forward Get MSG_Add_Focus RootObj to rVal
3348>>>>>>>>>>>>>     if not rVal Begin
3350>>>>>>>>>>>>>        broadcast NO_STOP send add_focus current_object
3353>>>>>>>>>>>>>        If (Current_Radio_Object(Current_Object)=0) ;           Set Current_Radio to 0
3356>>>>>>>>>>>>>     end
3356>>>>>>>>>>>>>>
3356>>>>>>>>>>>>>  End_Procedure
3357>>>>>>>>>>>>>
3357>>>>>>>>>>>>>  Procedure Activate returns integer
3358>>>>>>>>>>>>>     Local Integer rVal Obj
3359>>>>>>>>>>>>>     If (Object_Shadow_State(Current_Object)) Procedure_Return ERROR_ENTERING
3362>>>>>>>>>>>>>     Set In_Group_State to True
3363>>>>>>>>>>>>>     If Not (Active_State(Current_Object)) ;        Send Add_Focus (focus(desktop))
3366>>>>>>>>>>>>>     Send Rotate_up
3367>>>>>>>>>>>>>     get Current_radio_Object to Obj
3368>>>>>>>>>>>>>     If Obj eq 0 ;        Get Radio_Object 0 to Obj
3371>>>>>>>>>>>>>     If Obj Get Msg_Activate of Obj to Rval
3374>>>>>>>>>>>>>     Else move 1 to rVal
3376>>>>>>>>>>>>>     Set In_Group_State to False
3377>>>>>>>>>>>>>     Procedure_Return rVal
3378>>>>>>>>>>>>>  End_Procedure // Activate
3379>>>>>>>>>>>>>
3379>>>>>>>>>>>>>  Procedure Mouse_down integer i1 integer i2
3380>>>>>>>>>>>>>  End_Procedure // Mouse_down
3381>>>>>>>>>>>>>
3381>>>>>>>>>>>>>  Procedure Mouse_Click integer i1 integer i2
3382>>>>>>>>>>>>>  End_Procedure // Mouse_Click
3383>>>>>>>>>>>>>
3383>>>>>>>>>>>>>  Procedure update_dependent_items
3384>>>>>>>>>>>>>  End_procedure
3385>>>>>>>>>>>>>
3385>>>>>>>>>>>>>
3385>>>>>>>>>>>>>End_Class
3386>>>>>>>>>>>>>
3386>>>>>>>>>>>>>
3386>>>>>>>>>>>
3386>>>>>>>>>>>
3386>>>>>>>>>>>// Class: Radio
3386>>>>>>>>>>>//
3386>>>>>>>>>>>// Assumption:
3386>>>>>>>>>>>//   Object of this class is child of a "RadioGroup" or 
3386>>>>>>>>>>>//   RadioContainer Object
3386>>>>>>>>>>>//
3386>>>>>>>>>>>// 1. Offers radio functionality in multiple one item radios.
3386>>>>>>>>>>>//
3386>>>>>>>>>>>Class Radio is a RadioButton
3387>>>>>>>>>>>
3387>>>>>>>>>>>   Procedure Construct_Object
3388>>>>>>>>>>>      Forward Send Construct_Object
3390>>>>>>>>>>>      Delegate Send Register_Radio_Object Current_Object
3392>>>>>>>>>>>      On_Key kUpArrow    Send Previous_Item
3393>>>>>>>>>>>      On_Key kDownArrow  Send Next_Item
3394>>>>>>>>>>>      On_Key kLeftArrow  Send Previous_Item
3395>>>>>>>>>>>      On_Key kRightArrow Send Next_Item
3396>>>>>>>>>>>      Set Use_Parent_Status_Help  to True
3397>>>>>>>>>>>   End_Procedure // Construct_Object
3398>>>>>>>>>>>
3398>>>>>>>>>>>   Procedure Activate returns integer
3399>>>>>>>>>>>      Local integer rVal
3400>>>>>>>>>>>      If (In_Group_state(Parent(Current_Object))) Begin
3402>>>>>>>>>>>         Forward Get MSG_Activate to rVal
3404>>>>>>>>>>>         If (rval=0 AND Select_State(Current_Object,0)=0) Begin
3406>>>>>>>>>>>            set select_state item 0 to true
3407>>>>>>>>>>>            Delegate Set Changed_State to TRUE
3409>>>>>>>>>>>         end
3409>>>>>>>>>>>>
3409>>>>>>>>>>>      end
3409>>>>>>>>>>>>
3409>>>>>>>>>>>      Else ;         delegate Get msg_Activate to rVal
3412>>>>>>>>>>>      Procedure_return rVal
3413>>>>>>>>>>>   End_Procedure // Activate
3414>>>>>>>>>>>
3414>>>>>>>>>>>   Procedure Set Select_State integer item# integer state
3415>>>>>>>>>>>      Forward Set Select_State item item# to state
3417>>>>>>>>>>>      If State ;         Delegate Send Private.Notify_Select_state Current_Object 0
3421>>>>>>>>>>>   End_Procedure // Set Select_State
3422>>>>>>>>>>>
3422>>>>>>>>>>>   Procedure Private.Notify_Select_State Integer ObjId Integer Item#
3423>>>>>>>>>>>   //   Delegate Send Private.Notify_Select_state ObjId Item#
3423>>>>>>>>>>>   End_Procedure // Private.Notify_Select_State
3424>>>>>>>>>>>
3424>>>>>>>>>>>   Procedure Select_Toggling
3425>>>>>>>>>>>   End_Procedure // Select_Toggling
3426>>>>>>>>>>>
3426>>>>>>>>>>>   Procedure Next_Item
3427>>>>>>>>>>>     Local integer OldGrp
3428>>>>>>>>>>>     Delegate Get In_Group_State to OldGrp
3430>>>>>>>>>>>     Delegate Set In_Group_State to True
3432>>>>>>>>>>>     Delegate Set Changed_State to TRUE
3434>>>>>>>>>>>     Forward send Switch
3436>>>>>>>>>>>     Delegate Set In_Group_State to OldGrp
3438>>>>>>>>>>>   End_Procedure
3439>>>>>>>>>>>
3439>>>>>>>>>>>   Procedure Previous_Item
3440>>>>>>>>>>>     Local integer OldGrp
3441>>>>>>>>>>>     Delegate Get In_Group_State to OldGrp
3443>>>>>>>>>>>     Delegate Set In_Group_State to True
3445>>>>>>>>>>>     Delegate Set Changed_State to TRUE
3447>>>>>>>>>>>     Forward send Switch_Back
3449>>>>>>>>>>>     Delegate Set In_Group_State to OldGrp
3451>>>>>>>>>>>   End_Procedure
3452>>>>>>>>>>>
3452>>>>>>>>>>>   Procedure Switch
3453>>>>>>>>>>>     Send Switch_Next_Group
3454>>>>>>>>>>>   End_Procedure
3455>>>>>>>>>>>
3455>>>>>>>>>>>   Procedure Switch_Back
3456>>>>>>>>>>>     Send Switch_Prior_Group
3457>>>>>>>>>>>   End_procedure
3458>>>>>>>>>>>
3458>>>>>>>>>>>   Procedure Mouse_Down integer i1 integer i2
3459>>>>>>>>>>>     Local integer OldGrp
3460>>>>>>>>>>>     Delegate Get In_Group_State to OldGrp
3462>>>>>>>>>>>     Delegate Set In_Group_State to True
3464>>>>>>>>>>>     Forward Send Mouse_Down i1 i2
3466>>>>>>>>>>>     Delegate Set In_Group_State to OldGrp
3468>>>>>>>>>>>   End_procedure  
3469>>>>>>>>>>>
3469>>>>>>>>>>>   Procedure Mouse_Click integer i1 integer i2
3470>>>>>>>>>>>   End_procedure  
3471>>>>>>>>>>>
3471>>>>>>>>>>>End_Class
3472>>>>>>>>>>>
3472>>>>>>>>>>>
3472>>>>>>>>>>>
3472>>>>>>>>>>>// Class: RadioGroup
3472>>>>>>>>>>>//
3472>>>>>>>>>>>// Assumption:
3472>>>>>>>>>>>//   Must be used together with one (or more) Radio child objects.
3472>>>>>>>>>>>//
3472>>>>>>>>>>>// 1. Offers radio functionality in multiple one item radios.
3472>>>>>>>>>>>//
3472>>>>>>>>>>>Class RadioGroup is a Group
3473>>>>>>>>>>>  
3473>>>>>>>>>>>  Procedure Construct_Object
3474>>>>>>>>>>>     Forward Send Construct_Object
3476>>>>>>>>>>>     Send Define_DFradio_group_Mixin
3477>>>>>>>>>>>  End_Procedure
3478>>>>>>>>>>>
3478>>>>>>>>>>>  Import_Class_Protocol DfRadio_Group_Mixin
3479>>>>>>>>>>>
3479>>>>>>>>>>>End_Class
3480>>>>>>>>>>>
3480>>>>>>>>>>>// Class: RadioContainer
3480>>>>>>>>>>>//
3480>>>>>>>>>>>// Assumption:
3480>>>>>>>>>>>//   Must be used together with one (or more) Radio child objects.
3480>>>>>>>>>>>//
3480>>>>>>>>>>>// 1. Offers radio functionality in multiple one item radios.
3480>>>>>>>>>>>//
3480>>>>>>>>>>>Class RadioContainer is a RadioGroup
3481>>>>>>>>>>>  Import_Class_Protocol NonVisual_Container_Mixin
3482>>>>>>>>>>>End_Class
3483>>>>>>>>>>>
3483>>>>>>>>>>>
3483>>>>>>>>>Use dfTabdg.pkg  // Tab dialog and tab page support
INCLUDING FILE: DFTABDG.PKG
3483>>>>>>>>>>>// DfTabdg.pkg
3483>>>>>>>>>>>//
3483>>>>>>>>>>>// Low Level Tab Dialog support
3483>>>>>>>>>>>//
3483>>>>>>>>>>>// Class TabDialog
3483>>>>>>>>>>>// Class TabPage
3483>>>>>>>>>>>//
3483>>>>>>>>>>>
3483>>>>>>>>>>>Use Winbase
3483>>>>>>>>>>>Use DfBase
3483>>>>>>>>>>>Use Dftab_mx.pkg // tab dialog support
INCLUDING FILE: DFTAB_MX.PKG
3483>>>>>>>>>>>>>//************************************************************************
3483>>>>>>>>>>>>>// Confidential Trade Secret.
3483>>>>>>>>>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
3483>>>>>>>>>>>>>// as an unpublished work.  All rights reserved.
3483>>>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>//************************************************************************
3483>>>>>>>>>>>>>//************************************************************************
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>// $File name  : Dftab_mx.pkg
3483>>>>>>>>>>>>>// $File title : Tab mixin support for tab page and tab dialog
3483>>>>>>>>>>>>>// Notice      :
3483>>>>>>>>>>>>>// $Author(s)  : John Tuohy
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>// $Rev History
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>//  1/28/98 JJT   Added rgb color support
3483>>>>>>>>>>>>>// JJT  9/4/97    Removed kEnter on_key. This is now handled by container panel.
3483>>>>>>>>>>>>>// JJT ??/??/9?   File created
3483>>>>>>>>>>>>>//************************************************************************
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>//  DfTab_mx.pkg - tab dialog mixin class and non deo tab dialog classes
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>// Defines:
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>//      Tab_Dialog_Mixin        is a Mixin  // mixin for tab dialog
3483>>>>>>>>>>>>>//      Tab_page_Mixin          is a Mixin  // mixin for tab page
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>// Skip_Button_Mode = 0 SBM_NEVER
3483>>>>>>>>>>>>>//                  = 1 SBM_ALWAYS
3483>>>>>>>>>>>>>//                  = 2 SBM_SMART  ** dflt
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>// Pointer_Only_State = T/F      ** F = dflt
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>// Events: Events can be keyboard or Mouse events
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>//        t->t    - Tab button to tab button navigation
3483>>>>>>>>>>>>>//        o->ot   - Non-tab to tab w/ old page navigation
3483>>>>>>>>>>>>>//        o->nt   - Non-tab to tab w/ new page navigation
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>//                            Mouse                       Kbd
3483>>>>>>>>>>>>>//                       t->t    o->ot   o->nt    t->t    o->ot   o->nt
3483>>>>>>>>>>>>>//                     
3483>>>>>>>>>>>>>// skp=always /p=F        B      B      B      D      D      D   
3483>>>>>>>>>>>>>//                     
3483>>>>>>>>>>>>>// skp=always /p=t       (D)     D      D     (D)     D      D   
3483>>>>>>>>>>>>>//                     
3483>>>>>>>>>>>>>// skp=never  /p=F        B      B      B      B      B      B   
3483>>>>>>>>>>>>>//                     
3483>>>>>>>>>>>>>// skp=never /p=T        (D)     D      D     (B)     B      B   
3483>>>>>>>>>>>>>//                     
3483>>>>>>>>>>>>>// skp=smart  /P=F        B      B      D      B      B      D   
3483>>>>>>>>>>>>>//                     
3483>>>>>>>>>>>>>// skp=smart /P=T        (B)     D      D     (B)     D      D   
3483>>>>>>>>>>>>>//                     
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>// Use Windows
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>//  Dftab_mx.pkg - tab dialog mixin class and non deo tab dialog classes
3483>>>>>>>>>>>>>//
3483>>>>>>>>>>>>>// Defines:
3483>>>>>>>>>>>>>//      Tab_Dialog_Mixin        is a Mixin  // mixin for tab dialog
3483>>>>>>>>>>>>>//      Tab_page_Mixin          is a Mixin  // mixin for tab page
3483>>>>>>>>>>>>>
3483>>>>>>>>>>>>>DEFINE RM_None           for 0
3483>>>>>>>>>>>>>DEFINE RM_Ring           for 1
3483>>>>>>>>>>>>>DEFINE RM_Rotate_in_Ring for 2
3483>>>>>>>>>>>>>DEFINE RM_Rotate         for 3
3483>>>>>>>>>>>>>
3483>>>>>>>>>>>>>Define SBM_NEVER         for 0
3483>>>>>>>>>>>>>Define SBM_ALWAYS        for 1
3483>>>>>>>>>>>>>Define SBM_SMART         for 2
3483>>>>>>>>>>>>>
3483>>>>>>>>>>>>>
3483>>>>>>>>>>>>>Register_Function pointer_only_state returns integer
3483>>>>>>>>>>>>>Register_Function Skip_Button_Mode returns integer
3483>>>>>>>>>>>>>
3483>>>>>>>>>>>>>
3483>>>>>>>>>>>>>Class Tab_Dialog_Mixin IS A Mixin
3484>>>>>>>>>>>>>
3484>>>>>>>>>>>>>    Procedure Define_Tab_dialog_Mixin
3485>>>>>>>>>>>>>
3485>>>>>>>>>>>>>        set auto_top_item_state to 0 // don't change - keeps tab buttons
3486>>>>>>>>>>>>>                                     // from resetting to 0 each time they
3486>>>>>>>>>>>>>                                     // activated
3486>>>>>>>>>>>>>
3486>>>>>>>>>>>>>        Property Integer Default_Tab Public 0 // tab to start/return to
3487>>>>>>>>>>>>>
3487>>>>>>>>>>>>>        // How to handle keyboard navigation
3487>>>>>>>>>>>>>        // SBM_NEVER  = don't skip tab in kbd navigation
3487>>>>>>>>>>>>>        // SBM_ALWAYS = skip tab in kbd navigation.
3487>>>>>>>>>>>>>        // SBM_SMART  = Use win95 logic. If not on a tab and the page is
3487>>>>>>>>>>>>>        //              changed go to page else goto tab
3487>>>>>>>>>>>>>        //
3487>>>>>>>>>>>>>        Property Integer Skip_Button_Mode  Public SBM_SMART
3488>>>>>>>>>>>>>
3488>>>>>>>>>>>>>        // If Skip_Button is NOT smart this determines if mouse navigation
3488>>>>>>>>>>>>>        // always give the tab the focus or never gives it the focus. If
3488>>>>>>>>>>>>>        // smart, use same logic as above
3488>>>>>>>>>>>>>        Property Integer Pointer_only_State Public False
3489>>>>>>>>>>>>>
3489>>>>>>>>>>>>>        // tab pages use this as their default rotate mode
3489>>>>>>>>>>>>>        Property Integer Rotate_Mode public RM_NONE
3490>>>>>>>>>>>>>        Property Integer In_Tab_Change_State public false
3491>>>>>>>>>>>>>
3491>>>>>>>>>>>>>        //    Property integer Current_Tab public -1
3491>>>>>>>>>>>>>        On_Key KLeftArrow Send  request_Previous_Tab PRIVATE
3492>>>>>>>>>>>>>        On_Key KRightArrow Send request_next_tab     PRIVATE
3493>>>>>>>>>>>>>
3493>>>>>>>>>>>>>        On_Key Key_Ctrl+Key_TAB Send Request_Next_Tab
3494>>>>>>>>>>>>>
3494>>>>>>>>>>>>>        // Should not be needed....but for now
3494>>>>>>>>>>>>>        On_Key KUpArrow  Send None  PRIVATE
3495>>>>>>>>>>>>>        On_Key KDownArrow Send None PRIVATE
3496>>>>>>>>>>>>>
3496>>>>>>>>>>>>>        //On_Key KEnter Send Next PRIVATE // make enter work like tab
3496>>>>>>>>>>>>>
3496>>>>>>>>>>>>>    End_Procedure
3497>>>>>>>>>>>>>
3497>>>>>>>>>>>>>    // This is a risky thing to do. Some of the packages (server.pkg) use
3497>>>>>>>>>>>>>    // client_area_state to figure out if the object is a client or a form.
3497>>>>>>>>>>>>>    // In order for internal activation of the tab items to work the real
3497>>>>>>>>>>>>>    // internal property client_area_state must be true. However, the
3497>>>>>>>>>>>>>    // external package standpoint client_area_state must be true. This seems
3497>>>>>>>>>>>>>    // to work because the internal client decisions (which uses the real
3497>>>>>>>>>>>>>    // client_area_state property) uses the internal property (it does not
3497>>>>>>>>>>>>>    // get the property by putting the message in the df message queue.
3497>>>>>>>>>>>>>    Function Client_area_state returns integer
3498>>>>>>>>>>>>>       function_return 1
3499>>>>>>>>>>>>>    End_Function // Client_area_state
3500>>>>>>>>>>>>>
3500>>>>>>>>>>>>>    //  Add a tab page. Pass tab name and the page object Id.
3500>>>>>>>>>>>>>    //                  return the tab (item) number of the new page
3500>>>>>>>>>>>>>    Function Add_Tab_item String val Integer tobjid returns integer
3501>>>>>>>>>>>>>        Local Integer NumBtns
3502>>>>>>>>>>>>>        Get Button_Count to NumBtns
3503>>>>>>>>>>>>>        Send Add_item msg_none val
3504>>>>>>>>>>>>>        Set Tab_Page_Id item NumBtns to tobjid
3505>>>>>>>>>>>>>        Function_Return NumBtns
3506>>>>>>>>>>>>>    End_Function
3507>>>>>>>>>>>>>
3507>>>>>>>>>>>>>    //  Get/Set Tab_Page_Id identifies the page object associated with
3507>>>>>>>>>>>>>    //  the tab item
3507>>>>>>>>>>>>>    Procedure Set Tab_page_Id integer item# integer Obj#
3508>>>>>>>>>>>>>        Set Aux_Value item item# to Obj#
3509>>>>>>>>>>>>>    end_Procedure
3510>>>>>>>>>>>>>
3510>>>>>>>>>>>>>    Function Tab_page_id integer item# returns integer
3511>>>>>>>>>>>>>       function_return (Aux_Value(Current_Object,item#))
3512>>>>>>>>>>>>>    End_Function // Tab_page_id
3513>>>>>>>>>>>>>
3513>>>>>>>>>>>>>    //  Button_Count: Number of tab buttons
3513>>>>>>>>>>>>>    //
3513>>>>>>>>>>>>>    Function Button_Count Returns Integer
3514>>>>>>>>>>>>>        Function_return (Item_Count(Current_Object))
3515>>>>>>>>>>>>>    end_Function
3516>>>>>>>>>>>>>
3516>>>>>>>>>>>>>    // The tab that is the current "active" tab. If the tab page is
3516>>>>>>>>>>>>>    // defined and it is not active the current_tab returns -1. If -1
3516>>>>>>>>>>>>>    // you can use item_count to find the tab that is rolled forward
3516>>>>>>>>>>>>>    Function Current_Tab returns integer
3517>>>>>>>>>>>>>       local integer id itm
3518>>>>>>>>>>>>>       If (item_count(Current_Object)) begin
3520>>>>>>>>>>>>>          Get current_item to itm
3521>>>>>>>>>>>>>          get tab_page_id item itm to id
3522>>>>>>>>>>>>>          // if no tab page or tab page is not active there
3522>>>>>>>>>>>>>          // can no current tab
3522>>>>>>>>>>>>>          if (Id=0 OR Active_State(id)=0) ;             Move -1 to itm
3525>>>>>>>>>>>>>          function_return itm
3526>>>>>>>>>>>>>       end
3526>>>>>>>>>>>>>>
3526>>>>>>>>>>>>>       function_return -1
3527>>>>>>>>>>>>>    End_Function
3528>>>>>>>>>>>>>
3528>>>>>>>>>>>>>    // Replace current mouse behavior with out own. This give us more control
3528>>>>>>>>>>>>>    // over the switching behavior.
3528>>>>>>>>>>>>>    Procedure Mouse_Down integer i1 integer i2
3529>>>>>>>>>>>>>        if i1 gt 0 ; // sometimes mouse down gets a 0 - should not happen           Send Request_Switch_to_Tab (i1-1) 1 // 1=kbd
3532>>>>>>>>>>>>>    End_Procedure
3533>>>>>>>>>>>>>
3533>>>>>>>>>>>>>    //Procedure Set Item_Shadow_State integer iItem integer iState
3533>>>>>>>>>>>>>    //   Forward Set Shadow_State item iItem to iState
3533>>>>>>>>>>>>>    //End_Procedure // Set Item_Shadow_State
3533>>>>>>>>>>>>>    //
3533>>>>>>>>>>>>>    //Function Item_Shadow_State integer iItem Returns integer
3533>>>>>>>>>>>>>    //   Local integer iState
3533>>>>>>>>>>>>>    //   Forward Get Shadow_State item iItem to iState
3533>>>>>>>>>>>>>    //   Function_Return iState
3533>>>>>>>>>>>>>    //End_Function // Item_Shadow_State
3533>>>>>>>>>>>>>
3533>>>>>>>>>>>>>
3533>>>>>>>>>>>>>
3533>>>>>>>>>>>>>    //  No Param or 0 - Kbd Navigation
3533>>>>>>>>>>>>>    //              1 - Mouse Navigation
3533>>>>>>>>>>>>>    //              2 - Force to Button
3533>>>>>>>>>>>>>    //              3 - Force to Dialog
3533>>>>>>>>>>>>>    //
3533>>>>>>>>>>>>>    Procedure Request_Previous_Tab integer Mode
3534>>>>>>>>>>>>>        Local Integer tab# Mde oldTab#
3535>>>>>>>>>>>>>
3535>>>>>>>>>>>>>        If num_arguments eq 0 Move 0 to Mde
3538>>>>>>>>>>>>>        Else Move Mode to Mde
3540>>>>>>>>>>>>>
3540>>>>>>>>>>>>>        Get Current_item TO oldtab#
3541>>>>>>>>>>>>>        Move Oldtab# to tab#
3542>>>>>>>>>>>>>        Repeat
3542>>>>>>>>>>>>>>
3542>>>>>>>>>>>>>          Decrement tab#
3543>>>>>>>>>>>>>          If tab# LT 0 Move (Button_Count(Current_Object)-1) TO tab#
3546>>>>>>>>>>>>>          If Tab# eq OldTab# procedure_Return
3549>>>>>>>>>>>>>        Until (Not(Item_Shadow_State(Current_Object,tab#)))
3551>>>>>>>>>>>>>        Send Request_Switch_to_Tab tab# Mde
3552>>>>>>>>>>>>>    End_Procedure
3553>>>>>>>>>>>>>
3553>>>>>>>>>>>>>    Procedure Request_Next_Tab integer Mode
3554>>>>>>>>>>>>>        Local Integer tab# oldtab# Mde
3555>>>>>>>>>>>>>
3555>>>>>>>>>>>>>        If num_arguments eq 0 Move 0 to Mde
3558>>>>>>>>>>>>>        Else Move Mode to Mde
3560>>>>>>>>>>>>>
3560>>>>>>>>>>>>>        Get Current_item TO oldtab#
3561>>>>>>>>>>>>>        Move OldTab# to tab#
3562>>>>>>>>>>>>>        Repeat
3562>>>>>>>>>>>>>>
3562>>>>>>>>>>>>>           Increment tab#
3563>>>>>>>>>>>>>           If (tab#>=Button_Count(Current_Object)) Move 0 TO tab#
3566>>>>>>>>>>>>>           If Tab# eq OldTab# procedure_Return
3569>>>>>>>>>>>>>        Until (Not(Item_Shadow_State(Current_Object,tab#)))
3571>>>>>>>>>>>>>        Send Request_Switch_to_Tab tab# Mde
3572>>>>>>>>>>>>>    End_Procedure
3573>>>>>>>>>>>>>
3573>>>>>>>>>>>>>    //  PonterMode parameter (required):
3573>>>>>>>>>>>>>    //      0 - Keyboard Navigation
3573>>>>>>>>>>>>>    //      1 - Mouse Navigation
3573>>>>>>>>>>>>>    //      2 - Force to Button
3573>>>>>>>>>>>>>    //      3 - Force to Dialog
3573>>>>>>>>>>>>>    Procedure Request_Switch_to_Tab Integer tab# integer PointerMode
3574>>>>>>>>>>>>>        local integer rval foc ctb Skipmode
3575>>>>>>>>>>>>>
3575>>>>>>>>>>>>>        If (Item_Shadow_State(Current_Object,tab#)) procedure_return
3578>>>>>>>>>>>>>        Get Skip_Button_Mode to SkipMode // 0 to button, 1=dialog, 1=smrt
3579>>>>>>>>>>>>>        If PointerMode eq 0 Begin // Kbd Navigation mode
3581>>>>>>>>>>>>>           If SkipMode eq SBM_SMART begin // if smartmode....figure it out
3583>>>>>>>>>>>>>              Get Focus to Foc
3584>>>>>>>>>>>>>              Get Current_Tab to ctb
3585>>>>>>>>>>>>>              If ( ctb=tab# OR Foc=Current_Object ) ;                 Move 0 to PointerMode
3588>>>>>>>>>>>>>              else ;                 Move 1 to PointerMode
3590>>>>>>>>>>>>>           end
3590>>>>>>>>>>>>>>
3590>>>>>>>>>>>>>           else ;              Move SkipMode to PointerMode // 0 to button, 1=dialog
3592>>>>>>>>>>>>>        End
3592>>>>>>>>>>>>>>
3592>>>>>>>>>>>>>        Else If PointerMode eq 1 Begin // Mouse Navigation
3595>>>>>>>>>>>>>           If SkipMode eq SBM_SMART begin // if smartmode....figure it out
3597>>>>>>>>>>>>>              Get Focus to Foc
3598>>>>>>>>>>>>>              Get Current_Tab to ctb
3599>>>>>>>>>>>>>              If ( ctb=tab# OR Foc=Current_Object ) ;                 Move 0 to PointerMode
3602>>>>>>>>>>>>>              else ;                 Move 1 to PointerMode
3604>>>>>>>>>>>>>           end
3604>>>>>>>>>>>>>>
3604>>>>>>>>>>>>>           Else ;              get Pointer_only_State to PointerMode // 0=tab, 1=dialog
3606>>>>>>>>>>>>>        End
3606>>>>>>>>>>>>>>
3606>>>>>>>>>>>>>        Else ; // its 2 or 3, if 3 to dialog, if 2 to button           Move (PointerMode=3) to Pointermode
3608>>>>>>>>>>>>>        get Tab_Change tab# PointerMode to rval
3609>>>>>>>>>>>>>    End_Procedure
3610>>>>>>>>>>>>>
3610>>>>>>>>>>>>>    //  PointerMode: 0 - button takes focus
3610>>>>>>>>>>>>>    //               1 - dialog takes focus
3610>>>>>>>>>>>>>    //               2 - no-one takes focus, just add to focus tree
3610>>>>>>>>>>>>>    //
3610>>>>>>>>>>>>>    // Rule: If the tab dialog object has the focus ;
3610>>>>>>>>>>>>>    //          give the keep the focus in the dialog object.
3610>>>>>>>>>>>>>    //       else if switching pages
3610>>>>>>>>>>>>>    //          Give the focus to the new page
3610>>>>>>>>>>>>>    //       else (tab dialog<>focus, same page)
3610>>>>>>>>>>>>>    //          give the tab the focus
3610>>>>>>>>>>>>>    //
3610>>>>>>>>>>>>>    Function Tab_Change Integer totab Integer PointerMode returns integer
3611>>>>>>>>>>>>>        Local Integer tabobj rval fromtab fromobj toobj focobj oldst
3612>>>>>>>>>>>>>        local string xx
3612>>>>>>>>>>>>>        Get In_Tab_Change_State to OldSt
3613>>>>>>>>>>>>>        set In_Tab_Change_State to true
3614>>>>>>>>>>>>>        Get current_Item to fromtab             // from tab item
3615>>>>>>>>>>>>>
3615>>>>>>>>>>>>>        if (totab gt (item_count( Current_Object))) move fromtab to totab
3618>>>>>>>>>>>>>
3618>>>>>>>>>>>>>        Get tab_page_id item fromtab to fromobj // from tab page
3619>>>>>>>>>>>>>        Get tab_page_id item totab   to toobj   // to tab page
3620>>>>>>>>>>>>>
3620>>>>>>>>>>>>>        // Activate & Roll up correct Tab
3620>>>>>>>>>>>>>        If FromTab ne ToTab Begin
3622>>>>>>>>>>>>>           If (Focus(Current_Object)<>Current_Object) ;                Get Msg_Activate to rval
3625>>>>>>>>>>>>>           If not Rval Begin
3627>>>>>>>>>>>>>              Set Current_item to totab // first set to new tab
3628>>>>>>>>>>>>>              If (current_item(Current_Object)<>totab) Move 1 to rval
3631>>>>>>>>>>>>>           End
3631>>>>>>>>>>>>>>
3631>>>>>>>>>>>>>        End
3631>>>>>>>>>>>>>>
3631>>>>>>>>>>>>>
3631>>>>>>>>>>>>>        // deactivate existing tab page if required
3631>>>>>>>>>>>>>        If (rval=0 AND ;            fromobj AND fromObj<>toObj AND active_state(fromobj)) begin
3633>>>>>>>>>>>>>              Get Deactivate_Tab fromtab fromobj to rval
3634>>>>>>>>>>>>>              If rVal ;                         // if deactivate failed restore                 Set Current_Item to fromobj   // original tab and exit
3637>>>>>>>>>>>>>        End
3637>>>>>>>>>>>>>>
3637>>>>>>>>>>>>>
3637>>>>>>>>>>>>>        // At this point new tab is current item (and maybe focus)
3637>>>>>>>>>>>>>        // and new page is not yet active
3637>>>>>>>>>>>>>
3637>>>>>>>>>>>>>        // Add focus of new tab page if required
3637>>>>>>>>>>>>>        If (rval=0 AND ;            toobj AND active_state(toobj)=0) begin
3639>>>>>>>>>>>>>                 set focus_mode of toobj to focusable
3640>>>>>>>>>>>>>                 get msg_add_focus of toobj Current_Object to rval
3641>>>>>>>>>>>>>        End
3641>>>>>>>>>>>>>>
3641>>>>>>>>>>>>>        // Activate either Tab dialog, Tab page, or nothing
3641>>>>>>>>>>>>>        //
3641>>>>>>>>>>>>>        if (rval=0 AND ;            pointerMode<>2) Begin
3643>>>>>>>>>>>>>              If (Toobj=0 OR PointerMode=0) ;                 Move Current_Object to focObj
3646>>>>>>>>>>>>>              Else ;                 Move ToObj to focobj
3648>>>>>>>>>>>>>              if (focus(Current_Object)<>focobj) ;                 Get Msg_activate of focobj to rval // force button to take focus.
3651>>>>>>>>>>>>>        end
3651>>>>>>>>>>>>>>
3651>>>>>>>>>>>>>        Set In_Tab_Change_State to OldSt
3652>>>>>>>>>>>>>
3652>>>>>>>>>>>>>        function_return rval
3653>>>>>>>>>>>>>    End_Function
3654>>>>>>>>>>>>>
3654>>>>>>>>>>>>>    Function Deactivate_Tab Integer tab# Integer tabpageobj Returns integer
3655>>>>>>>>>>>>>        local integer rval
3656>>>>>>>>>>>>>        Get Msg_Deactivate of tabpageobj 0 to rval
3657>>>>>>>>>>>>>        Procedure_Return rval
3658>>>>>>>>>>>>>    End_Function
3659>>>>>>>>>>>>>
3659>>>>>>>>>>>>>    //  Display passed tab page. If no value (or -1) use default tab
3659>>>>>>>>>>>>>    //  display = add to focus tree if needed, rotate up, do not activate
3659>>>>>>>>>>>>>    //
3659>>>>>>>>>>>>>    Procedure Request_Tab_display integer Tab#
3660>>>>>>>>>>>>>       local integer tb rval
3661>>>>>>>>>>>>>       if (Num_arguments=0 OR tab#=-1) Get default_tab to tb
3664>>>>>>>>>>>>>       else move Tab# to tb
3666>>>>>>>>>>>>>       get Tab_Change tb 2 to rval // 2 means don't take focus
3667>>>>>>>>>>>>>    End_procedure
3668>>>>>>>>>>>>>
3668>>>>>>>>>>>>>    //  Augment to give the default tab the focus
3668>>>>>>>>>>>>>    //
3668>>>>>>>>>>>>>    procedure Top_of_Panel
3669>>>>>>>>>>>>>      local integer id
3670>>>>>>>>>>>>>      If (Button_Count(Current_Object)=0) ;          Forward Send Top_of_Panel
3674>>>>>>>>>>>>>      Else Begin
3675>>>>>>>>>>>>>          Get Default_Tab to Id
3676>>>>>>>>>>>>>          Send Request_Switch_To_Tab id 1
3677>>>>>>>>>>>>>      end
3677>>>>>>>>>>>>>>
3677>>>>>>>>>>>>>    end_procedure
3678>>>>>>>>>>>>>
3678>>>>>>>>>>>>>    // Augment to add the default tab page to the focus tree
3678>>>>>>>>>>>>>    procedure add_focus integer root returns integer
3679>>>>>>>>>>>>>        local integer rval
3680>>>>>>>>>>>>>        forward get MSG_add_focus root to rval
3682>>>>>>>>>>>>>        if not rval ;           Send Request_tab_display // make sure dflt tab is rotated up
3685>>>>>>>>>>>>>        procedure_return rval
3686>>>>>>>>>>>>>    end_procedure
3687>>>>>>>>>>>>>
3687>>>>>>>>>>>>>    // Most tab navigation events are controlled by the class and activate
3687>>>>>>>>>>>>>    // messages are sent in the middle of these events. When this occurs the
3687>>>>>>>>>>>>>    // private property In_tab_change_state is true. In some cases of
3687>>>>>>>>>>>>>    // keyboard navigation from outside the object activate is called directly.
3687>>>>>>>>>>>>>    // This should never happen with no active tab page (because add_focus
3687>>>>>>>>>>>>>    // takes care of this). In such a case, we must decide if activate should
3687>>>>>>>>>>>>>    // keep the focus (the tab) or give it to the page. If smart mode or always
3687>>>>>>>>>>>>>    // mode go the tab button else go to button (normal activate behavior)
3687>>>>>>>>>>>>>    //
3687>>>>>>>>>>>>>    Procedure Activate returns integer
3688>>>>>>>>>>>>>       local integer tb rv
3689>>>>>>>>>>>>>       If (active_state(Current_Object) AND Object_shadow_state(Current_Object)) ;         Procedure_return 1
3692>>>>>>>>>>>>>
3692>>>>>>>>>>>>>       Forward Get MSG_Activate to rV // this will give button the focus
3694>>>>>>>>>>>>>       // if this is not part of tab_change we might want to give the page the
3694>>>>>>>>>>>>>       // focus
3694>>>>>>>>>>>>>       if (rv=0 AND In_Tab_Change_State(Current_Object)=0) begin
3696>>>>>>>>>>>>>          Get current_tab to tb
3697>>>>>>>>>>>>>          if (tb>-1 AND ; // if tab is not yet active (should not happen              (Skip_Button_Mode(Current_Object)<>SBM_NEVER ) ) begin
3699>>>>>>>>>>>>>                  get tab_page_id item tb to tb        // force focus to
3700>>>>>>>>>>>>>                  if tb Get Msg_activate of tb to rv   // page
3703>>>>>>>>>>>>>          end
3703>>>>>>>>>>>>>>
3703>>>>>>>>>>>>>       end
3703>>>>>>>>>>>>>>
3703>>>>>>>>>>>>>       procedure_return rv
3704>>>>>>>>>>>>>    End_Procedure // Activate
3705>>>>>>>>>>>>>
3705>>>>>>>>>>>>>End_Class
3706>>>>>>>>>>>>>
3706>>>>>>>>>>>>>
3706>>>>>>>>>>>>>Class Tab_page_Mixin is a Mixin
3707>>>>>>>>>>>>>
3707>>>>>>>>>>>>>
3707>>>>>>>>>>>>>   Procedure Define_Tab_Page_Mixin
3708>>>>>>>>>>>>>      Local integer obj mode clr
3709>>>>>>>>>>>>>
3709>>>>>>>>>>>>>      Property integer Tab_Button_item public -1
3710>>>>>>>>>>>>>      Property Integer Rotate_Mode private RM_NONE
3711>>>>>>>>>>>>>      Delegate Get Rotate_mode to Mode
3713>>>>>>>>>>>>>      Set Rotate_mode to Mode
3714>>>>>>>>>>>>>
3714>>>>>>>>>>>>>      Set Border_Style to Border_None
3715>>>>>>>>>>>>>      Set Popup_State to True
3716>>>>>>>>>>>>>      Set Attach_parent_state to True
3717>>>>>>>>>>>>>
3717>>>>>>>>>>>>>         Delegate Get Color to clr
3719>>>>>>>>>>>>>         Set Color to Clr
3720>>>>>>>>>>>>>         Delegate Get TextColor to clr
3722>>>>>>>>>>>>>         Set TextColor to Clr
3723>>>>>>>>>>>>>
3723>>>>>>>>>>>>>      Move Current_Object to obj
3724>>>>>>>>>>>>>      Set Label to '' // forces tab button to get created
3725>>>>>>>>>>>>>   end_procedure
3726>>>>>>>>>>>>>
3726>>>>>>>>>>>>>    Procedure Page Integer bState
3727>>>>>>>>>>>>>        if (bstate and GUILocation(Current_Object)=0) Send Auto_Page Current_Object
3730>>>>>>>>>>>>>        Forward Send Page bState
3732>>>>>>>>>>>>>    End_Procedure
3733>>>>>>>>>>>>>
3733>>>>>>>>>>>>>   Function Rotate_Mode returns integer
3734>>>>>>>>>>>>>      function_return (!$.Rotate_mode(Current_Object))
3735>>>>>>>>>>>>>   end_function
3736>>>>>>>>>>>>>
3736>>>>>>>>>>>>>   Procedure Set Rotate_mode integer mode
3737>>>>>>>>>>>>>      Set !$.Rotate_mode to mode
3738>>>>>>>>>>>>>      Set Ring_State to (Mode<>RM_NONE)
3739>>>>>>>>>>>>>   end_Procedure
3740>>>>>>>>>>>>>
3740>>>>>>>>>>>>>   // Augment to activate button if needed.
3740>>>>>>>>>>>>>   Procedure Activate returns integer
3741>>>>>>>>>>>>>      Local integer rVal tabitem curtab
3742>>>>>>>>>>>>>      Get tab_button_item to tabitem   // this page's tab item #
3743>>>>>>>>>>>>>      delegate get Current_item to CurTab        // the current tab number
3745>>>>>>>>>>>>>      // If we have a button and it is not yet active then this
3745>>>>>>>>>>>>>      // activate was sent directly. We need to make it go through
3745>>>>>>>>>>>>>      // the dialog logic (which will send activate here again with
3745>>>>>>>>>>>>>      // tab_active_state set true)
3745>>>>>>>>>>>>>      if ( tabitem>=0 AND tabItem<>curtab ) ;         Delegate Get Tab_Change tabItem 2 to rval // 2=force to page
3749>>>>>>>>>>>>>      else ;         Forward Get MSG_Activate to rval
3752>>>>>>>>>>>>>      Procedure_Return rVal
3753>>>>>>>>>>>>>   End_procedure
3754>>>>>>>>>>>>>
3754>>>>>>>>>>>>>   Procedure set value integer item# string val
3755>>>>>>>>>>>>>      local integer co id
3756>>>>>>>>>>>>>      Forward Set value item item# to val
3758>>>>>>>>>>>>>      Move Current_Object to co
3759>>>>>>>>>>>>>      Get tab_button_item to id
3760>>>>>>>>>>>>>      If id eq -1 begin
3762>>>>>>>>>>>>>         delegate Get add_tab_item val co to id
3764>>>>>>>>>>>>>         Set Tab_button_item to id
3765>>>>>>>>>>>>>      end
3765>>>>>>>>>>>>>>
3765>>>>>>>>>>>>>      else ;         delegate Set Value item id to val
3768>>>>>>>>>>>>>   End_Procedure // set value
3769>>>>>>>>>>>>>
3769>>>>>>>>>>>>>   //  Augment to force focus to correct spot based on rotate_mode,
3769>>>>>>>>>>>>>   //  skip_button_mode and pointer_only_state.
3769>>>>>>>>>>>>>   //
3769>>>>>>>>>>>>>   procedure Child_wrapping integer dir integer id
3770>>>>>>>>>>>>>     local integer rs rval pg
3771>>>>>>>>>>>>>     Move 1 to rval
3772>>>>>>>>>>>>>     get rotate_mode to rs
3773>>>>>>>>>>>>>     Delegate get current_Item to pg
3775>>>>>>>>>>>>>     if (rs=RM_NONE or rs=RM_RING) Begin
3777>>>>>>>>>>>>>        If (Rs=RM_Ring AND Skip_Button_Mode(Current_Object)<>SBM_ALWAYS) ;          delegate Send Request_switch_to_Tab pg 2 // force to Button
3781>>>>>>>>>>>>>          //delegate Send Activate // will force to tab
3781>>>>>>>>>>>>>        else begin
3782>>>>>>>>>>>>>          If Num_Arguments eq 1 ;             forward get msg_child_wrapping dir to rval
3786>>>>>>>>>>>>>          else forward get msg_child_wrapping dir id to rval
3789>>>>>>>>>>>>>        end
3789>>>>>>>>>>>>>>
3789>>>>>>>>>>>>>     End
3789>>>>>>>>>>>>>>
3789>>>>>>>>>>>>>     else begin
3790>>>>>>>>>>>>>       Delegate get current_Item to pg
3792>>>>>>>>>>>>>       if dir Begin
3794>>>>>>>>>>>>>          If (Rs=RM_Rotate_in_ring OR ;              pg< (Button_count(Current_Object)-1) ) ;                send Request_Next_Tab
3797>>>>>>>>>>>>>          Else Begin
3798>>>>>>>>>>>>>             Set Rotate_mode to RM_NONE
3799>>>>>>>>>>>>>             Delegate Send switch // switch_next_area
3801>>>>>>>>>>>>>             Set Rotate_mode to RM_Rotate
3802>>>>>>>>>>>>>          end
3802>>>>>>>>>>>>>>
3802>>>>>>>>>>>>>       end
3802>>>>>>>>>>>>>>
3802>>>>>>>>>>>>>       else begin
3803>>>>>>>>>>>>>          If (Rs=RM_Rotate_in_ring OR pg>0 ) ;             Send Request_Previous_Tab
3806>>>>>>>>>>>>>          else Begin
3807>>>>>>>>>>>>>             Set Rotate_mode to RM_NONE
3808>>>>>>>>>>>>>             Delegate Send Switch_back // switch_Prior_area
3810>>>>>>>>>>>>>             Set Rotate_mode to RM_Rotate
3811>>>>>>>>>>>>>          end
3811>>>>>>>>>>>>>>
3811>>>>>>>>>>>>>       end
3811>>>>>>>>>>>>>>
3811>>>>>>>>>>>>>     end
3811>>>>>>>>>>>>>>
3811>>>>>>>>>>>>>     procedure_return rval
3812>>>>>>>>>>>>>   end_procedure
3813>>>>>>>>>>>>>
3813>>>>>>>>>>>>>   Procedure Set Tab_ToolTip_Value String Val
3814>>>>>>>>>>>>>      local integer itm
3815>>>>>>>>>>>>>      Get Tab_Button_Item to itm
3816>>>>>>>>>>>>>      If itm ge 0 Delegate set tooltip_value item itm to val
3820>>>>>>>>>>>>>   End_Procedure
3821>>>>>>>>>>>>>
3821>>>>>>>>>>>>>   Function Tab_ToolTip_Value returns string
3822>>>>>>>>>>>>>      local integer itm
3823>>>>>>>>>>>>>      local string rval
3823>>>>>>>>>>>>>      Get Tab_Button_Item to itm
3824>>>>>>>>>>>>>      Delegate Get tooltip_value item itm to rval
3826>>>>>>>>>>>>>      function_return rval
3827>>>>>>>>>>>>>   end_function
3828>>>>>>>>>>>>>
3828>>>>>>>>>>>>>    Procedure Set Button_Shadow_State integer iState
3829>>>>>>>>>>>>>      local integer itm
3830>>>>>>>>>>>>>      Get Tab_Button_Item to itm
3831>>>>>>>>>>>>>      Delegate Set Item_Shadow_State item itm to iState
3833>>>>>>>>>>>>>    End_Procedure // Set Button_Shadow_State
3834>>>>>>>>>>>>>
3834>>>>>>>>>>>>>    Function Button_Shadow_State returns integer
3835>>>>>>>>>>>>>      local integer itm iState
3836>>>>>>>>>>>>>      Get Tab_Button_Item to itm
3837>>>>>>>>>>>>>      Delegate Get Item_Shadow_State item itm to iState
3839>>>>>>>>>>>>>      Function_Return iState
3840>>>>>>>>>>>>>    End_Function // Button_Shadow_State
3841>>>>>>>>>>>>>
3841>>>>>>>>>>>>>    // override for desktop in val_mx which does not work well with tab
3841>>>>>>>>>>>>>    // pages. If page is not active, delegate to parent (tab dialog) and
3841>>>>>>>>>>>>>    // activate it. Then, if still not active and parent is active, activate
3841>>>>>>>>>>>>>    // the page.
3841>>>>>>>>>>>>>    // This is only sent during DEO validation
3841>>>>>>>>>>>>>    Procedure Activate_Area Integer TakeFocusFg
3842>>>>>>>>>>>>>     // If not in focus tree make sure the tab dialog
3842>>>>>>>>>>>>>     // is also in focus before proceeding
3842>>>>>>>>>>>>>     If not (Active_State(self)) begin
3844>>>>>>>>>>>>>        Delegate Send Activate_Area False
3846>>>>>>>>>>>>>        // now give the tab page the focus (if needed). Also
3846>>>>>>>>>>>>>        // only do this if the tab dialog parent is active.
3846>>>>>>>>>>>>>        // (if not active, some error occurred)
3846>>>>>>>>>>>>>        If ( Active_state(Parent(self)) AND Not(Active_State(self)) ) ;            Send Activate
3849>>>>>>>>>>>>>     end
3849>>>>>>>>>>>>>>
3849>>>>>>>>>>>>>End_Procedure
3850>>>>>>>>>>>>>
3850>>>>>>>>>>>>>End_class
3851>>>>>>>>>>>
3851>>>>>>>>>>>Enumeration_List
3851>>>>>>>>>>>    Define twRaggedRight
3851>>>>>>>>>>>    Define twRightJustify
3851>>>>>>>>>>>    Define twFixedWidth
3851>>>>>>>>>>>End_Enumeration_List
3851>>>>>>>>>>>
3851>>>>>>>>>>>// Class: TabDialog
3851>>>>>>>>>>>//
3851>>>>>>>>>>>//  1. Define Standard container behaviors
3851>>>>>>>>>>>//  2. Mixin Tab-dialog support
3851>>>>>>>>>>>//  3. Cancel Set Label
3851>>>>>>>>>>>//
3851>>>>>>>>>>>Class TabDialog Is A DfBaseTabDialog
3852>>>>>>>>>>>
3852>>>>>>>>>>>    Procedure Construct_Object
3853>>>>>>>>>>>        Forward Send Construct_Object
3855>>>>>>>>>>>        Property Integer Private.MultiLine_State  Public False
3856>>>>>>>>>>>        Property Integer Private.Buttons_State    Public False
3857>>>>>>>>>>>        Property Integer Private.TabWidth_Mode    Public twRaggedRight
3858>>>>>>>>>>>        Send Define_Standard_Container_Mixin
3859>>>>>>>>>>>        Send Define_Tab_Dialog_Mixin
3860>>>>>>>>>>>    End_Procedure // Construct_Object
3861>>>>>>>>>>>
3861>>>>>>>>>>>    Import_Class_Protocol Standard_Container_Mixin
3862>>>>>>>>>>>    Import_Class_Protocol Tab_Dialog_Mixin
3863>>>>>>>>>>>
3863>>>>>>>>>>>    // Must Cancel. Values Are The Tab Items
3863>>>>>>>>>>>    Procedure Set Label String Val
3864>>>>>>>>>>>    End_Procedure
3865>>>>>>>>>>>
3865>>>>>>>>>>>    Procedure OnResize
3866>>>>>>>>>>>    End_Procedure
3867>>>>>>>>>>>
3867>>>>>>>>>>>    Procedure Set GuiSize Integer cy Integer cx
3868>>>>>>>>>>>        Local Integer cxy
3869>>>>>>>>>>>        Get GuiSize To cxy
3870>>>>>>>>>>>        Forward Set GuiSize to cy cx
3872>>>>>>>>>>>        If (BuildingObjectId=0 AND ;            Window_Handle(current_object) AND ;            ( Hi(cxy)<>cy or Low(cxy)<>cx) ) ;                Send OnResize
3875>>>>>>>>>>>    End_Procedure
3876>>>>>>>>>>>
3876>>>>>>>>>>>    Procedure Page Integer iState
3877>>>>>>>>>>>        Set Window_Style To TCS_MULTILINE    (Private.MultiLine_State(current_object))
3878>>>>>>>>>>>        Set Window_Style To TCS_BUTTONS      (Private.Buttons_State(current_object))
3879>>>>>>>>>>>        Set Window_Style To TCS_RIGHTJUSTIFY (Private.TabWidth_Mode(current_object) = twRightJustify)
3880>>>>>>>>>>>        Set Window_Style To TCS_RAGGEDRIGHT  (Private.TabWidth_Mode(current_object) = twRaggedRight)
3881>>>>>>>>>>>        Set Window_Style To TCS_FIXEDWIDTH   (Private.TabWidth_Mode(current_object) = twFixedWidth)
3882>>>>>>>>>>>        Forward Send Page iState
3884>>>>>>>>>>>        If (iState =1) Send OnResize
3887>>>>>>>>>>>    End_Procedure
3888>>>>>>>>>>>
3888>>>>>>>>>>>    Procedure Set Buttons_State Integer bButtons
3889>>>>>>>>>>>        Local Handle hWnd
3890>>>>>>>>>>>        Local Integer iStyle iVoid
3890>>>>>>>>>>>        Set Private.Buttons_State To bButtons
3891>>>>>>>>>>>        Get Window_Handle To hWnd
3892>>>>>>>>>>>        If hWnd Begin
3894>>>>>>>>>>>            Move (GetWindowLong(hWnd, GWL_STYLE)) To iStyle
3895>>>>>>>>>>>            If bButtons Move (AddBitValue(TCS_BUTTONS, iStyle))    To iStyle
3898>>>>>>>>>>>            Else        Move (RemoveBitValue(TCS_BUTTONS, iStyle)) To iStyle
3900>>>>>>>>>>>            Move (SetWindowLong(hWnd, GWL_STYLE, iStyle)) To iVoid
3901>>>>>>>>>>>        End
3901>>>>>>>>>>>>
3901>>>>>>>>>>>    End_Procedure
3902>>>>>>>>>>>    Function Buttons_State Returns Integer
3903>>>>>>>>>>>        Function_Return (Private.Buttons_State(current_object))
3904>>>>>>>>>>>    End_Function
3905>>>>>>>>>>>
3905>>>>>>>>>>>    Procedure Set MultiLine_State Integer bMultiLine
3906>>>>>>>>>>>        Local Handle hWnd
3907>>>>>>>>>>>        Local Integer iStyle iVoid
3907>>>>>>>>>>>        Set Private.MultiLine_State To bMultiLine
3908>>>>>>>>>>>        Get Window_Handle To hWnd
3909>>>>>>>>>>>        If hWnd Begin
3911>>>>>>>>>>>            Move (GetWindowLong(hWnd, GWL_STYLE)) To iStyle
3912>>>>>>>>>>>            If bMultiLine Move (AddBitValue(TCS_MULTILINE, iStyle))    To iStyle
3915>>>>>>>>>>>            Else        Move (RemoveBitValue(TCS_MULTILINE, iStyle)) To iStyle
3917>>>>>>>>>>>            Move (SetWindowLong(hWnd, GWL_STYLE, iStyle)) To iVoid
3918>>>>>>>>>>>        End
3918>>>>>>>>>>>>
3918>>>>>>>>>>>    End_Procedure
3919>>>>>>>>>>>    Function MultiLine_State Returns Integer
3920>>>>>>>>>>>        Function_Return (Private.MultiLine_State(current_object))
3921>>>>>>>>>>>    End_Function
3922>>>>>>>>>>>
3922>>>>>>>>>>>    Procedure Set TabWidth_Mode Integer iMode
3923>>>>>>>>>>>        Local Handle hWnd
3924>>>>>>>>>>>        Local Integer iStyle iVoid
3924>>>>>>>>>>>        Set Private.TabWidth_Mode To iMode
3925>>>>>>>>>>>        Get Window_Handle To hWnd
3926>>>>>>>>>>>        If hWnd Begin
3928>>>>>>>>>>>            Move (GetWindowLong(hWnd, GWL_STYLE)) To iStyle
3929>>>>>>>>>>>
3929>>>>>>>>>>>            Move (RemoveBitValue(TCS_RIGHTJUSTIFY, iStyle)) To iStyle
3930>>>>>>>>>>>            Move (RemoveBitValue(TCS_RAGGEDRIGHT, iStyle)) To iStyle
3931>>>>>>>>>>>            Move (RemoveBitValue(TCS_FIXEDWIDTH, iStyle)) To iStyle
3932>>>>>>>>>>>
3932>>>>>>>>>>>            If      iMode eq twRightJustify Move (AddBitValue(TCS_RIGHTJUSTIFY, iStyle)) To iStyle
3935>>>>>>>>>>>            Else If iMode eq twRaggedRight  Move (AddBitValue(TCS_RAGGEDRIGHT, iStyle))  To iStyle
3939>>>>>>>>>>>            Else If iMode eq twFixedWidth   Move (AddBitValue(TCS_FIXEDWIDTH, iStyle))   To iStyle
3943>>>>>>>>>>>
3943>>>>>>>>>>>            Move (SetWindowLong(hWnd, GWL_STYLE, iStyle)) To iVoid
3944>>>>>>>>>>>        End
3944>>>>>>>>>>>>
3944>>>>>>>>>>>    End_Procedure
3945>>>>>>>>>>>    Function TabWidth_Mode Returns Integer
3946>>>>>>>>>>>        Function_Return (Private.TabWidth_Mode(current_object))
3947>>>>>>>>>>>    End_Function
3948>>>>>>>>>>>
3948>>>>>>>>>>>    Function NumberOfRows Returns Integer
3949>>>>>>>>>>>        Local Handle hWnd
3950>>>>>>>>>>>        Get Window_Handle To hWnd
3951>>>>>>>>>>>        If hWnd Function_Return (SendMessage(hWnd, TCM_GetRowCount,0,0))
3954>>>>>>>>>>>        Else Function_Return -1
3956>>>>>>>>>>>    End_Function
3957>>>>>>>>>>>
3957>>>>>>>>>>>    Procedure Mouse_Drag //cancelled to stop rotation of tab-pages
3958>>>>>>>>>>>    End_Procedure
3959>>>>>>>>>>>
3959>>>>>>>>>>>End_Class
3960>>>>>>>>>>>
3960>>>>>>>>>>>
3960>>>>>>>>>>>// Class: TabPage
3960>>>>>>>>>>>//
3960>>>>>>>>>>>//  1. Import all tab page behaviors
3960>>>>>>>>>>>//  2. Understand get/set Label (sets tab values)
3960>>>>>>>>>>>//
3960>>>>>>>>>>>Class TabPage is a Container3d
3961>>>>>>>>>>>
3961>>>>>>>>>>>    Procedure Construct_Object
3962>>>>>>>>>>>        Forward Send Construct_Object
3964>>>>>>>>>>>        Send Define_Tab_Page_Mixin
3965>>>>>>>>>>>    End_Procedure // Construct_Object
3966>>>>>>>>>>>
3966>>>>>>>>>>>    Import_Class_Protocol Tab_Page_Mixin
3967>>>>>>>>>>>
3967>>>>>>>>>>>End_Class
3968>>>>>>>>>Use dfCmbfrm.pkg // Combo form and entry support
INCLUDING FILE: DFCMBFRM.PKG
3968>>>>>>>>>>>// 07/23/96 JJT - New Class names
3968>>>>>>>>>>>// 08/07/97 JJT - Added capslock_state support to entry and form combos
3968>>>>>>>>>>>use combo_mx.pkg
INCLUDING FILE: COMBO_MX.PKG
3968>>>>>>>>>>>>>use windows
3968>>>>>>>>>>>>>
3968>>>>>>>>>>>>>//  8/2/97  JJT  Made item_changed_state in combo_edit_changed unconditional.
3968>>>>>>>>>>>>>//               (DFCentry.pkg modified to forward to combo_edit_changed and
3968>>>>>>>>>>>>>//                combo_item_changed)
3968>>>>>>>>>>>>>// 06/13/97 JVH  Modified Combo_Edit_Changed so that it sends OnChange. It looks
3968>>>>>>>>>>>>>//               like it used to do this and was commented out (don't know why).
3968>>>>>>>>>>>>>// 04/01/97 JJT  Fixed all OEM to ANSI / ANSI to OEM problems
3968>>>>>>>>>>>>>
3968>>>>>>>>>>>>>class Combo_Mixin is a Mixin
3969>>>>>>>>>>>>>
3969>>>>>>>>>>>>>    Procedure Define_Combo_Mixin
3970>>>>>>>>>>>>>      // bug fix... Remove when C code is right!
3970>>>>>>>>>>>>>      Set Focus_Mode of (Combo_data_Object(Current_Object)) to NO_ACTIVATE
3971>>>>>>>>>>>>>      // not implemented
3971>>>>>>>>>>>>>      Property Integer Combo_Sort_State   Public  TRUE
3972>>>>>>>>>>>>>      // not implemented
3972>>>>>>>>>>>>>      Property Integer Maximum_Rows       Public  8
3973>>>>>>>>>>>>>      Property Integer Allow_Blank_State  Public False
3974>>>>>>>>>>>>>      Property Integer Deferred_State     Public False
3975>>>>>>>>>>>>>      Property Integer Default_Combo_Item Public -1 // -1 means top
3976>>>>>>>>>>>>>      Send define_standard_Form_Mixin
3977>>>>>>>>>>>>>    End_Procedure
3978>>>>>>>>>>>>>
3978>>>>>>>>>>>>>    Import_Class_Protocol Standard_Form_Mixin
3979>>>>>>>>>>>>>
3979>>>>>>>>>>>>>  //Procedure Set Form_Style_NoEnter integer state
3979>>>>>>>>>>>>>  //end_procedure
3979>>>>>>>>>>>>>
3979>>>>>>>>>>>>>  Procedure Command integer i1 integer i2
3980>>>>>>>>>>>>>    local integer param
3981>>>>>>>>>>>>>    Forward Send Command i1 i2
3983>>>>>>>>>>>>>    Move (hi(i1)) to param
3984>>>>>>>>>>>>>    //showln "Command " (hi(i1)) ' ' (low(i2)) ' ' i2
3984>>>>>>>>>>>>>    If param eq CBN_SELCHANGE Send Combo_Item_Changed
3987>>>>>>>>>>>>>    Else if (param=CBN_EDITCHANGE OR param=CBN_EDITUPDATE) send Combo_Edit_Changed
3991>>>>>>>>>>>>>    Else If Param eq CBN_DROPDOWN Send OnDropDown
3995>>>>>>>>>>>>>    Else If Param eq CBN_CLOSEUP  Send OnCloseUp
3999>>>>>>>>>>>>>  end_procedure
4000>>>>>>>>>>>>>
4000>>>>>>>>>>>>>  Procedure combo_item_Changed
4001>>>>>>>>>>>>>    Set item_Changed_State item 0 to true
4002>>>>>>>>>>>>>    //showln "changed selection"
4002>>>>>>>>>>>>>    Send OnChange
4003>>>>>>>>>>>>>  end_Procedure
4004>>>>>>>>>>>>>
4004>>>>>>>>>>>>>  Procedure combo_edit_Changed
4005>>>>>>>>>>>>>//    If not (item_Changed_State(Current_Object,0)) begin
4005>>>>>>>>>>>>>    Set item_Changed_State item 0 to true // JJT - 8/2/97 - Made unconditional
4006>>>>>>>>>>>>>       //showln "edit changed"
4006>>>>>>>>>>>>>//    end
4006>>>>>>>>>>>>>    Send OnChange       // jvh - 13 Jun 97
4007>>>>>>>>>>>>>  end_Procedure
4008>>>>>>>>>>>>>
4008>>>>>>>>>>>>>  Function Combo_Item_Count Returns Integer
4009>>>>>>>>>>>>>     Local integer dataobj
4010>>>>>>>>>>>>>     Get Combo_data_object to dataobj
4011>>>>>>>>>>>>>     If dataobj ;        Function_return (item_count(dataobj))
4014>>>>>>>>>>>>>  End_function
4015>>>>>>>>>>>>>
4015>>>>>>>>>>>>>  Function Combo_Current_Item Returns Integer
4016>>>>>>>>>>>>>     Local integer dataobj
4017>>>>>>>>>>>>>     Get Combo_data_object to dataobj
4018>>>>>>>>>>>>>     If dataobj ;        Function_return (current_item(dataobj))
4021>>>>>>>>>>>>>  End_Function
4022>>>>>>>>>>>>>
4022>>>>>>>>>>>>>  Procedure SET Combo_Current_Item integer iTo
4023>>>>>>>>>>>>>     Local integer dataobj
4024>>>>>>>>>>>>>     Get Combo_data_object to dataobj
4025>>>>>>>>>>>>>     If dataobj ;        Set Current_item of dataobj to iTo
4028>>>>>>>>>>>>>  End_Procedure
4029>>>>>>>>>>>>>
4029>>>>>>>>>>>>>  Procedure Set Combo_Value Integer item# String sValue
4030>>>>>>>>>>>>>     Local integer dataobj witem#
4031>>>>>>>>>>>>>     Local String OldVal OldComboVal
4031>>>>>>>>>>>>>     Get Combo_data_object to dataobj
4032>>>>>>>>>>>>>     If dataobj Begin
4034>>>>>>>>>>>>>        // if windows exists make sure it is also up to date.
4034>>>>>>>>>>>>>        If (Window_Handle(Current_Object)) Begin
4036>>>>>>>>>>>>>           Get Value of dataobj item item# to OldComboVal // current value
4037>>>>>>>>>>>>>           Get WinCombo_Item_Matching OldComboVal To WItem#
4038>>>>>>>>>>>>>           If WItem# ne -1 Begin
4040>>>>>>>>>>>>>              Get Value item 0 to OldVal // current value
4041>>>>>>>>>>>>>              Send Windows_Message CB_DELETESTRING WItem# 0
4042>>>>>>>>>>>>>              Send WinCombo_Add_Insert_Value CB_INSERTSTRING WItem# sValue
4043>>>>>>>>>>>>>              Set Value item 0 to OldVal // current value
4044>>>>>>>>>>>>>           End
4044>>>>>>>>>>>>>>
4044>>>>>>>>>>>>>        End
4044>>>>>>>>>>>>>>
4044>>>>>>>>>>>>>        Set Value of dataobj item item# to sValue
4045>>>>>>>>>>>>>     End
4045>>>>>>>>>>>>>>
4045>>>>>>>>>>>>>  End_Procedure
4046>>>>>>>>>>>>>
4046>>>>>>>>>>>>>  Function Combo_Value Integer item# Returns String
4047>>>>>>>>>>>>>     Local integer dataobj
4048>>>>>>>>>>>>>     Get Combo_data_object to dataobj
4049>>>>>>>>>>>>>     If dataobj ;        Function_return (Value(dataobj,item#))
4052>>>>>>>>>>>>>  End_Procedure
4053>>>>>>>>>>>>>
4053>>>>>>>>>>>>>  Procedure Combo_Add_Item string sValue
4054>>>>>>>>>>>>>     Local integer dataobj
4055>>>>>>>>>>>>>     Get Combo_data_object to dataobj
4056>>>>>>>>>>>>>     If dataobj Begin
4058>>>>>>>>>>>>>        send add_item to dataobj msg_none sValue
4059>>>>>>>>>>>>>        If (Deferred_State(Current_Object)=0 AND Window_Handle(Current_Object)) ;           Send WinCombo_Add_Insert_Value CB_ADDSTRING 0 sValue
4062>>>>>>>>>>>>>     End
4062>>>>>>>>>>>>>>
4062>>>>>>>>>>>>>  End_Procedure
4063>>>>>>>>>>>>>
4063>>>>>>>>>>>>>  Procedure Combo_Insert_Item Integer iItem string sValue
4064>>>>>>>>>>>>>     Local integer dataobj
4065>>>>>>>>>>>>>     Get Combo_data_object to dataobj
4066>>>>>>>>>>>>>     If dataobj Begin
4068>>>>>>>>>>>>>        send insert_item to dataobj iItem msg_none sValue
4069>>>>>>>>>>>>>        If (Window_Handle(Current_Object)) ;           Send WinCombo_Add_Insert_Value CB_INSERTSTRING iItem sValue
4072>>>>>>>>>>>>>     End
4072>>>>>>>>>>>>>>
4072>>>>>>>>>>>>>  End_Procedure
4073>>>>>>>>>>>>>
4073>>>>>>>>>>>>>  // Internal: Send it the wrong values and watch the smoke!
4073>>>>>>>>>>>>>  Procedure WinCombo_Add_Insert_Value integer mode integer iItem String sValue
4074>>>>>>>>>>>>>     local pointer lpString pVoid
4075>>>>>>>>>>>>>     Append sValue (character(0))
4076>>>>>>>>>>>>>     GetAddress of sValue To lpString
4077>>>>>>>>>>>>>     Move (OemToAnsi(lpString,lpString)) To pVoid // covert to ANSI first
4078>>>>>>>>>>>>>     Send Windows_Message Mode iItem lpString
4079>>>>>>>>>>>>>  End_Procedure
4080>>>>>>>>>>>>>
4080>>>>>>>>>>>>>  Procedure Combo_Delete_Item Integer iItem
4081>>>>>>>>>>>>>     Local integer dataobj
4082>>>>>>>>>>>>>     Get Combo_data_object to dataobj
4083>>>>>>>>>>>>>     If dataobj Begin
4085>>>>>>>>>>>>>        Send Delete_Item to dataobj iItem
4086>>>>>>>>>>>>>        If (Window_Handle(Current_Object)) ;           Send Windows_Message CB_DELETESTRING iItem 0
4089>>>>>>>>>>>>>     End
4089>>>>>>>>>>>>>>
4089>>>>>>>>>>>>>  End_Procedure
4090>>>>>>>>>>>>>
4090>>>>>>>>>>>>>  Procedure Combo_Delete_Data
4091>>>>>>>>>>>>>     Local integer dataobj
4092>>>>>>>>>>>>>     Get Combo_data_object to dataobj
4093>>>>>>>>>>>>>     If dataobj Begin
4095>>>>>>>>>>>>>        Send Delete_Data to dataobj
4096>>>>>>>>>>>>>        If (Deferred_State(Current_Object)=0 AND Window_Handle(Current_Object)) ;           Send Windows_Message CB_RESETCONTENT 0 0
4099>>>>>>>>>>>>>     End
4099>>>>>>>>>>>>>>
4099>>>>>>>>>>>>>  End_Procedure
4100>>>>>>>>>>>>>
4100>>>>>>>>>>>>>
4100>>>>>>>>>>>>>  Function Combo_Item_Matching String sText Returns Integer
4101>>>>>>>>>>>>>     Local integer dataobj item#
4102>>>>>>>>>>>>>     Get Combo_data_object to dataobj
4103>>>>>>>>>>>>>     If dataobj Begin
4105>>>>>>>>>>>>>        Move 0 to item#
4106>>>>>>>>>>>>>        get item_matching of dataobj sText to item#
4107>>>>>>>>>>>>>        //showln "comboitemmat " stext item#
4107>>>>>>>>>>>>>        Function_return item#
4108>>>>>>>>>>>>>     end
4108>>>>>>>>>>>>>>
4108>>>>>>>>>>>>>     Else Function_Return -1
4110>>>>>>>>>>>>>  End_Function
4111>>>>>>>>>>>>>
4111>>>>>>>>>>>>>  // Perform the item match in the window's control
4111>>>>>>>>>>>>>  //
4111>>>>>>>>>>>>>  Function WinCombo_Item_Matching String sText Returns Integer
4112>>>>>>>>>>>>>      Local Handle hWnd
4113>>>>>>>>>>>>>      Local Integer iItem
4113>>>>>>>>>>>>>      Local Pointer lpsText pVoid
4113>>>>>>>>>>>>>      Get Window_Handle To hWnd
4114>>>>>>>>>>>>>      If hWnd BEgin
4116>>>>>>>>>>>>>         Append sText (Character(0))
4117>>>>>>>>>>>>>         GetAddress of sText To lpsText
4118>>>>>>>>>>>>>         // convert to ANSI for search against ANSI items in list
4118>>>>>>>>>>>>>         Move (OemToAnsi(lpsText,lpsText)) To pVoid
4119>>>>>>>>>>>>>         Move (SendMessage (hWnd, CB_FINDSTRINGEXACT, 0, lpsText)) To iItem
4120>>>>>>>>>>>>>         If iItem eq CB_ERR Function_Return -1
4123>>>>>>>>>>>>>         Else               Function_Return iItem
4125>>>>>>>>>>>>>      End
4125>>>>>>>>>>>>>>
4125>>>>>>>>>>>>>  End_Function
4126>>>>>>>>>>>>>
4126>>>>>>>>>>>>>  Procedure SET WinCombo_Current_Item integer iTo
4127>>>>>>>>>>>>>    Send Windows_Message CB_SETCURSEL iTo 0
4128>>>>>>>>>>>>>  End_Procedure
4129>>>>>>>>>>>>>
4129>>>>>>>>>>>>>  Function WinCombo_Current_Item Returns Integer
4130>>>>>>>>>>>>>     Function_Return (SendMessage(Window_Handle(Current_Object), CB_GETCURSEL,0,0))
4131>>>>>>>>>>>>>  End_Function
4132>>>>>>>>>>>>>
4132>>>>>>>>>>>>>  Function WinCombo_Value Integer item# Returns String
4133>>>>>>>>>>>>>      local string sValue
4134>>>>>>>>>>>>>      local Pointer lpsValue pVoid
4134>>>>>>>>>>>>>      Pad sValue To sValue 255
4136>>>>>>>>>>>>>>
4136>>>>>>>>>>>>>      GetAddress of sValue To lpsValue
4137>>>>>>>>>>>>>      Send Windows_Message CB_GETLBTEXT item# lpsValue
4138>>>>>>>>>>>>>      Move (AnsiToOem(lpsValue, lpsValue)) To pVoid // covert back to OEM
4139>>>>>>>>>>>>>      Function_Return (CString(sValue))
4140>>>>>>>>>>>>>  End_Function
4141>>>>>>>>>>>>>
4141>>>>>>>>>>>>>  Function Validate_Combo_Value returns integer
4142>>>>>>>>>>>>>     local string val
4143>>>>>>>>>>>>>     local integer ival
4143>>>>>>>>>>>>>     Get value item 0 to val
4144>>>>>>>>>>>>>     Move ( (Val='' AND allow_Blank_state(Current_Object) ) OR ;            (Combo_item_matching(Current_Object,Val)>=0) ) to ival
4145>>>>>>>>>>>>>     function_return (not(ival)) // 1=bad, 0=ok
4146>>>>>>>>>>>>>  End_function
4147>>>>>>>>>>>>>
4147>>>>>>>>>>>>>  Procedure OnDropDown // cancelled
4148>>>>>>>>>>>>>  End_Procedure
4149>>>>>>>>>>>>>
4149>>>>>>>>>>>>>  Procedure OnCloseUp // cancelled
4150>>>>>>>>>>>>>  End_Procedure
4151>>>>>>>>>>>>>
4151>>>>>>>>>>>>>  Procedure Add_Form_To_List
4152>>>>>>>>>>>>>     Local String Val
4153>>>>>>>>>>>>>     Local String itm
4153>>>>>>>>>>>>>     Get Value item 0 to Val
4154>>>>>>>>>>>>>     Get Combo_Item_matching Val to itm
4155>>>>>>>>>>>>>     if itm eq -1 Send Combo_Add_Item Val
4158>>>>>>>>>>>>>  End_Procedure
4159>>>>>>>>>>>>>
4159>>>>>>>>>>>>>  Procedure Combo_Fill_List
4160>>>>>>>>>>>>>  End_Procedure
4161>>>>>>>>>>>>>
4161>>>>>>>>>>>>>  Procedure combo_initialize_list
4162>>>>>>>>>>>>>     if (Combo_Item_count(Current_Object)=0) ;        Send Combo_fill_list
4165>>>>>>>>>>>>>  End_Procedure // combo_initialize_list
4166>>>>>>>>>>>>>
4166>>>>>>>>>>>>>  Procedure End_Define_Combo_Mixin
4167>>>>>>>>>>>>>     Local integer Sz
4168>>>>>>>>>>>>>     Get Size to Sz
4169>>>>>>>>>>>>>     If (Hi(Sz)<20) Set Size to 100 (Low(Sz))
4172>>>>>>>>>>>>>     //Send Combo_Initialize_List
4172>>>>>>>>>>>>>     //If (Shadow_State(Current_Object,0) ) ;
4172>>>>>>>>>>>>>     //      Set Form_Style_NoEnter to True
4172>>>>>>>>>>>>>
4172>>>>>>>>>>>>>     Send Locate_Label
4173>>>>>>>>>>>>>
4173>>>>>>>>>>>>>  End_Procedure
4174>>>>>>>>>>>>>
4174>>>>>>>>>>>>>  //
4174>>>>>>>>>>>>>  Procedure set value integer item# string val
4175>>>>>>>>>>>>>     Local integer ComboItem#
4176>>>>>>>>>>>>>     If (Window_Handle(Current_Object) AND Entry_State(Current_Object,0)=0) Begin
4178>>>>>>>>>>>>>        Get WinCombo_Item_Matching Val To ComboItem#
4179>>>>>>>>>>>>>        If ComboItem# eq -1 Begin // not found
4181>>>>>>>>>>>>>           Get Default_Combo_Item to ComboItem#
4182>>>>>>>>>>>>>           If ComboItem# eq -1 Begin  // -1 means top of list
4184>>>>>>>>>>>>>              Get WinCombo_Value item 0 to Val
4185>>>>>>>>>>>>>              Move 0 to ComboItem#
4186>>>>>>>>>>>>>           End
4186>>>>>>>>>>>>>>
4186>>>>>>>>>>>>>           Else Begin
4187>>>>>>>>>>>>>              Get Combo_Value item ComboItem# to Val
4188>>>>>>>>>>>>>              Get WinCombo_Item_Matching Val To ComboItem#
4189>>>>>>>>>>>>>           End
4189>>>>>>>>>>>>>>
4189>>>>>>>>>>>>>        End
4189>>>>>>>>>>>>>>
4189>>>>>>>>>>>>>        Forward Set value item item# to Val
4191>>>>>>>>>>>>>        If ComboItem# ge 0 ;           Set WinCombo_Current_Item To ComboItem#
4194>>>>>>>>>>>>>     End
4194>>>>>>>>>>>>>>
4194>>>>>>>>>>>>>     Else ;        Forward Set value item item# to Val
4197>>>>>>>>>>>>>  End_Procedure // set value
4198>>>>>>>>>>>>>
4198>>>>>>>>>>>>>  Procedure Page integer mode#
4199>>>>>>>>>>>>>    If Mode# ;       Set Window_Style To CBS_SORT (Combo_Sort_State(Current_Object))
4202>>>>>>>>>>>>>    Forward Send Page mode#
4204>>>>>>>>>>>>>  End_Procedure
4205>>>>>>>>>>>>>
4205>>>>>>>>>>>>>  Procedure Add_Focus integer id
4206>>>>>>>>>>>>>      Forward Send Add_Focus id
4208>>>>>>>>>>>>>      If not (Entry_State(Current_Object,0)) ;         Set Value Item 0 to (value(Current_Object,0))
4211>>>>>>>>>>>>>  End_Procedure
4212>>>>>>>>>>>>>
4212>>>>>>>>>>>>>
4212>>>>>>>>>>>>>end_class
4213>>>>>>>>>>>
4213>>>>>>>>>>>class ComboForm is a DFBaseComboBox
4214>>>>>>>>>>>
4214>>>>>>>>>>>    Procedure Construct_Object
4215>>>>>>>>>>>      Forward Send Construct_Object
4217>>>>>>>>>>>      Send Define_Combo_Mixin
4218>>>>>>>>>>>    End_Procedure // Construct_Object
4219>>>>>>>>>>>
4219>>>>>>>>>>>    Import_Class_Protocol Combo_Mixin
4220>>>>>>>>>>>
4220>>>>>>>>>>>    // By default we will fill combo lists during activating. In some cases
4220>>>>>>>>>>>    // the list may already be filled in which case nothing will happen.
4220>>>>>>>>>>>    Procedure Activating returns integer
4221>>>>>>>>>>>      Local integer rVal
4222>>>>>>>>>>>      Forward Get MSG_Activating to rVal
4224>>>>>>>>>>>      if not rval Send Combo_initialize_list
4227>>>>>>>>>>>      Procedure_Return rVal
4228>>>>>>>>>>>    End_Procedure
4229>>>>>>>>>>>
4229>>>>>>>>>>>    Procedure End_Construct_Object
4230>>>>>>>>>>>       Send End_Define_Combo_Mixin
4231>>>>>>>>>>>       Forward Send End_Construct_Object
4233>>>>>>>>>>>    End_Procedure // End_Construct_Object
4234>>>>>>>>>>>
4234>>>>>>>>>>>    procedure Set Capslock_State Integer bState
4235>>>>>>>>>>>       local integer iOptions
4236>>>>>>>>>>>       Get form_Options item 0 to iOptions
4237>>>>>>>>>>>       if bState ;          Move (AddBitValue(CAPSLOCK_BIT_VALUE, iOptions)) To iOptions
4240>>>>>>>>>>>       else ;           Move (RemoveBitValue(CAPSLOCK_BIT_VALUE, iOptions)) to iOptions
4242>>>>>>>>>>>       set form_Options item 0 to iOptions
4243>>>>>>>>>>>    End_procedure
4244>>>>>>>>>>>
4244>>>>>>>>>>>    Function CapsLock_State returns integer
4245>>>>>>>>>>>       local integer iOptions
4246>>>>>>>>>>>       get form_Options item 0 to iOptions
4247>>>>>>>>>>>       Function_Return ( (iOptions IAND CAPSLOCK_BIT_VALUE)<>0 )
4248>>>>>>>>>>>    End_Function
4249>>>>>>>>>>>
4249>>>>>>>>>>>    // This replaces the page in the mixin. We need to do some capslock
4249>>>>>>>>>>>    // checking with form combos. For some reason the runtime does not
4249>>>>>>>>>>>    // recognize the capslock bit in the form_options (as it does in form)
4249>>>>>>>>>>>    //
4249>>>>>>>>>>>    Procedure Page integer mode#
4250>>>>>>>>>>>      local integer iStyle hWnd bState
4251>>>>>>>>>>>      If Mode# ; // copied from mixin...         Set Window_Style To CBS_SORT (Combo_Sort_State(Current_Object))
4254>>>>>>>>>>>      Forward Send Page mode#
4256>>>>>>>>>>>      // This is required in form versions of combos because for
4256>>>>>>>>>>>      // some odd reason setting capslock in form option does not
4256>>>>>>>>>>>      // work.
4256>>>>>>>>>>>      If Mode# Begin
4258>>>>>>>>>>>         get form_window_handle item 0 to hWnd
4259>>>>>>>>>>>         if hWnd Begin
4261>>>>>>>>>>>            Get Capslock_State to bState
4262>>>>>>>>>>>            Move (GetWindowLong(hWnd, GWL_STYLE)) To iStyle
4263>>>>>>>>>>>            if bState ;               Move (AddBitValue(ES_UPPERCASE, iStyle)) To iStyle
4266>>>>>>>>>>>            else ;               Move (RemoveBitValue(ES_UPPERCASE, iStyle)) To iStyle
4268>>>>>>>>>>>            Move (SetWindowLong(hWnd, GWL_STYLE, iStyle)) To iStyle
4269>>>>>>>>>>>         end
4269>>>>>>>>>>>>
4269>>>>>>>>>>>      end
4269>>>>>>>>>>>>
4269>>>>>>>>>>>    End_Procedure
4270>>>>>>>>>>>
4270>>>>>>>>>>>    // for some reason these keys get forwarded in the C code.
4270>>>>>>>>>>>    // if key navigation, just let windows do it. This is part of KbdFix.pkg. When
4270>>>>>>>>>>>    // fixed in the RT we can remove this. We cannot use dfbaseComboBox because
4270>>>>>>>>>>>    // msg_key is defined at this level in the C code (jjt)
4270>>>>>>>>>>>    procedure key integer iKy returns integer
4271>>>>>>>>>>>    If (iKy=KUPARROW or iKy=KDOWNARROW or iKy=KSCROLL_BACK or iKy=KSCROLL_FORWARD) ;        set windows_override_state to false
4274>>>>>>>>>>>    else forward send key iKy
4277>>>>>>>>>>>    end_procedure
4278>>>>>>>>>>>
4278>>>>>>>>>>>end_class
4279>>>>>>>>>>>
4279>>>>>>>>>>>Class ComboEntry is a DFBaseComboBoxEntry
4280>>>>>>>>>>>
4280>>>>>>>>>>>    Procedure Construct_Object
4281>>>>>>>>>>>      Forward Send Construct_Object
4283>>>>>>>>>>>      Send Define_Combo_Mixin
4284>>>>>>>>>>>    End_Procedure // Construct_Object
4285>>>>>>>>>>>
4285>>>>>>>>>>>    Import_Class_Protocol Combo_Mixin
4286>>>>>>>>>>>    Import_Class_Protocol Auto_Setup_Mixin
4287>>>>>>>>>>>    Import_Class_Protocol DataFile_Help_Mixin
4288>>>>>>>>>>>    Import_Class_Protocol Entry_Shadow_Mixin
4289>>>>>>>>>>>
4289>>>>>>>>>>>    Procedure End_construct_object
4290>>>>>>>>>>>       Send Define_Form_Margins
4291>>>>>>>>>>>       Send End_Define_Combo_Mixin
4292>>>>>>>>>>>       Forward Send End_construct_object
4294>>>>>>>>>>>    End_Procedure // End_construct_object
4295>>>>>>>>>>>
4295>>>>>>>>>>>    // By default we will fill combo lists during activating. In some cases
4295>>>>>>>>>>>    // the list may already be filled in which case nothing will happen.
4295>>>>>>>>>>>    Procedure Activating returns integer
4296>>>>>>>>>>>      Local integer rVal
4297>>>>>>>>>>>      Forward Get MSG_Activating to rVal
4299>>>>>>>>>>>      if not rval Send Combo_initialize_list
4302>>>>>>>>>>>      Procedure_Return rVal
4303>>>>>>>>>>>    End_Procedure
4304>>>>>>>>>>>
4304>>>>>>>>>>>    // With entry based objects we can set capslock by setting
4304>>>>>>>>>>>    // the right bit in item_options AND form_Options. We use the
4304>>>>>>>>>>>    // options message instead of the option message because form_
4304>>>>>>>>>>>    // option doesn't seem to work right.
4304>>>>>>>>>>>    Procedure Set Capslock_State Integer bState
4305>>>>>>>>>>>        local integer iOptions
4306>>>>>>>>>>>        Get Item_Options item 0 to iOptions
4307>>>>>>>>>>>        if bState ;           Move (AddBitValue(CAPSLOCK_BIT_VALUE, iOptions)) To iOptions
4310>>>>>>>>>>>        else ;           Move (RemoveBitValue(CAPSLOCK_BIT_VALUE, iOptions)) to iOptions
4312>>>>>>>>>>>        set Item_Options item 0 to iOptions
4313>>>>>>>>>>>        set form_Options item 0 to iOptions
4314>>>>>>>>>>>    End_procedure
4315>>>>>>>>>>>
4315>>>>>>>>>>>    // check capslock bit for capslock_state
4315>>>>>>>>>>>    Function CapsLock_State returns integer
4316>>>>>>>>>>>       local integer iOptions
4317>>>>>>>>>>>       get Item_Options item 0 to iOptions
4318>>>>>>>>>>>       Function_Return ( (iOptions IAND CAPSLOCK_BIT_VALUE)<>0 )
4319>>>>>>>>>>>    End_Function // Wrap_State
4320>>>>>>>>>>>
4320>>>>>>>>>>>    // for some reason these keys get forwarded in the C code.
4320>>>>>>>>>>>    // if key navigation, just let windows do it. This is part of KbdFix.pkg. When
4320>>>>>>>>>>>    // fixed in the RT we can remove this. We cannot use dfbaseComboBox because
4320>>>>>>>>>>>    // msg_key is defined at this level in the C code (jjt)
4320>>>>>>>>>>>    procedure key integer iKy returns integer
4321>>>>>>>>>>>    If (iKy=KUPARROW or iKy=KDOWNARROW or iKy=KSCROLL_BACK or iKy=KSCROLL_FORWARD) ;        set windows_override_state to false
4324>>>>>>>>>>>    else forward send key iKy
4327>>>>>>>>>>>    end_procedure
4328>>>>>>>>>>>
4328>>>>>>>>>>>end_class
4329>>>>>>>>>
4329>>>>>>>>>Function Windows_Message Global Integer uMsg Dword wParam Dword lParam Returns Integer
4330>>>>>>>>>    Local Handle hWnd
4331>>>>>>>>>    Get Window_Handle To hWnd
4332>>>>>>>>>    Function_Return (SendMessage(hWnd, uMsg, wParam, lParam))
4333>>>>>>>>>End_Function
4334>>>use SentDat.pkg // define shared data positions
INCLUDING FILE: SENTDAT.PKG
4334>>>>>//
4334>>>>>//  Sentinel/Host common shared data
4334>>>>>//
4334>>>>>
4334>>>>>DEFINE BUTTONSTART   for 10
4334>>>>>DEFINE BUTTONLENGTH  for 25
4334>>>>>
4334>>>>>DEFINE CAPTIONSTART  for 35
4334>>>>>DEFINE CAPTIONLENGTH for 250
4334>>>>>
4334>>>>>DEFINE TITLESTART    for 285
4334>>>>>DEFINE TITLELENGTH   for 250
4334>>>>>
4334>>>>>DEFINE MESSAGESTART  for 535
4334>>>>>DEFINE MESSAGELENGTH for 250
4334>>>>>
4334>>>>>DEFINE ACTIONSTART   for 785
4334>>>>>DEFINE ACTIONLENGTH  for 250
4334>>>use msgbox.pkg
INCLUDING FILE: MSGBOX.PKG
4334>>>>>// MSGBOX.pkg
4334>>>>>//
4334>>>>>// 08/02/96 JJT - Checks a little harder for a container handle. If object
4334>>>>>//                using this is inactive (no handle) we want it to look for
4334>>>>>//                its parent handle. Else we get modeless confirm
4334>>>>>// 09/12/96 JJT - Add addition Default button support
4334>>>>>//
4334>>>>>
4334>>>>>Use Dll
4334>>>>>Use WinUser
4334>>>>>
4334>>>>>// Buttons required
4334>>>>>
4334>>>>>// Icon required
4334>>>>>
4334>>>>>// Default to which button
4334>>>>>
4334>>>>>
4334>>>>>// Modal Type
4334>>>>>
4334>>>>>
4334>>>>>
4334>>>>>
4334>>>>>
4334>>>>>
4334>>>>>// Function Return Values
4334>>>>>
4334>>>>>External_Function MessageBox "MessageBoxA" User32.dll ;    Handle  hWndParent ;    String  sText      ;    String  sCaption   ;    DWord   wType      ;    Returns Integer
4335>>>>>
4335>>>>>Function Message_Box GLOBAL String sMessage String sCaption ;                            Integer Btns Integer Icon returns Integer
4336>>>>>    Local Handle hWnd
4337>>>>>    Local String IncorrectNewline
4337>>>>>    Local String szMessage szCaption
4337>>>>>    Local Pointer lpszMessage lpszCaption
4337>>>>>    Local integer rval iVoid Obj
4337>>>>>
4337>>>>>    Move (Replaces("\n",sMessage,Character(13))) to sMessage
4338>>>>>    Move (sMessage +character(0)) To szMessage
4339>>>>>
4339>>>>>    Move "" To IncorrectNewline
4340>>>>>    Append IncorrectNewline "\" (Character(13))
4342>>>>>    Move (Replaces(IncorrectNewline, szMessage, "\n")) To szMessage
4343>>>>>
4343>>>>>    GetAddress of szMessage To lpszMessage
4344>>>>>    Move (OemToAnsi(lpszMessage,lpszMessage)) To iVoid
4345>>>>>
4345>>>>>    Move (sCaption +character(0)) To szCaption
4346>>>>>    GetAddress of szCaption To lpszCaption
4347>>>>>    Move (OemToAnsi(lpszCaption,lpszCaption)) To iVoid
4348>>>>>    Move Current_Object to Obj
4349>>>>>    Get Container_Handle of Obj To hWnd
4350>>>>>    While (hWnd=0 AND Obj<>Desktop)
4354>>>>>        Get Parent of Obj to Obj
4355>>>>>        Get Container_Handle of Obj To hWnd
4356>>>>>    End
4357>>>>>>
4357>>>>>    Move (MessageBox (hWnd, szMessage, szCaption, Btns IOR Icon)) To rval
4358>>>>>    Function_Return rVal
4359>>>>>End_Function
4360>>>>>
4360>>>>>Procedure Info_Box GLOBAL String sMessage String sTitle
4361>>>>>    Local Handle hWnd
4362>>>>>    Local String sCaption
4362>>>>>    Local integer rval
4362>>>>>    If Num_Arguments eq 1 Move 'Information' To sCaption
4365>>>>>    Else                  Move sTitle        To sCaption
4367>>>>>    Get Message_Box sMessage sCaption MB_OK MB_ICONINFORMATION to rval
4368>>>>>End_Procedure
4369>>>>>
4369>>>>>Procedure Stop_Box GLOBAL String sMessage String sTitle
4370>>>>>    Local Handle hWnd
4371>>>>>    Local String sCaption
4371>>>>>    Local Integer rval
4371>>>>>    If (Num_Arguments eq 1 or sTitle='') Move 'Stop' To sCaption
4374>>>>>    Else                                 Move sTitle To sCaption
4376>>>>>    Get Message_Box sMessage sCaption MB_OK MB_ICONHAND to rval
4377>>>>>End_Procedure
4378>>>>>
4378>>>>>Function YesNo_Box GLOBAL String sMessage String sTitle Integer DfltBtn ;                          Returns Integer
4379>>>>>    Local Handle hWnd
4380>>>>>    Local String sCaption
4380>>>>>    Local Integer Dflt
4380>>>>>    Local Integer rval
4380>>>>>    
4380>>>>>    If (Num_Arguments = 1 or sTitle = '') Move 'Question' To sCaption
4383>>>>>    Else                                  Move sTitle     To sCaption
4385>>>>>    
4385>>>>>    If (Num_Arguments < 3 OR DfltBtn = 0 OR DfltBtn = MB_DEFBUTTON1);       Move MB_DEFBUTTON1 to Dflt
4388>>>>>    Else ;       Move MB_DEFBUTTON2 to Dflt
4390>>>>>    
4390>>>>>    Get Message_Box sMessage sCaption MB_YESNO (MB_ICONQUESTION IOR Dflt) ;        to rval
4391>>>>>
4391>>>>>    Function_Return rval
4392>>>>>End_Function
4393>>>>>
4393>>>>>Function YesNoCancel_Box GLOBAL String sMessage String sTitle Integer DfltBtn ;               Returns Integer
4394>>>>>    Local Handle hWnd
4395>>>>>    Local String sCaption
4395>>>>>    Local Integer rval
4395>>>>>    Local Integer Dflt
4395>>>>>
4395>>>>>    If (Num_Arguments = 1 or sTitle = '') Move 'Question' To sCaption
4398>>>>>    Else                                  Move sTitle     To sCaption
4400>>>>>
4400>>>>>    If (Num_Arguments < 3 OR DfltBtn = 0 OR DfltBtn = MB_DEFBUTTON1);       Move MB_DEFBUTTON1 to Dflt
4403>>>>>    Else If (DfltBtn = 1 OR DfltBtn = MB_DEFBUTTON2);       Move MB_DEFBUTTON2 to Dflt
4407>>>>>    Else ;       Move MB_DEFBUTTON3 to Dflt
4409>>>>>
4409>>>>>    Get Message_Box sMessage sCaption MB_YESNOCANCEL (MB_ICONQUESTION IOR Dflt) ;        to rval
4410>>>>>
4410>>>>>    Function_Return rval
4411>>>>>End_Function
4412>>>
4412>>>Class StatusPanel is a DfObject
4413>>>
4413>>>   Procedure Construct_Object
4414>>>      Forward Send Construct_Object
4416>>>      Property String  Sentinel_Name     public "Sentinel"
4417>>>      Property Integer Sentinel_Running_State    Public False
4418>>>      Property Integer ProgressBar_State public False
4419>>>      Property Integer Progress_Minimum  public 0
4420>>>      Property Integer Progress_Maximum  public 100
4421>>>      Property String  Private.Button_text       Public ""
4422>>>      Property String  Private.Title_Text        Public ""
4423>>>      Property String  Private.Caption_Text      Public ""
4424>>>      Property String  Private.Message_Text      Public ""
4425>>>      Property String  Private.Action_Text       Public ""
4426>>>      Property Integer Allow_Cancel_State        Public True
4427>>>      // whenever a status is initialized, the default
4427>>>      // is used unless a different value is passed in
4427>>>      // initialize_StatusPanel
4427>>>      property string  status_params             public ''
4428>>>      property string  Status_Default_params     public ''
4429>>>      Set Button_Text to "Cancel"
4430>>>
4430>>>   End_Procedure // Construct_Object
4431>>>
4431>>>   Procedure Close_Panel
4432>>>   End_Procedure
4433>>>
4433>>>   Procedure Initialize_StatusPanel String sCaption String sTitle ;                        String sMessage String sParams
4434>>>      Set ProgressBar_State to False
4435>>>      Set Caption_text to sCaption
4436>>>      Set Title_Text   to sTitle
4437>>>      Set Message_Text to sMessage
4438>>>      // the 4th param is optional because it was not supported
4438>>>      // in vdf4. You are encouraged to supply this
4438>>>      If num_arguments gt 3 ;        set Status_params to sParams
4441>>>      else ;        set Status_params to (Status_Default_params(current_object))
4443>>>   End_Procedure
4444>>>
4444>>>   Procedure Set Caption_Text string sText
4445>>>      Set Private.Caption_Text to sText
4446>>>      Set SentinelData of Desktop to sText CAPTIONSTART CAPTIONLENGTH
4447>>>   End_Procedure // Set Caption_Text
4448>>>
4448>>>   Function Caption_Text returns string
4449>>>      Function_Return (Private.Caption_Text(Current_Object))
4450>>>   End_Function // Caption_Text
4451>>>
4451>>>   Procedure Set Message_Text string sText
4452>>>      Set Private.Message_Text to sText
4453>>>      Set SentinelData of Desktop to sText MESSAGESTART MESSAGELENGTH
4454>>>   End_Procedure // Set Message_Text
4455>>>
4455>>>   Function Message_Text returns string
4456>>>      Function_Return (Private.Message_Text(Current_Object))
4457>>>   End_Function // Message_Text
4458>>>
4458>>>   Procedure Set Action_Text string sText
4459>>>      Set Private.Action_Text to sText
4460>>>      Set SentinelData of Desktop to sText ACTIONSTART ACTIONLENGTH
4461>>>   End_Procedure // Set Action_Text
4462>>>
4462>>>   Function Action_Text returns string
4463>>>      Function_Return (Private.Action_Text(Current_Object))
4464>>>   End_Function // Action_Text
4465>>>
4465>>>   Procedure Set Button_Text string sText
4466>>>      Set Private.Button_Text to sText
4467>>>      Set SentinelData of Desktop to sText BUTTONSTART BUTTONLENGTH
4468>>>   End_Procedure // Set Button_Text
4469>>>
4469>>>   Function Button_Text returns string
4470>>>      Function_Return (Private.Button_Text(Current_Object))
4471>>>   End_Function // Button_Text
4472>>>
4472>>>   Procedure Set Title_Text string sText
4473>>>      Set Private.Title_Text to sText
4474>>>      Set SentinelData of Desktop to sText TITLESTART TITLELENGTH
4475>>>   End_Procedure // Set Title_Text
4476>>>
4476>>>   Function Title_Text returns string
4477>>>      Function_Return (Private.Title_Text(Current_Object))
4478>>>   End_Function // Title_Text
4479>>>
4479>>>   Procedure Start_StatusPanel
4480>>>      Local integer iVal
4481>>>      Local String sParams
4481>>>      If Not (Sentinel_Running_State(Current_Object)) Begin
4483>>>         Get status_params to sParams
4484>>>         If Not (Allow_Cancel_State(Current_Object)) ;             Move (sParams * "-c0") to sParams
4487>>>         Set Sentinel_Program of Desktop to ("dfrun" * Sentinel_Name(Current_Object) * sParams)
4488>>>         Get Start_Sentinel_Program of Desktop to iVal
4489>>>         //showln "start sent = " ival
4489>>>         //If iVal ;
4489>>>         Set Sentinel_Running_State to TRUE
4490>>>      End
4490>>>>
4490>>>   End_Procedure // Start_StatusPanel
4491>>>
4491>>>   Procedure Update_StatusPanel String sAction
4492>>>      Set Action_Text to sAction
4493>>>   End_Procedure
4494>>>
4494>>>   Function Check_StatusPanel returns integer
4495>>>      Function_Return (Sentinel_Return_Value(Current_Object))
4496>>>   End_Function
4497>>>
4497>>>   Procedure Stop_StatusPanel
4498>>>      Local integer iVal
4499>>>      If (Sentinel_Running_State(Current_Object)) ;         Get Stop_Sentinel_Program to iVal
4502>>>      Set Sentinel_Running_State to False
4503>>>   End_Procedure
4504>>>
4504>>>End_Class
4505>>>
4505>>>Object Status_Panel is a StatusPanel
4507>>>End_Object
4508>Use Wkspcsel
INCLUDING FILE: WKSPCSEL.PKG
4508>>>//  WkSpcSel.Pkg Workspace Manager package
4508>>>//
4508>>>//  Ken C. Ross         7/5/96
4508>>>//  Mods by JJT         11/06/96
4508>>>//
4508>>>//  Public Interface:
4508>>>//
4508>>>//        Object Name: WorkSpace_Selector
4508>>>//
4508>>>//        Procedures:
4508>>>//
4508>>>//          Get Select_WorkSpace       to ChangedState (T or F)
4508>>>//
4508>>>//          Get Select_Maint_WorkSpace to ChangedMode (See Modes)
4508>>>//
4508>>>//                 ChangedMode = WSNotChanged   - No known changes
4508>>>//                               WSNewWorkSpace - Changed (and possibly
4508>>>//                                                created new WS
4508>>>//                               WSModified     - Possibly changed
4508>>>//                                                WS or other path
4508>>>//                                                environments. Should
4508>>>//                                                completely reset
4508>>>//
4508>>>//        Properties:
4508>>>//
4508>>>//          Maint_State               (TRUE/false)
4508>>>//          Notify_WS_Select_State    (true/FALSE)
4508>>>//
4508>>>//  Usage:
4508>>>//
4508>>>//        Send the message Get Select_WorkSpace to activate the
4508>>>//        interface in a "select only" mode where the "New" and "Modify"
4508>>>//        buttons are not visible. Sets Maint_State to FALSE.
4508>>>//
4508>>>//        Send the message Get Maint_WorkSpace to activate the interface
4508>>>//        with all buttons available. Sets Maint_State to TRUE.
4508>>>//
4508>>>//        If ChangedState is True, you have a new workspace. It is up to
4508>>>//        the calling object to initialize the new workspace
4508>>>//
4508>>>//        Clicking on the "Select" button (or pressing Alt+S) will update
4508>>>//        the registry "WorkSpaces" key, setting the value
4508>>>//        "CurrentWorkSpace" to the selected workspace key (e.g.
4508>>>//        CurrentWorkSpace="tutorial"). Once the registry is updated, the
4508>>>//        user will be informed of the change via a messagebox; pressing the
4508>>>//        Ok button on the messagebox will close the WorkSpace Manager
4508>>>//        interface and return control to the program. Note that the
4508>>>//        messagebox notification can be disabled by setting the
4508>>>//        WorkSpace_Selector's Notify_WS_Select property to FALSE.
4508>>>//
4508>>>//        Clicking on the "New" button (or pressing Alt+N) will activate the
4508>>>//        WorkSpace Wizard via a DLL call to DFWSWIZ.DLL. Returning from the
4508>>>//        wizard will cause the workspace list and current workspace form to
4508>>>//        refresh.
4508>>>//
4508>>>//        Clicking on the "Modify" button (or pressing Alt+M) will activate
4508>>>//        the WorkSpace Maintenance interface (not currently available).
4508>>>//        Returning from this interface will cause the workspace list and
4508>>>//        current workspace form to refresh.
4508>>>//
4508>>>//        Clicking on the "Close" button (or pressing Alt+C) will simply
4508>>>//        close the Workspace Manager interface, returning control to the
4508>>>//        calling program.
4508>>>//
4508>>>//        This interface assumes that it is "safe" to change workspaces. It
4508>>>//        is the responsibility of the application to make this interface
4508>>>//        unavailable when switching work spaces would be inappropriate,
4508>>>//        such as when files are still open.
4508>>>//
4508>>>//        Again, note that it is the responsibility of the calling object
4508>>>//        to initialize for a new workspace - if needed. For Example:
4508>>>//
4508>>>//        Procedure Request_Select_WorkSpace
4508>>>//           Local Integer Changed
4508>>>//           Get Select_WorkSpace of (WorkSpace_Selector(Current_Object)) ;
4508>>>//              to Changed
4508>>>//           If ChangedMode Send Initalize_new_WS
4508>>>//        End_Procedure
4508>>>//
4508>>>// ==========================================================================
4508>>>Use windows.pkg
4508>>>use msgbox.pkg
4508>>>
4508>>>// Returns 0 if user press cancel
4508>>>// Returns 1 if a new WS was created
4508>>>//
4508>>>External_Function32 StartDFExplorer "StartDFExplorer" DFEXPL.DLL Handle MyHnd Returns Integer
4509>>>
4509>>>//  Returns 0 if user press cancel
4509>>>//  Returns 1 if a new WS was created
4509>>>//
4509>>>External_Function32 StartDFWSWizard "StartDFWSWizard" DFWSWIZ.DLL Handle MyHnd Returns Integer
4510>>>
4510>>>// Change types Supported.
4510>>>Enum_list
4510>>>   Define WSNotChanged    // no change that we know of
4510>>>   Define WSNewWorkSpace  // selected New WS, No known editing
4510>>>   Define WSModified      // We may have edited, should be reinitialized
4510>>>End_Enum_list
4510>>>
4510>>>register_object wsNameArray
4510>>>
4510>>>// Ken Ross 1/14/97 5:51PM
4510>>>//
4510>>>Class VDF_Reg_Class Is A Windows_Registry
4511>>>
4511>>>    Function Reg_Key_Enum integer iKey string szKeyName returns Integer
4512>>>        local string sName
4513>>>        local integer arrayID
4513>>>        move (wsNameArray(Current_object)) to arrayID
4514>>>        Get_Profile_String ("WorkSpaces\"+szKeyName) "Description" To sName
4517>>>        delegate send Add_to_List arrayID sName szKeyName
4519>>>        function_return 1
4520>>>    end_function
4521>>>
4521>>>End_Class
4522>>>
4522>>>Class cWS_List Is A List
4523>>>
4523>>>    Procedure Construct_Object
4524>>>        forward send Construct_Object
4526>>>
4526>>>        Object wsNameArray Is An Array
4528>>>        End_Object
4529>>>
4529>>>        Object VDF_Registry Is A VDF_Reg_Class
4531>>>        End_Object
4532>>>
4532>>>    End_Procedure
4533>>>
4533>>>    Procedure Add_To_List integer arrayID String sName String szKeyName
4534>>>        local string szName
4535>>>        local pointer pszName pszKeyName
4535>>>        local integer iVoid
4535>>>
4535>>>        move (sName + character(0)) to szName
4536>>>        GetAddress of szName To pszName
4537>>>        Move (AnsiToOem(pszName, pszName)) To iVoid
4538>>>
4538>>>        Send Add_Item (Item_Count(Self)) szName
4539>>>        Set Value of arrayID Item (Item_Count(arrayID)) TO szKeyName
4540>>>    End_Procedure
4541>>>
4541>>>    Procedure Rebuild_WS_List
4542>>>        Send Delete_Data
4543>>>        Send Delete_Data to (wsNameArray(Current_Object))
4544>>>        Get EnumRegistryKey of (VDF_Registry(Current_Object)) ;            "SOFTWARE\Data Access Corporation\Visual DataFlex\6\WorkSpaces" To WindowIndex
4545>>>    End_Procedure
4546>>>
4546>>>    Function KeyValue Returns string
4547>>>        Local String sValue
4548>>>        Local Integer item#
4548>>>        Get current_item To item#
4549>>>        Get Message item item# To item#
4550>>>        Get Value of (wsNameArray(current_object)) Item item# TO sValue
4551>>>        Function_Return sValue
4552>>>    End_Function
4553>>>
4553>>>    Function KeyDescription Returns string
4554>>>        Local String sValue
4555>>>        Local Integer item#
4555>>>        Get current_item To item#
4556>>>        get value item item# to sValue
4557>>>        Function_Return sValue
4558>>>    End_Function
4559>>>
4559>>>End_Class
4560>>>
4560>>>Object WorkSpace_Selector is a ModalPanel
4562>>>
4562>>>    property integer Maint_State            Public TRUE   // FALSE = select only, no new or modify options.
4564>>>    property integer Notify_WS_Select_State Public False  // Show messagebox after WS selection.
4566>>>    property Integer Changed_Mode           Public WSNotChanged
4568>>>    property String  Initial_WorkSpace_Key  Public ''
4570>>>    property Integer pbChangeSystemCurrent  Public FALSE     // TRUE = automatically make selected workspace the "current" system workspace.
4572>>>    property String  psSelectedWorkspace    Public ''
4574>>>
4574>>>    Set Help_Id To 150
4575>>>
4575>>>    Set Label to "Workspace Manager"
4576>>>    Set Size to 190 223
4577>>>    Set Locate_Mode to CENTER_ON_SCREEN
4578>>>
4578>>>    Function Current_WorkSpace Returns String
4580>>>        local string wsKey
4581>>>        Get_Profile_String "WorkSpaces" "CurrentWorkspace" To wsKey
4584>>>        Function_Return wsKey
4585>>>    End_Function
4586>>>
4586>>>    Function Current_Description returns String
4588>>>        local string sName wsKey szName
4589>>>        local pointer pszName pszKeyName
4589>>>        local integer iVoid
4589>>>
4589>>>        Get Current_WorkSpace to wsKey
4590>>>        Get_Profile_String ("WorkSpaces\"+wsKey) "Description" To sName
4593>>>
4593>>>        move (sName + character(0)) to szName
4594>>>        GetAddress of szName To pszName
4595>>>        Move (AnsiToOem(pszName, pszName)) To iVoid
4596>>>        Function_Return szName
4597>>>    End_Function
4598>>>
4598>>>    Object oWS_Group is a Group
4600>>>        Set Label to "Current Workspace"
4601>>>        Set Size to 38 208
4602>>>        Set Location to 5 5
4603>>>
4603>>>        Object name_form is a Form
4605>>>            Set Size to 13 195
4606>>>            Set Location to 15 7
4607>>>            set shadow_state to true
4608>>>
4608>>>            Procedure Update_Current_WS
4610>>>                local string sName
4611>>>                Delegate Get Current_Description to sName
4613>>>                if sName eq "" move "<undefined>" to sName
4616>>>                set value item 0 to sName
4617>>>            End_Procedure
4618>>>
4618>>>        End_Object    // Form1
4619>>>
4619>>>        Procedure Update_Current_WS
4621>>>            Send Update_Current_WS to (name_form(current_object))
4622>>>        End_Procedure
4623>>>
4623>>>    End_Object
4624>>>
4624>>>    Object oWS_List Is a cWS_List
4626>>>        Set Select_Mode to SINGLE_SELECT
4627>>>        Set Label to "&Available Workspaces:"
4628>>>        Set Label_Col_Offset to 0
4629>>>        Set Label_Justification_Mode to jMode_Top
4630>>>        Set Size to 113 152
4631>>>        Set Location to 58 5
4632>>>
4632>>>        Procedure Mouse_Click Integer iWin Integer iChar
4634>>>            Forward Send Mouse_Click iWin iChar
4636>>>            Delegate Send DoSelectWorkspace
4638>>>        End_Procedure
4639>>>
4639>>>        Procedure Page Integer iState
4641>>>            Local Integer iItem icItem
4642>>>            Local String sName
4642>>>            Forward Send Page iState
4644>>>            Get Value of (Name_Form(oWS_Group(current_object))) To sName
4645>>>            Get Item_Count To icItem
4646>>>            For iItem From 0 To (icItem -1)
4652>>>>
4652>>>                If (Value(current_object, iItem)) eq sName Begin
4654>>>                    Set current_Item To iItem
4655>>>                    Move icItem To iItem // break the loop
4656>>>                End
4656>>>>
4656>>>            Loop
4657>>>>
4657>>>        End_Procedure
4658>>>
4658>>>    End_Object
4659>>>
4659>>>    Object SelectButton is a Button
4661>>>        Set Label to "&Select"
4662>>>        Set Location to 58 163
4663>>>        Set Default_State To True
4664>>>        Procedure OnClick
4666>>>            Delegate Send DoSelectWorkSpace
4668>>>        End_Procedure
4669>>>    End_Object    // SelectButton
4670>>>
4670>>>    Object NewButton is a Button
4672>>>        Set Label to "&New..."
4673>>>        Set Location to 76 163
4674>>>        Procedure OnClick
4676>>>           Delegate Send DoNewWorkSpace
4678>>>        End_Procedure
4679>>>    End_Object    // NewButton
4680>>>
4680>>>    Object ModifyButton is a Button
4682>>>        Set Label to "&Modify..."
4683>>>        Set Location to 95 163
4684>>>        Procedure OnClick
4686>>>            Delegate Send DoModifyWorkSpace
4688>>>        End_Procedure
4689>>>    End_Object    // ModifyButton
4690>>>
4690>>>    Object CloseButton is a Button
4692>>>        Set Label to "&Close"
4693>>>        Set Location to 157 163
4694>>>        Procedure OnClick
4696>>>            Delegate Send Cancel_Panel
4698>>>        End_Procedure
4699>>>    End_Object    // CloseButton
4700>>>
4700>>>    Procedure Refresh
4702>>>       Send Update_Current_WS To (oWS_Group(Current_Object))
4703>>>       Send Rebuild_WS_List   To (oWS_List(Current_Object))
4704>>>       Send Sort_Items        To (oWS_List(Current_Object)) ASCENDING
4705>>>
4705>>>    End_procedure
4706>>>
4706>>>    //  Close Panel. If WS has changed set Changed_Mode
4706>>>    //
4706>>>    Procedure Close_Panel
4708>>>        Local String sKey
4709>>>        Local Integer Changed
4709>>>        Get psSelectedWorkSpace to sKey
4710>>>        Move (sKey<>Initial_Workspace_Key(Current_Object)) to Changed // new WS?
4711>>>
4711>>>        // If we're not allowing the change of the global workspace, treat all
4711>>>        // selections as a change.
4711>>>        //
4711>>>        if (pbChangeSystemCurrent(Current_Object) eq FALSE) move 1 to Changed
4714>>>
4714>>>        If (Changed AND Changed_Mode(Current_Object)=WSNotChanged) ;           Set Changed_Mode to WSNewWorkSpace
4717>>>        If (Changed AND Notify_WS_Select_State(current_object)) ;           Send Info_Box (Current_Description(Current_Object)) "New WorkSpace Selected:"
4720>>>        Send Stop_Modal_Ui //DeActivate
4721>>>    End_Procedure
4722>>>
4722>>>    Procedure Cancel_Panel
4724>>>        Send Stop_Modal_Ui //DeActivate
4725>>>    End_Procedure
4726>>>
4726>>>    Procedure Cancel_Panel
4728>>>        Send Stop_Modal_Ui //DeActivate
4729>>>    End_Procedure
4730>>>
4730>>>    Procedure DoSelectWorkSpace
4732>>>        Local String sKey
4733>>>        Get KeyValue  of (oWS_List(current_object)) To sKey
4734>>>        if (pbChangeSystemCurrent(current_object)) ;            Set_Profile_String "WorkSpaces" "CurrentWorkSpace" To sKey
4739>>>        set psSelectedWorkspace to sKey
4740>>>        Send Close_Panel
4741>>>    End_Procedure
4742>>>
4742>>>    Procedure DoNewWorkSpace
4744>>>        local Handle  hHand
4745>>>        local Integer iStatus
4745>>>        Get Container_Handle to hHand
4746>>>        Move (StartDFWSWizard(hHand)) to iStatus
4747>>>        If iStatus send Refresh
4750>>>    End_Procedure
4751>>>
4751>>>    Procedure DoModifyWorkSpace
4753>>>        local Handle  hHand
4754>>>        local Integer iStatus
4754>>>        Move (StartDFExplorer(hHand)) to iStatus
4755>>>        // we don't know if it was changed. So we say yes - changed
4755>>>        Set Changed_Mode to WSModified
4756>>>        Send Refresh
4757>>>     End_Procedure
4758>>>
4758>>>    Procedure Activating
4760>>>        local integer wsMode
4761>>>        get Maint_State to wsMode
4762>>>        Move (if(WsMode,FOCUSABLE,NO_ACTIVATE)) to wsMode
4763>>>        set Focus_Mode of (NewButton(Current_Object))    to wsMode
4764>>>        set Focus_Mode of (ModifyButton(Current_Object)) to wsMode
4765>>>        Set Initial_Workspace_Key to (Current_WorkSpace(Current_Object))
4766>>>        Set psSelectedWorkspace to ''
4767>>>        Send Refresh
4768>>>        Set Changed_Mode to WSNotChanged
4769>>>        forward send activating
4771>>>    End_Procedure
4772>>>
4772>>>    On_Key kClose_Panel         Send Close_Panel
4773>>>    On_Key kExit_Application    Send Close_Panel
4774>>>    On_Key kCancel              Send Close_Panel
4775>>>    On_Key Key_Alt+Key_A        Send Activate to  (oWS_List(Current_Object))
4776>>>    On_Key Key_Alt+Key_S        Send KeyAction to (SelectButton(Current_Object))
4777>>>    On_Key Key_Alt+Key_N        Send KeyAction to (NewButton(Current_Object))
4778>>>    On_Key Key_Alt+Key_M        Send KeyAction to (ModifyButton(Current_Object))
4779>>>    On_Key Key_Alt+Key_C        Send KeyAction to (CloseButton(Current_Object))
4780>>>
4780>>>    //  Public access functions
4780>>>    //
4780>>>    //
4780>>>    Function Select_WorkSpace returns integer
4782>>>       set Maint_State to false
4783>>>       Send Popup
4784>>>       Function_Return (Changed_Mode(Current_Object)<>WSNotChanged)
4785>>>    End_Function
4786>>>
4786>>>    Function Select_Maint_WorkSpace returns integer
4788>>>       set Maint_State to true
4789>>>       Send Popup
4790>>>       Function_Return (Changed_Mode(Current_Object))
4791>>>    End_Function
4792>>>
4792>>>End_Object
4793>Use Seq_Chnl.Pkg // Package with I/O channel management functions
INCLUDING FILE: SEQ_CHNL.PKG
4793>>>//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
4793>>>// Confidential Trade Secret.
4793>>>// Copyright 1987-1994 Data Access Corporation, Miami FL, USA
4793>>>// All Rights reserved
4793>>>// DataFlex is a registered trademark of Data Access Corporation.
4793>>>//
4793>>>// Module:
4793>>>//      seq_chnl.pkg
4793>>>//
4793>>>// Purpose:
4793>>>//      Defines global sequential device management operations.
4793>>>//
4793>>>// Author:
4793>>>//      Lee Smith
4793>>>//
4793>>>// Date:
4793>>>//      11/2/94
4793>>>//
4793>>>//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
4793>>>
4793>>>use ui
INCLUDING FILE: ERRORNUM.INC
4793>>>>// DataFlex Source Code
4793>>>>// Copyright 1987-1992 Data Access Corporation, Miami FL, USA
4793>>>>// All Rights reserved
4793>>>>// 
4793>>>>// JR 2/7/92
4793>>>>
4793>>>>
4793>>>>
4793>>>>
4793>>>>   
4793>>>>
4793>>>>
4793>>>>
4793>>>
4793>>>define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
4793>>>define DF_SEQ_CHANNEL_ERROR         for -1
4793>>>define DF_SEQ_CHANNEL_MIN           for 0
4793>>>define DF_SEQ_CHANNEL_MAX           for 9
4793>>>define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
4793>>>                            // so that programs that use direct_input/output
4793>>>                            // w/o specifying a channel will work.
4793>>>enum_list
4793>>>    define DF_SEQ_CHANNEL_MODE_CLOSED
4793>>>    define DF_SEQ_CHANNEL_MODE_OPEN
4793>>>    define DF_SEQ_CHANNEL_MODE_OUTPUT
4793>>>    define DF_SEQ_CHANNEL_MODE_INPUT
4793>>>end_enum_list
4793>>>
4793>>>enum_list
4793>>>    define DF_SEQ_CHANNEL_ERROR_MODE_NONE
4793>>>    define DF_SEQ_CHANNEL_ERROR_MODE_ALL
4793>>>end_enum_list
4793>>>
4793>>>integer Seq$Channel$Error$Mode
4793>>>
4793>>>procedure set Seq_Channel_Error_Mode GLOBAL integer Mode
4794>>>    move Mode to Seq$Channel$Error$Mode
4795>>>end_procedure
4796>>>
4796>>>function Seq_Channel_Error_Mode GLOBAL returns integer
4797>>>    function_return Seq$Channel$Error$Mode
4798>>>end_procedure
4799>>>
4799>>>object Seq_Channel_List is an Array
4801>>>    procedure Initialize
4803>>>        local integer Itm
4804>>>
4804>>>        move DF_SEQ_CHANNEL_MIN to Itm
4805>>>
4805>>>        while Itm LE DF_SEQ_CHANNEL_MAX
4809>>>            set Array_Value item Itm to DF_SEQ_CHANNEL_MODE_CLOSED
4810>>>            increment Itm
4811>>>        end
4812>>>>
4812>>>    end_procedure
4813>>>
4813>>>    send Initialize
4814>>>end_object
4815>>>
4815>>>set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
4816>>>
4816>>>function Seq_Channel_Mode GLOBAL integer Chnl returns integer
4817>>>    function_return (Integer_Value(Seq_Channel_List(Current_Object), Chnl))
4818>>>end_function
4819>>>
4819>>>procedure set Seq_Channel_Mode GLOBAL integer Chnl integer Mode
4820>>>    set Array_Value of (Seq_Channel_List(Current_Object)) item Chnl to Mode
4821>>>end_procedure
4822>>>
4822>>>function Seq_New_Channel GLOBAL returns integer
4823>>>    local integer Obj Chnl
4824>>>
4824>>>    move DF_SEQ_START_CHANNEL to Chnl
4825>>>
4825>>>    while Chnl LE DF_SEQ_CHANNEL_MAX
4829>>>        if (Seq_Channel_Mode(Chnl)) EQ DF_SEQ_CHANNEL_MODE_CLOSED begin
4831>>>            set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
4832>>>            function_return Chnl
4833>>>        end
4833>>>>
4833>>>
4833>>>        increment Chnl
4834>>>    end
4835>>>>
4835>>>
4835>>>    // wrap back to beginning
4835>>>    move 0 to Chnl
4836>>>
4836>>>    while Chnl LT DF_SEQ_START_CHANNEL
4840>>>        if (Seq_Channel_Mode(Chnl)) EQ DF_SEQ_CHANNEL_MODE_CLOSED begin
4842>>>            set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
4843>>>            function_return Chnl
4844>>>        end
4844>>>>
4844>>>
4844>>>        increment Chnl
4845>>>    end
4846>>>>
4846>>>
4846>>>    function_return DF_SEQ_CHANNEL_NOT_AVAILABLE
4847>>>end_procedure
4848>>>
4848>>>procedure Seq_Release_Channel GLOBAL integer Chnl
4849>>>    if ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) ;        set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_CLOSED
4852>>>end_procedure
4853>>>
4853>>>function Seq_Open_Input_Channel GLOBAL string Dvc returns integer
4854>>>    local integer Chnl
4855>>>
4855>>>    get Seq_New_Channel to Chnl
4856>>>
4856>>>    if Chnl LE DF_SEQ_CHANNEL_ERROR begin
4858>>>        if (Seq_Channel_Error_Mode()) EQ DF_SEQ_CHANNEL_ERROR_MODE_ALL ;            error DFERR_CANT_OPEN_INPUT_FILE (Dvc + ": no open channels")
4861>>>        function_return Chnl
4862>>>    end
4862>>>>
4862>>>
4862>>>    indicate Err FALSE
4863>>>    direct_input channel Chnl Dvc
4865>>>
4865>>>    [Err] begin
4867>>>>
4867>>>        send Seq_Release_Channel Chnl
4868>>>        function_return DF_SEQ_CHANNEL_ERROR
4869>>>    end
4869>>>>
4869>>>
4869>>>    set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_INPUT
4870>>>
4870>>>    function_return Chnl
4871>>>end_function
4872>>>
4872>>>function Seq_Open_Output_Channel GLOBAL string Dvc returns integer
4873>>>    local integer Chnl
4874>>>
4874>>>    get Seq_New_Channel to Chnl
4875>>>
4875>>>    if Chnl LE DF_SEQ_CHANNEL_ERROR begin
4877>>>        if (Seq_Channel_Error_Mode()) EQ DF_SEQ_CHANNEL_ERROR_MODE_ALL begin
4879>>>            error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ": channel not available")
4880>>>>
4880>>>            move DF_SEQ_CHANNEL_ERROR to Chnl
4881>>>        end
4881>>>>
4881>>>
4881>>>        function_return Chnl
4882>>>    end
4882>>>>
4882>>>
4882>>>    indicate Err FALSE
4883>>>    direct_output channel Chnl Dvc
4885>>>
4885>>>    [Err] begin
4887>>>>
4887>>>        send Seq_Release_Channel Chnl
4888>>>        function_return DF_SEQ_CHANNEL_ERROR
4889>>>    end
4889>>>>
4889>>>
4889>>>    set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
4890>>>
4890>>>    function_return Chnl
4891>>>end_function
4892>>>
4892>>>function Seq_Append_Output_Channel GLOBAL string Dvc returns integer
4893>>>    local integer Chnl
4894>>>
4894>>>    get Seq_New_Channel to Chnl
4895>>>
4895>>>    if Chnl LE DF_SEQ_CHANNEL_ERROR begin
4897>>>        if (Seq_Channel_Error_Mode()) EQ DF_SEQ_CHANNEL_ERROR_MODE_ALL begin
4899>>>            error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ": channel not available")
4900>>>>
4900>>>            move DF_SEQ_CHANNEL_ERROR to Chnl
4901>>>        end
4901>>>>
4901>>>
4901>>>        function_return Chnl
4902>>>    end
4902>>>>
4902>>>
4902>>>    indicate Err FALSE
4903>>>    append_output channel Chnl Dvc
4905>>>
4905>>>    [Err] begin
4907>>>>
4907>>>        send Seq_Release_Channel Chnl
4908>>>        function_return DF_SEQ_CHANNEL_ERROR
4909>>>    end
4909>>>>
4909>>>
4909>>>    set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
4910>>>
4910>>>    function_return Chnl
4911>>>end_function
4912>>>
4912>>>procedure Seq_Close_Channel GLOBAL integer Chnl
4913>>>    local integer Mode
4914>>>
4914>>>    if ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) begin
4916>>>        get Seq_Channel_Mode Chnl to Mode
4917>>>
4917>>>        if Mode EQ DF_SEQ_CHANNEL_MODE_OUTPUT ;            close_output channel Chnl
4921>>>        else if Mode EQ DF_SEQ_CHANNEL_MODE_INPUT ;            close_input channel Chnl
4926>>>        else begin
4927>>>            error DFERR_FILE_NOT_OPEN ("Channel: " + Chnl)
4928>>>>
4928>>>            procedure_return
4929>>>        end
4929>>>>
4929>>>
4929>>>        send Seq_Release_Channel Chnl
4930>>>    end
4930>>>>
4930>>>end_procedure
4931>//AB-StoreTopEnd
4931>
4931>//AB-IgnoreStart
4931>
4931>
4931>//AB-IgnoreEnd
4931>
4931>DEFERRED_VIEW Activate_oRelated FOR ;;Object oRelated is a dbView
DEFERRED_VIEW Activate_oRelated FOR ;;Object oRelated is a dbView
ERROR: 4298 Command not found DEFERRED_VIEW ON LINE: 121 (4931) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4931>
4931>    //AB-StoreTopStart
4931>    Property String psSource        public ""
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 124 (4931) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4932>    Property String psTarget        public ""
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 125 (4932) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4933>    Property String psUserName      public ""
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 126 (4933) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4934>    Property String psComputerName  public ""
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 127 (4934) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4935>    Property Integer piSourceDat  1
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 128 (4935) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4936>    Property Integer piSourceInt  0
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 129 (4936) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4937>    Property Integer piTargetDat  0
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 130 (4937) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4938>    Property Integer piTargetInt  1
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 131 (4938) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4939>    Property Integer piAppendFile 0
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 132 (4939) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4940>    Property Handle  phWinHandel  0
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 133 (4940) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4941>    Property Integer piStopCheckState 0
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 134 (4941) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4942>    Property Integer piPrimaryIndexTrigger 0
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 135 (4942) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4943>    Property Integer piTotalRecWritten     0
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 136 (4943) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4944>    Property Integer piZeroOverWriteTarget     0
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 137 (4944) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4945>    Property Integer piKeepRecId     0
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 138 (4945) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4946>    Property Integer piIntLocation   0
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 139 (4946) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4947>    Property Integer piTypeSize      45
ERROR: 302 PROPERTY CAN ONLY BE DEFINED WITHIN A CLASS OR OBJECT ON LINE: 140 (4947) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
4948>
4948>    //Object oFileInformation Is a cAPICalls
4948>    //End_Object // oFileInformation
4948>
4948>    Function GetField_Type Integer iDfType  Returns String
4949>        If iDfType eq DF_ASCII   Function_Return "ASC"   //DF_ASCII     0
4952>        If iDfType eq DF_BCD     Function_Return "NUM"   //DF_BCD       1
4955>        If iDfType eq DF_DATE    Function_Return "DAT"   //DF_DATE      2
4958>        If iDfType eq DF_OVERLAP Function_Return "OVE"   //DF_OVERLAP   3
4961>        If iDfType eq DF_TEXT    Function_Return "TEX"   //DF_TEXT      5
4964>        If iDfType eq DF_BINARY  Function_Return "BIN"   //DF_BINARY    6
4967>    End_Function
4968>
4968>    //    Move  (XLSDateTime(Self, 2)) to String 0= 21:01:01  1= 01/01/01 2= 01/01/01 00:00:00
4968>    Function XLSDateTime Integer iDateOrTime  Returns String
4969>        Integer iHour  iMin iSec
4970>        String  sTodayDate sYy  sDD  sMm sTime sDateTime
4970>        Date dTodayDate
4970>        Sysdate  dTodayDate iHour  iMin iSec
4974>        Move    "" to sTime
4975>        Move dTodayDate to sTodayDate
4976>        Right sTodayDate  To sYy 2
4978>        Mid   sTodayDate  To sDD 2 4
4981>        Left  sTodayDate  To sMm 2
4983>        Move "" to sTodayDate
4984>        Append sTodayDate sMm "/" sDD "/" sYy
4989>
4989>        If iMin Lt 10  Append sTime  iHour ":0" iMin
4994>        Else           Append sTime  iHour ":"  iMin
4998>        If iSec Lt 10  Append sTime  ":0" iSec
5002>        Else           Append sTime  ":"  iSec
5005>        If (iDateOrTime = 0) Move sTime to sDateTime
5008>        If (iDateOrTime = 1) Move sTodayDate to sDateTime
5011>        If (iDateOrTime = 2) Move (sTodayDate * sTime) to sDateTime
5014>        Function_Return sDateTime
5015>    End_Function
5016>
5016>
5016>    //AB-StoreTopEnd
5016>
5016>    Set Label to "Work Space Select View"
5017>    Set Size to 265 523
5018>    Set Location to 6 6
5019>
5019>    //AB-DDOStart
5019>
5019>
5019>    //AB-DDOEnd
5019>
5019>    Object WorkSpaceBtn is a Button
5021>        Set Label to "Select WorkSpace"
5022>        Set Default_State to TRUE
5023>        Set Size to 14 67
5024>        Set Location to 4 5
5025>        Set Status_Help to "Select a WorkSpace"
5026>
5026>        //AB-StoreStart
5026>        set focus_mode to pointer_only
5027>        Procedure OnClick
5029>            Send ChangeWorkspace   to oRelated
5030>        End_procedure // OnClick
5031>
5031>        //AB-StoreEnd
5031>
5031>    End_Object    // WorkSpaceBtn
5032>
5032>    Object BuildFileWorkList is a Button
5034>        Set Label to "Build File Related File List"
5035>        Set Size to 14 103
5036>        Set Location to 4 74
5037>
5037>        //AB-StoreStart
5037>        Procedure OnClick
5039>           Integer iRetval iFileNumber iChOut
5040>           String sLabel sFile_Name  sRelatedRpt
5040>            get Seq_New_Channel to iChOut
5041>            // no channel avaiLabel
5041>            if (iChOut=DF_SEQ_CHANNEL_NOT_AVAILABLE) begin
5043>                send Info_Box "No Channel AvaiLabel for Output" "Error"
5044>                Procedure_return
5045>            end
5045>            Get Value of RelatedRpt to sRelatedRpt
5046>            Direct_Output Channel  iChOut sRelatedRpt
5048>            Move (XLSDateTime(Self,2))      to oRelatedHdr.1
5049>            Output Channel iChOut oRelatedHdr
5051>            Send delete_data to RelatedFileListGrid
5052>            Repeat
5052>              Get_Attribute  DF_FILE_NEXT_USED  of iFileNumber  To iFileNumber
5055>              If iFileNumber eq 48  Get_Attribute  DF_FILE_NEXT_USED  of iFileNumber  To iFileNumber
5060>              If (Not(iFileNumber)) Break
5063>              Get_Attribute Df_File_Logical_Name Of iFileNumber To sFile_Name
5066>              Send Build_Process_List to ReworkListArray iFileNumber //22 //76
5067>              Send  OpenAllFiles
5068>              Send  MoveInfo2Grid  iChOut  sRelatedRpt
5069>              Send  CloseAllFiles
5070>            Loop
5071>            Close_Output Channel iChOut
5073>            send Seq_Release_Channel iChOut
5074>
5074>        End_Procedure // OnClick
5075>
5075>        Procedure MoveInfo2Grid  Integer iChOut String  sRelatedRpt
5077>            Integer iCol  array_id  iItem iItmCnt  iChild iParent iRecLevel iLevel iLevelMax iFieldTypeChild
5078>            Integer iFieldNativeLengthChild iFieldNativeLengthParent  iFieldTypeParent iGridLevelCnt
5078>            Integer iLoop iField  iRelated_File  iRelated_Field  iItemCountRelatedFileListGrid iFieldNativeLength
5078>            Integer iFieldSortCheckBoxState  iChildLength  iChildOffset
5078>            String  sChild   sParent    sChildField  sParentField  sChild# sParent#  sFieldTypeChild
5078>            String  sFieldTypeParent sNumber2Str  sDriverName
5078>            Move 5 to iCol
5079>            move (ReworkListArray(Self)) to array_id
5080>            get item_count of array_id to iItmCnt
5081>            If (Not(iItmCnt)) Procedure_Return
5084>            Move 0 to iItem
5085>            Move 0 to iLevel
5086>            Move 0 to iLevelMax
5087>            Move 0 to iGridLevelCnt
5088>            Get checked_State of FieldSortCheckBox to iFieldSortCheckBoxState
5089>            If (iItmCnt <> 0) Begin
5091>                repeat
5091>                    Move (Integer_value(Array_id,   iItem    )) to iRecLevel
5092>                    Move (Integer_value(Array_id,  (iItem+1) )) to iChild
5093>                    Move (Integer_value(Array_id,  (iItem+2) )) to iField
5094>                    Move (Integer_value(Array_id,  (iItem+3) )) to iRelated_File
5095>                    Move (Integer_value(Array_id,  (iItem+4) )) to iRelated_Field
5096>                    Get_Attribute Df_File_Logical_Name    Of iChild        To sChild
5099>                    Get_Attribute Df_File_Logical_Name    Of iRelated_File To sParent
5102>                    Get_Attribute DF_FIELD_NAME           of iChild        iField         to sChildField
5105>                    Get_Attribute DF_FIELD_NAME           of iRelated_File iRelated_Field to sParentField
5108>
5108>                    Get_Attribute DF_FIELD_TYPE           Of iChild iField to iFieldTypeChild
5111>                    Move  (GetField_Type(Self,iFieldTypeChild ))           to sFieldTypeChild
5112>                    Get_Attribute DF_FILE_DRIVER                                        of iChild to sDriverName
5115>                    If ( sDriverName = "DB2_DRV")  get_attribute DF_FIELD_LENGTH        of iChild iField to iFieldNativeLengthChild
5120>                    Else get_attribute DF_FIELD_NATIVE_LENGTH of iChild iField to iFieldNativeLengthChild
5124>
5124>                    get_attribute DF_FIELD_OFFSET of iChild iField to iChildOffset
5127>
5127>                    If ( sDriverName = "DB2_DRV")  get_attribute DF_FIELD_LENGTH        of iChild iField to iChildLength
5132>                    Else get_attribute DF_FIELD_NATIVE_LENGTH of iChild iField to iChildLength
5136>
5136>                    Move iFieldNativeLengthChild to  sNumber2Str
5137>                    If  (iFieldNativeLengthChild Le  9)                                        insert "00" in sNumber2Str at 1
5141>                    If ((iFieldNativeLengthChild Gt  9) and  (iFieldNativeLengthChild Le 99) ) insert  "0" in sNumber2Str at 1
5145>
5145>                    Get_Attribute DF_FIELD_TYPE           Of iRelated_File iRelated_Field to iFieldTypeParent
5148>                    Move  (GetField_Type(Self,iFieldTypeParent ))                        to sFieldTypeParent
5149>                    Get_Attribute DF_FIELD_NATIVE_LENGTH  Of iRelated_File iRelated_Field to iFieldNativeLengthParent
5152>                    Move "[" to  sChild#
5153>                    Append sChild#  iChild "." iField "] "
5157>                    Move "[" to  sParent#
5158>                    Append sParent#  iRelated_File "." iRelated_Field "] "
5162>
5162>                    If (iRecLevel Gt iLevelMax) Move  iRecLevel to iLevelMax
5165>                    If ((iLevel =  iRecLevel) or (Not(iFieldSortCheckBoxState))) Begin
5167>                        Calc (iRecLevel * 2) to iGridLevelCnt
5168>                        For iLoop From 1 to 14
5174>                           Send Add_Item of RelatedFileListGrid  iLoop ""
5175>                        Loop
5176>                        BlankForm  oRelatedBody
5177>                        Calc (iRecLevel * 5 )                       to WindowIndex
5178>                        Print iChild                             to oRelatedBody.1&
5179>                        Print iField                             to oRelatedBody.2&
5180>                        Print (sChild  + "." + sChildField)      to oRelatedBody.3&
5181>                        Print sFieldTypeChild                    to oRelatedBody.4&
5182>                        Print iFieldNativeLengthChild            to oRelatedBody.5&
5183>                        Print iRelated_File                      to oRelatedBody.6&
5184>                        Print iRelated_Field                     to oRelatedBody.7&
5185>                        Print (sParent + "." + sParentField)     to oRelatedBody.8&
5186>                        Output Channel iChOut oRelatedBody
5188>
5188>                        get item_count of (RelatedFileListGrid(Self)) to iItemCountRelatedFileListGrid //Note this should be the last item + 1
5189>                        Move (iItemCountRelatedFileListGrid - 14) to  iItemCountRelatedFileListGrid
5190>                        set  Value of (RelatedFileListGrid(Self)) item  (iItemCountRelatedFileListGrid + iGridLevelCnt)    to (sChild  + "." + sChildField  )
5191>                        set  Value of (RelatedFileListGrid(Self)) item  (iItemCountRelatedFileListGrid + iGridLevelCnt+1)  to  (sFieldTypeChild + "-" +  sNumber2Str + " ->")
5192>                        set  Value of (RelatedFileListGrid(Self)) item  (iItemCountRelatedFileListGrid + iGridLevelCnt+2)  to (sParent + "." + sParentField )
5193>                    End
5193>                    Add iCol To iItem
5194>                    If (iFieldSortCheckBoxState) If (iItem > (iItmCnt-1)) ;                        If (iLevel Lt iLevelMax)Begin
5200>                             Add 1 to iLevel
5201>                             Move 0 to iItem
5202>                             End
5202>                until  (iItem > (iItmCnt-1))
5204>            End
5204>            Output Channel iChOut oRelatedFooter
5206>            For iLoop From 1 to 14
5212>               Send Add_Item of RelatedFileListGrid  iLoop ""
5213>            Loop
5214>
5214>        End_Procedure
5215>
5215>        Procedure Move_Record  Integer iSource Integer iSourceField Integer iTarget Integer iTargetField
5217>            Integer iType
5218>            String  sType sName sStr2Move
5218>            Number nBCD2Move
5218>            Date  dDate2Move
5218>
5218>            Get_Attribute DF_FIELD_TYPE    Of iTarget iTargetField to sType
5221>            Get_Attribute DF_FIELD_NAME    Of iTarget iTargetField to sName
5224>            Move sType to iType
5225>
5225>            If iType eq DF_ASCII  Get_Field_Value iSource   iSourceField To   sStr2Move
5230>            If iType eq DF_ASCII  Set_Field_Value iTarget   iTargetField To   sStr2Move
5235>
5235>            If iType eq DF_BCD    Get_Field_Value iSource   iSourceField To   nBCD2Move
5240>            If iType eq DF_BCD    Set_Field_Value iTarget   iTargetField To   nBCD2Move
5245>
5245>            If iType eq DF_DATE   Get_Field_Value iSource   iSourceField To   dDate2Move
5250>            If iType eq DF_DATE   Set_Field_Value iTarget   iTargetField To   dDate2Move
5255>
5255>            If iType eq DF_TEXT   Get_Field_Value iSource   iSourceField To   sStr2Move
5260>            If iType eq DF_TEXT   Set_Field_Value iTarget   iTargetField To   sStr2Move
5265>
5265>            If iType eq DF_BINARY Get_Field_Value iSource   iSourceField To   sStr2Move
5270>            If iType eq DF_BINARY Set_Field_Value iTarget   iTargetField To   sStr2Move
5275>        End_Procedure
5276>
5276>        Procedure CloseAllFiles
5278>            Integer iCol  array_id  iItem iItmCnt  iChild iParent iRecLevel
5279>            String   sChild   sParent
5279>            Move 5 to iCol
5280>            move (ReworkListArray(Self)) to array_id
5281>            get item_count of array_id to iItmCnt
5282>            Move 0 to iItem
5283>            If (iItmCnt <> 0) Begin
5285>            repeat
5285>                Move (Integer_value(Array_id,   iItem    )) to iRecLevel
5286>                Move (Integer_value(Array_id,  (iItem+1) )) to iChild
5287>                Move (Integer_value(Array_id,  (iItem+3) )) to iParent
5288>                If (Not(iItem)) Begin
5290>                    Get_Attribute Df_File_Logical_Name Of iChild  To sChild
5293>                    Get_Attribute Df_File_Logical_Name Of iParent To sParent
5296>                    Close iChild
5297>                    Close iParent
5298>                    End
5298>                If     (iItem)  Begin
5300>                    Get_Attribute Df_File_Logical_Name Of iParent To sParent
5303>                    Close iParent
5304>                    End
5304>                Add iCol To iItem
5305>            until (iItem > (iItmCnt-1))
5307>            End
5307>
5307>
5307>        End_Procedure
5308>
5308>
5308>        Procedure OpenAllFiles
5310>            Integer iCol  array_id  iItem iItmCnt  iChild iParent iRecLevel
5311>            String   sChild   sParent
5311>            Move 5 to iCol
5312>            move (ReworkListArray(Self)) to array_id
5313>            get item_count of array_id to iItmCnt
5314>            Move 0 to iItem
5315>            If (iItmCnt <> 0) Begin
5317>            repeat
5317>                Move (Integer_value(Array_id,   iItem    )) to iRecLevel
5318>                Move (Integer_value(Array_id,  (iItem+1) )) to iChild
5319>                Move (Integer_value(Array_id,  (iItem+3) )) to iParent
5320>                If (Not(iItem)) Begin
5322>                    Open iChild
5324>                    Open iParent
5326>                    Get_Attribute Df_File_Logical_Name Of iChild  To sChild
5329>                    Get_Attribute Df_File_Logical_Name Of iParent To sParent
5332>                    End
5332>                If     (iItem)  Begin
5334>                    Open iParent
5336>                    Get_Attribute Df_File_Logical_Name Of iParent To sParent
5339>                    End
5339>                Add iCol To iItem
5340>            until (iItem > (iItmCnt-1))
5342>            End
5342>
5342>
5342>        End_Procedure
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>
5343>        //AB-StoreEnd
5343>
5343>    End_Object    // BuildFileWorkList
5344>
5344>    Object RelatedFileListGrid is a Grid
5346>        Set CurrentRowColor to clYellow
5347>        Set Size to 194 518
5348>        Set Location to 22 1
5349>        Set Highlight_Row_state to TRUE
5350>
5350>        Set Line_Width to 14 0
5351>
5351>        Set Form_Width    item 0 to 125
5352>        Set Header_Label  item 0 to "Child File Relate to"
5353>
5353>        Set Form_Width    item 1 to 45
5354>        Set Header_Label  item 1 to "Type Size"
5355>
5355>        Set Form_Width    item 2 to 125
5356>        Set Header_Label  item 2 to "Related From File Relate To"
5357>
5357>        Set Form_Width    item 3 to 45
5358>        Set Header_Label  item 3 to "Type Size"
5359>
5359>        Set Form_Width    item 4 to 125
5360>        Set Header_Label  item 4 to "Related From File Relate To"
5361>
5361>        Set Form_Width    item 5 to 45
5362>        Set Header_Label  item 5 to "Type Size"
5363>
5363>        Set Form_Width    item 6 to 125
5364>        Set Header_Label  item 6 to "Related From File Relate To"
5365>
5365>        Set Form_Width    item 7 to 45
5366>        Set Header_Label  item 7 to "Type Size"
5367>
5367>        Set Form_Width    item 8 to 125
5368>        Set Header_Label  item 8 to "Related From File Relate To"
5369>
5369>        Set Form_Width    item 9 to 45
5370>        Set Header_Label  item 9 to "Type Size"
5371>
5371>        Set Form_Width    item 10 to 125
5372>        Set Header_Label  item 10 to "Related From File Relate  to"
5373>
5373>        Set Form_Width    item 11 to 45
5374>        Set Header_Label  item 11 to "Type Size"
5375>
5375>        Set Form_Width    item 12 to 125
5376>        Set Header_Label  item 12 to "Related From File Relate to"
5377>
5377>        Set Form_Width    item 13 to 125
5378>        Set Header_Label  item 13 to "Type Size"
5379>
5379>    End_Object    // RelatedFileListGrid
5380>
5380>    Object ReworkListArray is a Array
5382>
5382>        //AB-StoreTopStart
5382>        Property integer  piJumpOver    Public 0
5384>        Property Integer OldErrorId public 0
5386>        Property Integer Error_processing_state public false //  required
5388>
5388>        Procedure Error_report Integer iErrNum Integer iErrLine String sErrText
5390>            Local Integer hId datf
5391>            // Always check that we are not already in an error
5391>            If (error_processing_state(current_object)) Procedure_return
5394>            Set error_processing_State to true // we are now within an error
5395>              //: perform custom error handling
5395>            If (iErrNum = 75) Begin
5397>                Set piJumpOver to True
5398>                //  Get OldErrorId to hId
5398>                //  Send Error_report to hId iErrNum iErrLine sErrText
5398>            End
5398>            Set error_processing_State to false // we are no longer within an error
5399>        End_Procedure
5400>        //AB-StoreTopEnd
5400>
5400>        Set Location to 1 475
5401>
5401>        //AB-StoreStart
5401>        Function OpenFileGetFieldMax Integer iFileNumber Returns Integer
5403>            Integer iFieldMax   iJumpOver
5404>            String sFile_Name
5404>            Get_Attribute Df_File_Logical_Name Of iFileNumber To sFile_Name
5407>            Open iFileNumber
5409>            Get piJumpOver to iJumpOver       // Check for Error
5410>            Set piJumpOver to 0              // Check for Error
5411>            If (iJumpOver) Function_Return 0        // File open Error
5414>            Get_Attribute DF_FILE_NUMBER_FIELDS of iFileNumber to iFieldMax
5417>            Set piJumpOver to False  //PT
5418>            move 0 to iJumpOver
5419>            Function_Return iFieldMax
5420>        End_Function
5421>
5421>        Procedure Build_Process_List Integer iFileNumber
5423>           Integer  iJumpOver  iFieldMax iField  iRelated_File   iRelated_Field iRecnum iRecursionCnt
5424>           Integer  iDF_FIELD_TYPE  hId  iItemCount  icounter iItemCountRec tiItemCountRec  iStartBack
5424>           Integer  iFieldLengthTest  iFieldOffset  iRelatedFieldOffsetTest iProcessOverLaps
5424>           String   sDF_FIELD_NAME  sDriverName  sFile_Name sRelated_File  sRelated_NAME
5424>           Set OldErrorId to Error_object_id        // remember old error object
5425>           Move current_object to Error_object_id   // make self the error object
5426>           Get checked_State of ProcessOverLaps to iProcessOverLaps
5427>           Move 0 to iItemCount
5428>           Move 0 to iRecursionCnt
5429>           Handle   hReworkListArryId  hRecurArrayId
5429>           Move (ReworkListArray(Self))  to hReworkListArryId
5430>           Move (RecurArray(Self))       to hRecurArrayId
5431>           Send delete_data to hReworkListArryId
5432>           Send delete_data to hRecurArrayId
5433>              If iFileNumber eq 48  Procedure_Return
5436>              If iFileNumber Eq 0 Procedure_Return
5439>             Open iFileNumber
5441>             Get piJumpOver to iJumpOver       // Check for Error
5442>             Set piJumpOver to 0              // Check for Error
5443>             If (iJumpOver) Procedure_Return        // File open Error
5446>             Get_Attribute DF_FILE_DRIVER        of iFileNumber to sDriverName
5449>             Get_Attribute DF_FILE_NUMBER_FIELDS of iFileNumber to iFieldMax
5452>             //Note: Break Begin will return to hear with new File # and Max Fields
5452>             For iField From 1 to iFieldMax
5458>                Move 0 to iStartBack
5459>                Get_Attribute Df_File_Logical_Name Of iFileNumber To sFile_Name
5462>                Get_Attribute DF_FIELD_NAME           of iFileNumber iField to sDF_FIELD_NAME
5465>                Get_Attribute DF_FIELD_TYPE           of iFileNumber iField to iDF_FIELD_TYPE
5468>                Get_Attribute DF_FIELD_Related_File   of iFileNumber iField to iRelated_File
5471>                Get_Attribute DF_FIELD_Related_Field  of iFileNumber iField to iRelated_Field
5474>                If (iRelated_File) Begin
5476>                    get item_count of hReworkListArryId to iItemCount //Note this should be the last item + 1
5477>                    set Array_Value of hReworkListArryId item  iItemCount      to iRecursionCnt
5478>                    set Array_Value of hReworkListArryId item (iItemCount + 1) to iFileNumber
5479>                    set Array_Value of hReworkListArryId item (iItemCount + 2) to iField
5480>                    set Array_Value of hReworkListArryId item (iItemCount + 3) to iRelated_File
5481>                    set Array_Value of hReworkListArryId item (iItemCount + 4) to iRelated_Field
5482>                    Move (iRecursionCnt * 3) to iItemCountRec
5483>                    set Array_Value of hRecurArrayId item  iItemCountRec      to iFileNumber
5484>                    set Array_Value of hRecurArrayId item (iItemCountRec + 1) to iField
5485>                    set Array_Value of hRecurArrayId item (iItemCountRec + 2) to iFieldMax
5486>                    Move (OpenFileGetFieldMax(Self,iRelated_File)) to  iFieldMax
5487>                    Get_Attribute Df_File_Logical_Name Of iRelated_File To sRelated_File
5490>                    Get_Attribute DF_FIELD_NAME        of iRelated_File iRelated_Field to sRelated_NAME
5493>
5493>                    If ( iDF_FIELD_TYPE = DF_OVERLAP)Begin
5495>                        If (Not(iProcessOverLaps)) Break
5498>                        get_attribute DF_FIELD_OFFSET of iFileNumber   iField         to iFieldOffset
5501>
5501>                        If ( sDriverName = "DB2_DRV")  get_attribute DF_FIELD_LENGTH        of iFileNumber iField to iFieldLengthTest
5506>                        Else  get_attribute DF_FIELD_NATIVE_LENGTH of iFileNumber iField to iFieldLengthTest
5510>
5510>                        get_attribute DF_FIELD_OFFSET of iRelated_File iRelated_Field to iRelatedFieldOffsetTest
5513>                        Send  Process_OverLaps  iRecursionCnt iFileNumber   iFieldOffset   iRelated_File iRelatedFieldOffsetTest iFieldLengthTest
5514>                        End
5514>
5514>                    Add 1 to iRecursionCnt
5515>                     If (iFieldMax)  Begin
5517>                        Move iRelated_File to  iFileNumber
5518>                        Move 0             to  iField
5519>                        End
5519>                    Else Begin
5520>                        Send Info_Box ("Error Open "  * iFileNumber)
5521>                        Procedure_Return
5522>                        End
5522>                End
5522>                If (iField = iFieldMax) Begin
5524>                    If (iRecursionCnt) Begin
5526>                        Sub 1 From iRecursionCnt
                        Sub 1 From iRecursionCnt
ERROR: 4298 Command not found SUB ON LINE: 718 (5526) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5526>                        Move (iRecursionCnt * 3) to iItemCountRec
5527>                        get Array_Value of hRecurArrayId item  iItemCountRec      to iFileNumber
5528>                        get Array_Value of hRecurArrayId item (iItemCountRec + 1) to iField
5529>                        get Array_Value of hRecurArrayId item (iItemCountRec + 2) to iFieldMax
5530>                        If ((iRecursionCnt) and (iField = iFieldMax)) Break Begin
5533>                        Move 1 to iStartBack
5534>                        End
5534>                    End
5534>                If ((iRelated_File) or (iStartBack) ) Break Begin
5537>             Loop // For iField
5538>            Send delete_data to hRecurArrayId
5539>            Close iFileNumber
5540>            Set piJumpOver to False  //PT
5541>            move 0 to iJumpOver
5542>
5542>           Get OldErrorId to hId
5543>           Move hId to Error_object_id
5544>        End_Procedure //Build_Process_List
5545>
5545>
5545>
5545>
5545>        Procedure Process_OverLaps Integer iRecursionCnt Integer iFileNumber   Integer  iFieldOffsetTest ;                                                         Integer iRelated_File Integer  iRelatedFieldOffsetTest ;                                                         Integer  iFieldLengthTest
5547>           Integer  iJumpOver  iFieldMax iField     iRelated_Field iRecnum   iRelatedFieldMax
5548>           Integer  iDF_FIELD_TYPE  hId  iItemCount  icounter iItemCountRec tiItemCountRec  iStartBack
5548>           Integer  iFieldLength  iFieldOffset iRelatedFieldLength iRelatedFieldOffset iTotalLength
5548>           String   sDF_FIELD_NAME  sDriverName  sFile_Name sRelated_File  sRelated_NAME
5548>           Handle   hReworkListArryId  hRecurArrayId
5548>           Move (ReworkListArray(Self))  to hReworkListArryId
5549>                 Get_Attribute DF_FILE_DRIVER        of iFileNumber to sDriverName
5552>                 Get_Attribute DF_FILE_NUMBER_FIELDS of iFileNumber to iFieldMax
5555>                 Get_Attribute DF_FILE_NUMBER_FIELDS of iRelated_File to iRelatedFieldMax
5558>                 //Note: Break Begin will return to hear with new File # and Max Fields
5558>                 Move 0 to iRelated_Field
5559>                 Move 0 to iTotalLength
5560>
5560>                 For iField From 1 to iFieldMax
5566>                    Get_Attribute DF_FIELD_NAME           of iFileNumber iField to sDF_FIELD_NAME
5569>                    Get_Attribute DF_FIELD_TYPE           of iFileNumber iField to iDF_FIELD_TYPE
5572>                    If ( iDF_FIELD_TYPE <> DF_OVERLAP) Begin
5574>                        Get_Attribute Df_File_Logical_Name Of iFileNumber To sFile_Name
5577>                        get_attribute DF_FIELD_OFFSET of iFileNumber iField to iFieldOffset
5580>
5580>                        If ( sDriverName = "DB2_DRV")  get_attribute DF_FIELD_LENGTH        of iFileNumber iField to iFieldLength
5585>                        Else get_attribute DF_FIELD_NATIVE_LENGTH of iFileNumber iField to iFieldLength
5589>
5589>                        If  (iFieldOffset = iFieldOffsetTest) Begin
5591>                             Repeat
5591>                                Add 1 to iRelated_Field
5592>                                Get_Attribute DF_FIELD_NAME           of iRelated_File iRelated_Field to sDF_FIELD_NAME
5595>                                Get_Attribute DF_FIELD_TYPE           of iRelated_File iRelated_Field to iDF_FIELD_TYPE
5598>                                If ( iDF_FIELD_TYPE <> DF_OVERLAP) Begin
5600>                                    Get_Attribute Df_File_Logical_Name Of iRelated_File To sFile_Name
5603>                                    get_attribute DF_FIELD_OFFSET of iRelated_File iRelated_Field to iRelatedFieldOffset
5606>                                    If ( sDriverName = "DB2_DRV")  get_attribute DF_FIELD_LENGTH        of iRelated_File iRelated_Field to iRelatedFieldLength
5611>                                    Else get_attribute DF_FIELD_NATIVE_LENGTH of iRelated_File iRelated_Field to iRelatedFieldLength
5615>                                    If  (iRelatedFieldOffset Ge iRelatedFieldOffsetTest) Begin
5617>                                        get item_count of hReworkListArryId to iItemCount //Note this should be the last item + 1
5618>                                        set Array_Value of hReworkListArryId item  iItemCount      to iRecursionCnt
5619>                                        set Array_Value of hReworkListArryId item (iItemCount + 1) to iFileNumber
5620>                                        set Array_Value of hReworkListArryId item (iItemCount + 2) to iField
5621>
5621>                                        set Array_Value of hReworkListArryId item (iItemCount + 3) to iRelated_File
5622>                                        set Array_Value of hReworkListArryId item (iItemCount + 4) to iRelated_Field
5623>                                        Add iRelatedFieldLength to iTotalLength
5624>                                        Add 1 to iField
5625>                                    End
5625>                                End
5625>                             If (iTotalLength Ge iFieldLengthTest)  Procedure_Return
5628>                             Until (iRelated_Field = iRelatedFieldMax)
5630>                         End
5630>                    End
5630>                 Loop // For iField
5631>        End_Procedure //Process_OverLaps
5632>
5632>
5632>        Procedure Build_ReworkList
5634>           Integer  iFileNumber  iJumpOver  iFieldMax iField  iRelated_File   iRelated_Field iRecnum
5635>           Integer  iDF_FIELD_TYPE  hId iItemCount  icounter
5635>           String   sDF_FIELD_NAME  sDriverName  sFile_Name
5635>           Handle   hReworkListArryId
5635>
5635>           Move 0 to iFileNumber
5636>           Move (ReworkListArray(Self))  to hReworkListArryId
5637>           Set OldErrorId to Error_object_id        // remember old error object
5638>           Move current_object to Error_object_id   // make self the error object
5639>           Move 0 to iItemCount
5640>
5640>           Repeat
5640>              Get_Attribute  DF_FILE_NEXT_USED  of iFileNumber  To iFileNumber
5643>              If iFileNumber eq 48  Get_Attribute  DF_FILE_NEXT_USED  of iFileNumber  To iFileNumber
5648>              If iFileNumber Eq 0 Break
5651>              If iFileNumber Gt 0 Begin
5653>                 Get_Attribute Df_File_Logical_Name Of iFileNumber To sFile_Name
5656>                 Open iFileNumber
5658>                 Get piJumpOver to iJumpOver       // Check for Error
5659>                 Set piJumpOver to 0              // Check for Error
5660>                 If (iJumpOver) Break        // File open Error
5663>                 Get_Attribute DF_FILE_DRIVER        of iFileNumber to sDriverName
5666>                 Get_Attribute DF_FILE_NUMBER_FIELDS of iFileNumber to iFieldMax
5669>                 For iField From 1 to iFieldMax
5675>                    Get_Attribute DF_FIELD_NAME           of iFileNumber iField to sDF_FIELD_NAME
5678>                    Get_Attribute DF_FIELD_TYPE           of iFileNumber iField to iDF_FIELD_TYPE
5681>                    Get_Attribute DF_FIELD_Related_File   of iFileNumber iField to iRelated_File
5684>                    Get_Attribute DF_FIELD_Related_Field  of iFileNumber iField to iRelated_Field
5687>                    If (iRelated_File) Begin
5689>                        get item_count of hReworkListArryId to iItemCount
5690>                        set array_value of hReworkListArryId item iItemCount to ("C"*(String(iFileNumber))  * "," *   (String(iField)) * "P" *  ;                                                                                (String(iRelated_File)) * "," * (String(iRelated_Field)) )
5691>                        get item_count of hReworkListArryId to icounter
5692>                        End
5692>                 Loop // For iField
5693>                Close iFileNumber
5694>                Set piJumpOver to False  //PT
5695>                move 0 to iJumpOver
5696>              End  //If iFileNumber gt 0
5696>           Loop
5697>
5697>           Get OldErrorId to hId
5698>           Move hId to Error_object_id
5699>        End_Procedure //Build_ReworkList
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>
5700>        //AB-StoreEnd
5700>
5700>    End_Object    // ReworkListArray
5701>
5701>    Object RecurArray is a Array
5703>        Set Location to 0 497
5704>    End_Object    // RecurArray
5705>
5705>    Object Mew32 is a Form
5707>        Set Size to 13 160
5708>        Set Location to 217 355
5709>
5709>        //AB-StoreStart
5709>        Procedure OnChange
5711>            String sMew32Loc
5712>            Integer  iChInOut
5712>            get Seq_New_Channel to iChInOut
5713>            // no channel avaiLabel
5713>            if (iChInOut=DF_SEQ_CHANNEL_NOT_AVAILABLE) begin
5715>                send Info_Box "No Channel AvaiLabel for Output" "Error"
5716>                Procedure_return
5717>                end
5717>            Direct_Output Channel  iChInOut "C:\CodeCrank.Cfg"
5719>            Get Value of (Mew32(Self)) to sMew32Loc
5720>            WriteLn Channel  iChInOut sMew32Loc
5723>            Close_Output Channel  iChInOut
5725>            send Seq_Release_Channel iChInOut
5726>        End_Procedure
5727>
5727>
5727>        //AB-StoreEnd
5727>
5727>    End_Object    // Mew32
5728>
5728>    Object RelatedRpt is a Form
5730>        Set Label to "RelatedRpt.Txt"
5731>        Set Size to 13 160
5732>        Set Location to 236 355
5733>        Set Label_Col_Offset to 10
5734>        Set Label_Justification_Mode to jMode_Right
5735>    End_Object    // RelatedRpt
5736>
5736>    Object PrintLog is a Button
5738>        Set Label to "Print Related Report With"
5739>        Set Size to 14 93
5740>        Set Location to 216 257
5741>
5741>        //AB-StoreStart
5741>        set focus_mode to pointer_only
5742>        Procedure OnClick
5744>            String sRelatedRpt    sMew32    sFullReportStr sReportCsv sTarget
5745>            integer iFileExists
5745>            Get Value of RelatedRpt to sRelatedRpt
5746>            Get Value of Mew32     to sMew32
5747>            Move (sTarget + "\MoveLogHist") to sReportCsv
5748>            Move (Trim(sRelatedRpt))       to sFullReportStr
5749>            Get get_file_exists (Trim(sMew32)) to  iFileExists
5750>            If (iFileExists)   Runprogram Wait ((Trim(sMew32)) * sFullReportStr )
5753>            Else               Runprogram Wait ("NotePad" * (Trim(sRelatedRpt)) )
5755>        End_Procedure // OnClick
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>
5756>        //AB-StoreEnd
5756>
5756>    End_Object    // PrintLog
5757>
5757>    Object FieldSortCheckBox is a CheckBox
5759>        Set Label to "Sort by Build  Order"
5760>        Set Size to 10 77
5761>        Set Location to 0 191
5762>
5762>        //AB-StoreStart
5762>        Procedure onChange
5764>            integer iState
5765>            Get checked_State to iState
5766>            If iState Set Label to "Sort by Child to Parent"
5769>            Else      Set Label to "Sort by Build  Order"
5771>        End_Procedure
5772>
5772>
5772>        //AB-StoreEnd
5772>
5772>    End_Object    // FieldSortCheckBox
5773>
5773>    Object CloseOpenTypeSize is a Button
5775>        Set Label to "Close Type Size"
5776>        Set Size to 14 87
5777>        Set Location to 3 311
5778>
5778>        //AB-StoreStart
5778>        set focus_mode to pointer_only
5779>        Procedure OnClick
5781>           Integer iLoop iTypeSize
5782>           Get piTypeSize to iTypeSize
5783>           If  (Not(iTypeSize)) Begin
5785>               Move 45 to iTypeSize
5786>               Set Label to "Close Type Size"
5787>           End
5787>           Else Begin
5788>                Move  0 to iTypeSize
5789>                Set Label to "Open Type Size"
5790>           End
5790>
5790>           set visible_state of (RelatedFileListGrid(Self)) to False
5791>           For iLoop From 0 to 13
5797>               if (Mod(iLoop, 2))   Set Form_Width of (RelatedFileListGrid(Self)) item iLoop to iTypeSize
5800>           Loop
5801>           set visible_state of (RelatedFileListGrid(Self)) to True
5802>           Set piTypeSize to iTypeSize
5803>        End_Procedure // OnClick
5804>
5804>
5804>
5804>
5804>
5804>
5804>
5804>        //AB-StoreEnd
5804>
5804>    End_Object    // CloseOpenTypeSize
5805>
5805>    Object ProcessOverLaps is a CheckBox
5807>        Set Label to "Don't Break Down Over Laps"
5808>        Set Size to 10 109
5809>        Set Location to 10 191
5810>
5810>        //AB-StoreStart
5810>        Procedure onChange
5812>            integer iState
5813>            Get checked_State to iState
5814>            If iState Set Label to "Break Down Overlaps"
5817>            Else      Set Label to "Don't Break Down Overlaps"
5819>        End_Procedure
5820>
5820>
5820>
5820>        //AB-StoreEnd
5820>
5820>    End_Object    // ProcessOverLaps
5821>
5821>    Object CurrentFileList is a Form
5823>        Set Label to "Current File List"
5824>        Set Size to 13 182
5825>        Set Location to 215 5
5826>        Set Label_Col_Offset to -235
5827>        Set Label_Justification_Mode to jMode_Right
5828>    End_Object    // CurrentFileList
5829>
5829>
5829>    //AB-StoreStart
5829>    // - close Conversion View if open
5829>    // - call WorkSpace Manager to change WorkSpaces
5829>    // - reopen Conversion View
5829>    Procedure ChangeWorkspace
5830>    integer iRetVal iViewID iMenuID iWorkSpaceObj
5831>    string sNewWorkSpace
5831>
5831>    get Object_ID of Main_Menu to iMenuID
ERROR: 300 INVALID OBJECT REFERENCE ON LINE: 1112 (5831) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5831>          get Object_ID of (oRelated(Client_Area(Main(Self)))) to iViewID
ERROR: 54 Invalid symbol in expression CLIENT_AREA ON LINE: 1113 (5831) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28735, |ES28735, |E ON LINE: 1113 (5831) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28735, |ES28735, |ES28735, |E ON LINE: 1113 (5831) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5832>          get Object_ID of (WorkSpace_Selector(self)) to iWorkSpaceObj  //This was sent to Desktop
5833>
5833>    // close view before changing WorkSpace
5833>    if (Active_State(iViewID)) send close_client of iViewID
5836>    //show iWorkspaceObj  //akb
5836>    get Select_Workspace of iWorkSpaceObj to iRetVal
5837>    if (iRetVal=1) begin  // new workspace has been selected
5839>        send CurrentEnv
5840>        send OpenView
5841>        Send delete_data to RelatedFileListGrid
5842>        end
5842>    End_Procedure  // ChangeWorkspace
5843>
5843>    // open Convert View
5843>    Procedure OpenView
5844>    Send Activate_oRelated
5845>    //          send PopUp to oFileList02
5845>    End_Procedure  // OpenView
5846>
5846>    // - open Files for new WorkSpace
5846>    Procedure CurrentEnv
5847>    string sLabel sWorkSpace  sCurrentWorkSpaceName
5848>    integer iWorkSpaceObj
5848>           get Object_ID of (WorkSpace_Selector(oRelated(self))) to iWorkSpaceObj          //This was sent to Desktop
5849>
5849>    get psSelectedWorkspace of iWorkSpaceObj to sWorkSpace
5850>    send DoSetWorkspace of ProgramWorkspace sWorkspace
ERROR: 300 INVALID OBJECT REFERENCE ON LINE: 1140 (5850) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5850>
5850>    Get CurrentWorkSpaceName of (ProgramWorkSpace(Main(Self))) to sCurrentWorkSpaceName
ERROR: 54 Invalid symbol in expression PROGRAMWORKSPACE ON LINE: 1142 (5850) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28843, |ES28843, |E ON LINE: 1142 (5850) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28843, |ES28843, |ES28843, |E ON LINE: 1142 (5850) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5851>    get CurrentWorkspaceDescription of ProgramWorkspace to sWorkSpace
ERROR: 300 INVALID OBJECT REFERENCE ON LINE: 1143 (5851) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5851>    append sLabel "WorkSpace - "  sCurrentWorkSpaceName
5853>    set Label of oRelated to sLabel
5854>    //set Label of Main to sLabel
5854>    End_Procedure  // CurrentEnv
5855>
5855>
5855>    Procedure Activating
5856>       string sLabel sWorkspace sCurrentFileListPath  sCurrentWorkSpaceName sCurrentDataPath sCurrentDDSrcPath
5857>       String sMew32Loc  sReportLog  sSource sTarget sComputerName  sUserName  sFileListName  sCurrentModuleName
5857>       Integer iFileExists   hoFileInformation iChInOut
5857>
5857>       Handle hWinHandel
5857>       Get Window_Handle To hWinHandel
5858>       Set phWinHandel of oRelated to hWinHandel
5859>      //Showln hWinHandel
5859>       forward send Activating
5861>
5861>       get_attribute DF_FILELIST_NAME to sFileListName
5864>
5864>       Get Window_Handle To hWinHandel
5865>       Set phWinHandel to hWinHandel
5866>
5866>       Get CurrentFileListPath  of (ProgramWorkSpace(Self)) to sCurrentFileListPath
ERROR: 54 Invalid symbol in expression PROGRAMWORKSPACE ON LINE: 1166 (5866) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28905, |ES28905, |E ON LINE: 1166 (5866) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28905, |ES28905, |ES28905, |E ON LINE: 1166 (5866) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5867>       Get CurrentWorkSpaceName of (ProgramWorkSpace(Self)) to sCurrentWorkSpaceName
ERROR: 54 Invalid symbol in expression PROGRAMWORKSPACE ON LINE: 1167 (5867) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28905, |ES28905, |E ON LINE: 1167 (5867) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28905, |ES28905, |ES28905, |E ON LINE: 1167 (5867) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5868>       Get CurrentDataPath      of (ProgramWorkSpace(Self)) to sCurrentDataPath
ERROR: 54 Invalid symbol in expression PROGRAMWORKSPACE ON LINE: 1168 (5868) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28905, |ES28905, |E ON LINE: 1168 (5868) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28905, |ES28905, |ES28905, |E ON LINE: 1168 (5868) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5869>       Get CurrentDDSrcPath     of (ProgramWorkSpace(Self)) to sCurrentDDSrcPath
ERROR: 54 Invalid symbol in expression PROGRAMWORKSPACE ON LINE: 1169 (5869) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28905, |ES28905, |E ON LINE: 1169 (5869) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28905, |ES28905, |ES28905, |E ON LINE: 1169 (5869) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5870>       Get CurrentModuleName    of (ProgramWorkSpace(Self)) to sCurrentModuleName
ERROR: 54 Invalid symbol in expression PROGRAMWORKSPACE ON LINE: 1170 (5870) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28905, |ES28905, |E ON LINE: 1170 (5870) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4345 Type check error |ES28905, |ES28905, |ES28905, |E ON LINE: 1170 (5870) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5871>       Set Value of CurrentFileList to sCurrentFileListPath
5872>
5872>       get CurrentWorkspaceDescription of ProgramWorkspace to sWorkSpace
ERROR: 300 INVALID OBJECT REFERENCE ON LINE: 1173 (5872) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5872>
5872>       append sLabel "WorkSpace - " sCurrentWorkSpaceName
5874>       set Label of Main to (sLabel * "  Updated 08-30-01 02:42 PM  ELB" )
ERROR: 300 INVALID OBJECT REFERENCE ON LINE: 1176 (5874) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5874>
5874>        Get get_file_exists "C:\CodeCrank.Cfg" to iFileExists
5875>        If (iFileExists)  Begin
5877>            get Seq_New_Channel to iChInOut
5878>            // no channel avaiLabel
5878>            if (iChInOut=DF_SEQ_CHANNEL_NOT_AVAILABLE) begin
5880>                send Info_Box "No Channel AvaiLabel for Output" "Error"
5881>                Procedure_return
5882>                end
5882>            //send Seq_Release_Channel iChInOut
5882>            Direct_Input Channel  iChInOut "C:\CodeCrank.Cfg"
5884>            Readln       Channel  iChInOut sMew32Loc
5886>            Set Value   of Mew32 to (Trim(sMew32Loc))
5887>            Close_Input Channel   iChInOut
5889>            send Seq_Release_Channel iChInOut
5890>        End
5890>        Else  Begin
5891>           Set Value of Mew32 to "C:\Mew\Mew32.exe"
5892>           Send OnChange to Mew32
5893>           End
5893>
5893>         Get WNetGetUserFunc     to sUserName
5894>         Get GetComputerNameFunc to sComputerName
5895>         Set psUserName     to sUserName
5896>         Set psComputerName to sComputerName
5897>         //Showln " sComputerName " sComputerName " sUserName " sUserName
5897>         Set Label to (sUserName * "Logon From" * sComputerName)
5898>         Set Value of RelatedRpt to ("C:\RelatedRpt_" + sComputerName + ".Txt")
5899>         Move  sCurrentDataPath          to oRelatedHdr.2
5900>         Move  sCurrentFileListPath      to oRelatedHdr.4
5901>         Move  sUserName          to oRelatedHdr.3
5902>         Move  sComputerName      to oRelatedHdr.5
5903>
5903>    //   direct_input channel 9 "C:\LastSourceTarget.Cfg"
5903>    //   [not seqeof] Begin
5903>    //       If  (Not(Seqeof))  ReadLn  sSource
5903>    //       If  (Not(Seqeof))  ReadLn  sTarget
5903>    //       Set Value of Source to sSource
5903>    //       Set Value of Target to sTarget
5903>    //   End
5903>    //   Close_input Channel 9
5903>
5903>    End_Procedure  // Activating
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>
5904>    //AB-StoreEnd
5904>
5904>CD_End_Object    // oRelated
CD_End_Object    // oRelated
ERROR: 4298 Command not found CD_END_OBJECT ON LINE: 1251 (5904) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
5904>
5904>
5904>//AB-StoreStart
5904>
5904>//AB-StoreEnd
5904>
5904>//AB/ End_Object    // prj
5904>
ERROR: 4306 Forward reference not resolved  GET_GET_FILE_EXISTS ON LINE: 956 (5748) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4306 Forward reference not resolved  MSG_CLOSE_CLIENT ON LINE: 1117 (5834) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4306 Forward reference not resolved  MSG_ACTIVATE_ORELATED ON LINE: 1129 (5843) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4306 Forward reference not resolved  MSG_DOSETWORKSPACE ON LINE: 1140 (5849) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4306 Forward reference not resolved  GET_CURRENTWORKSPACEDESCRIPTION ON LINE: 1143 (5850) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4306 Forward reference not resolved  GET_CURRENTFILELISTPATH ON LINE: 1166 (5865) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4306 Forward reference not resolved  GET_CURRENTDATAPATH ON LINE: 1168 (5867) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4306 Forward reference not resolved  GET_CURRENTDDSRCPATH ON LINE: 1169 (5868) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4306 Forward reference not resolved  GET_CURRENTMODULENAME ON LINE: 1170 (5869) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4306 Forward reference not resolved  GET_CURRENTWORKSPACEDESCRIPTION ON LINE: 1173 (5871) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
ERROR: 4306 Forward reference not resolved  GET_GET_FILE_EXISTS ON LINE: 1178 (5873) OF FILE: C:\VDF6\Develop\Empor\AppSrc\FindRelatedFiles.VW
Summary
Memory Available: 2147483647
Total Errors   : 74
Total Symbols  : 6002
Total Resources: 0
Total Commands : 5903
Total Windows  : 38
Total Pages    : 5
Static Data    : 29233
Message area   : 30280
Total Blocks   : 2503
74 ERRORS HAVE BEEN FOUND.
